// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vm

import (
	"context"
	"reflect"

	"errors"
	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/vm"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Example 1: Basic clone with minimal management
//			_, err := vm.NewClonedVirtualMachine(ctx, "basic_clone", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("basic-clone"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//					Full:       pulumi.Bool(true),
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores: pulumi.Int(4),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 2: Clone with explicit network management
//			_, err = vm.NewClonedVirtualMachine(ctx, "network_managed", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("network-clone"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//				},
//				Network: vm.ClonedVirtualMachineNetworkMap{
//					"net0": &vm.ClonedVirtualMachineNetworkArgs{
//						Bridge: pulumi.String("vmbr0"),
//						Model:  pulumi.String("virtio"),
//						Tag:    pulumi.Int(100),
//					},
//					"net1": &vm.ClonedVirtualMachineNetworkArgs{
//						Bridge:     pulumi.String("vmbr1"),
//						Model:      pulumi.String("virtio"),
//						Firewall:   pulumi.Bool(true),
//						MacAddress: pulumi.String("BC:24:11:2E:C5:00"),
//					},
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores: pulumi.Int(2),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 3: Clone with disk management
//			_, err = vm.NewClonedVirtualMachine(ctx, "disk_managed", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("disk-clone"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId:      pulumi.Int(100),
//					TargetDatastore: pulumi.String("local-lvm"),
//				},
//				Disk: vm.ClonedVirtualMachineDiskMap{
//					"scsi0": &vm.ClonedVirtualMachineDiskArgs{
//						DatastoreId: pulumi.String("local-lvm"),
//						SizeGb:      pulumi.Int(50),
//						Discard:     pulumi.String("on"),
//						Ssd:         pulumi.Bool(true),
//					},
//					"scsi1": &vm.ClonedVirtualMachineDiskArgs{
//						DatastoreId: pulumi.String("local-lvm"),
//						SizeGb:      pulumi.Int(100),
//						Backup:      pulumi.Bool(false),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 4: Clone with explicit device deletion
//			_, err = vm.NewClonedVirtualMachine(ctx, "selective_delete", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("minimal-clone"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//				},
//				Network: vm.ClonedVirtualMachineNetworkMap{
//					"net0": &vm.ClonedVirtualMachineNetworkArgs{
//						Bridge: pulumi.String("vmbr0"),
//						Model:  pulumi.String("virtio"),
//					},
//				},
//				Delete: &vm.ClonedVirtualMachineDeleteArgs{
//					Networks: pulumi.StringArray{
//						pulumi.String("net1"),
//						pulumi.String("net2"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 5: Full-featured clone with multiple settings
//			_, err = vm.NewClonedVirtualMachine(ctx, "full_featured", &vm.ClonedVirtualMachineArgs{
//				NodeName:    pulumi.String("pve"),
//				Name:        pulumi.String("production-vm"),
//				Description: pulumi.String("Production VM cloned from template"),
//				Tags: pulumi.StringArray{
//					pulumi.String("production"),
//					pulumi.String("web"),
//				},
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId:      pulumi.Int(100),
//					SourceNodeName:  pulumi.String("pve"),
//					Full:            pulumi.Bool(true),
//					TargetDatastore: pulumi.String("local-lvm"),
//					Retries:         pulumi.Int(3),
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores:        pulumi.Int(8),
//					Sockets:      pulumi.Int(1),
//					Architecture: pulumi.String("x86_64"),
//					Type:         pulumi.String("host"),
//				},
//				Memory: &vm.ClonedVirtualMachineMemoryArgs{
//					Size:    pulumi.Int(8192),
//					Balloon: pulumi.Int(2048),
//					Shares:  pulumi.Int(2000),
//				},
//				Network: vm.ClonedVirtualMachineNetworkMap{
//					"net0": &vm.ClonedVirtualMachineNetworkArgs{
//						Bridge:    pulumi.String("vmbr0"),
//						Model:     pulumi.String("virtio"),
//						Tag:       pulumi.Int(100),
//						Firewall:  pulumi.Bool(true),
//						RateLimit: pulumi.Float64(100),
//					},
//				},
//				Disk: vm.ClonedVirtualMachineDiskMap{
//					"scsi0": &vm.ClonedVirtualMachineDiskArgs{
//						DatastoreId: pulumi.String("local-lvm"),
//						SizeGb:      pulumi.Int(100),
//						Discard:     pulumi.String("on"),
//						Iothread:    pulumi.Bool(true),
//						Ssd:         pulumi.Bool(true),
//						Cache:       pulumi.String("writethrough"),
//					},
//				},
//				Vga: &vm.ClonedVirtualMachineVgaArgs{
//					Type:   pulumi.String("std"),
//					Memory: pulumi.Int(16),
//				},
//				Delete: &vm.ClonedVirtualMachineDeleteArgs{
//					Disks: pulumi.StringArray{
//						pulumi.String("ide2"),
//					},
//				},
//				StopOnDestroy:                    pulumi.Bool(false),
//				PurgeOnDestroy:                   pulumi.Bool(true),
//				DeleteUnreferencedDisksOnDestroy: pulumi.Bool(false),
//				Timeouts: &vm.ClonedVirtualMachineTimeoutsArgs{
//					Create: pulumi.String("30m"),
//					Update: pulumi.String("30m"),
//					Delete: pulumi.String("10m"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 6: Linked clone for testing
//			_, err = vm.NewClonedVirtualMachine(ctx, "test_clone", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("test-vm"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//					Full:       pulumi.Bool(false),
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores: pulumi.Int(2),
//				},
//				Network: vm.ClonedVirtualMachineNetworkMap{
//					"net0": &vm.ClonedVirtualMachineNetworkArgs{
//						Bridge: pulumi.String("vmbr0"),
//						Model:  pulumi.String("virtio"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 7: Clone with pool assignment
//			_, err = vm.NewClonedVirtualMachine(ctx, "pooled_clone", &vm.ClonedVirtualMachineArgs{
//				NodeName: pulumi.String("pve"),
//				Name:     pulumi.String("pooled-vm"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//					PoolId:     pulumi.String("production"),
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores: pulumi.Int(4),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example 8: Import existing cloned VM
//			_, err = vm.NewClonedVirtualMachine(ctx, "imported", &vm.ClonedVirtualMachineArgs{
//				VmId:     pulumi.String("123"),
//				NodeName: pulumi.String("pve"),
//				Clone: &vm.ClonedVirtualMachineCloneArgs{
//					SourceVmId: pulumi.Int(100),
//				},
//				Cpu: &vm.ClonedVirtualMachineCpuArgs{
//					Cores: pulumi.Int(4),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type ClonedVirtualMachine struct {
	pulumi.CustomResourceState

	// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
	Cdrom ClonedVirtualMachineCdromMapOutput `pulumi:"cdrom"`
	// Clone settings. Changes require recreation.
	Clone ClonedVirtualMachineCloneOutput `pulumi:"clone"`
	// The CPU configuration.
	Cpu ClonedVirtualMachineCpuPtrOutput `pulumi:"cpu"`
	// Explicit deletions to perform after cloning/updating. Entries persist across applies.
	Delete                           ClonedVirtualMachineDeletePtrOutput `pulumi:"delete"`
	DeleteUnreferencedDisksOnDestroy pulumi.BoolOutput                   `pulumi:"deleteUnreferencedDisksOnDestroy"`
	// Optional VM description applied after cloning.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
	Disk ClonedVirtualMachineDiskMapOutput `pulumi:"disk"`
	// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
	Memory ClonedVirtualMachineMemoryPtrOutput `pulumi:"memory"`
	// Optional VM name override applied after cloning.
	Name pulumi.StringOutput `pulumi:"name"`
	// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
	Network ClonedVirtualMachineNetworkMapOutput `pulumi:"network"`
	// Target node for the cloned VM.
	NodeName pulumi.StringOutput `pulumi:"nodeName"`
	// Purge backup configuration on destroy.
	PurgeOnDestroy pulumi.BoolOutput `pulumi:"purgeOnDestroy"`
	// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
	Rng ClonedVirtualMachineRngPtrOutput `pulumi:"rng"`
	// Stop the VM on destroy (instead of shutdown).
	StopOnDestroy pulumi.BoolOutput `pulumi:"stopOnDestroy"`
	// Tags applied after cloning.
	Tags     pulumi.StringArrayOutput              `pulumi:"tags"`
	Timeouts ClonedVirtualMachineTimeoutsPtrOutput `pulumi:"timeouts"`
	// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
	Vga ClonedVirtualMachineVgaPtrOutput `pulumi:"vga"`
	// The VM identifier in the Proxmox cluster.
	VmId pulumi.StringOutput `pulumi:"vmId"`
}

// NewClonedVirtualMachine registers a new resource with the given unique name, arguments, and options.
func NewClonedVirtualMachine(ctx *pulumi.Context,
	name string, args *ClonedVirtualMachineArgs, opts ...pulumi.ResourceOption) (*ClonedVirtualMachine, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Clone == nil {
		return nil, errors.New("invalid value for required argument 'Clone'")
	}
	if args.NodeName == nil {
		return nil, errors.New("invalid value for required argument 'NodeName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ClonedVirtualMachine
	err := ctx.RegisterResource("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClonedVirtualMachine gets an existing ClonedVirtualMachine resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClonedVirtualMachine(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClonedVirtualMachineState, opts ...pulumi.ResourceOption) (*ClonedVirtualMachine, error) {
	var resource ClonedVirtualMachine
	err := ctx.ReadResource("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClonedVirtualMachine resources.
type clonedVirtualMachineState struct {
	// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
	Cdrom map[string]ClonedVirtualMachineCdrom `pulumi:"cdrom"`
	// Clone settings. Changes require recreation.
	Clone *ClonedVirtualMachineClone `pulumi:"clone"`
	// The CPU configuration.
	Cpu *ClonedVirtualMachineCpu `pulumi:"cpu"`
	// Explicit deletions to perform after cloning/updating. Entries persist across applies.
	Delete                           *ClonedVirtualMachineDelete `pulumi:"delete"`
	DeleteUnreferencedDisksOnDestroy *bool                       `pulumi:"deleteUnreferencedDisksOnDestroy"`
	// Optional VM description applied after cloning.
	Description *string `pulumi:"description"`
	// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
	Disk map[string]ClonedVirtualMachineDisk `pulumi:"disk"`
	// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
	Memory *ClonedVirtualMachineMemory `pulumi:"memory"`
	// Optional VM name override applied after cloning.
	Name *string `pulumi:"name"`
	// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
	Network map[string]ClonedVirtualMachineNetwork `pulumi:"network"`
	// Target node for the cloned VM.
	NodeName *string `pulumi:"nodeName"`
	// Purge backup configuration on destroy.
	PurgeOnDestroy *bool `pulumi:"purgeOnDestroy"`
	// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
	Rng *ClonedVirtualMachineRng `pulumi:"rng"`
	// Stop the VM on destroy (instead of shutdown).
	StopOnDestroy *bool `pulumi:"stopOnDestroy"`
	// Tags applied after cloning.
	Tags     []string                      `pulumi:"tags"`
	Timeouts *ClonedVirtualMachineTimeouts `pulumi:"timeouts"`
	// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
	Vga *ClonedVirtualMachineVga `pulumi:"vga"`
	// The VM identifier in the Proxmox cluster.
	VmId *string `pulumi:"vmId"`
}

type ClonedVirtualMachineState struct {
	// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
	Cdrom ClonedVirtualMachineCdromMapInput
	// Clone settings. Changes require recreation.
	Clone ClonedVirtualMachineClonePtrInput
	// The CPU configuration.
	Cpu ClonedVirtualMachineCpuPtrInput
	// Explicit deletions to perform after cloning/updating. Entries persist across applies.
	Delete                           ClonedVirtualMachineDeletePtrInput
	DeleteUnreferencedDisksOnDestroy pulumi.BoolPtrInput
	// Optional VM description applied after cloning.
	Description pulumi.StringPtrInput
	// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
	Disk ClonedVirtualMachineDiskMapInput
	// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
	Memory ClonedVirtualMachineMemoryPtrInput
	// Optional VM name override applied after cloning.
	Name pulumi.StringPtrInput
	// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
	Network ClonedVirtualMachineNetworkMapInput
	// Target node for the cloned VM.
	NodeName pulumi.StringPtrInput
	// Purge backup configuration on destroy.
	PurgeOnDestroy pulumi.BoolPtrInput
	// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
	Rng ClonedVirtualMachineRngPtrInput
	// Stop the VM on destroy (instead of shutdown).
	StopOnDestroy pulumi.BoolPtrInput
	// Tags applied after cloning.
	Tags     pulumi.StringArrayInput
	Timeouts ClonedVirtualMachineTimeoutsPtrInput
	// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
	Vga ClonedVirtualMachineVgaPtrInput
	// The VM identifier in the Proxmox cluster.
	VmId pulumi.StringPtrInput
}

func (ClonedVirtualMachineState) ElementType() reflect.Type {
	return reflect.TypeOf((*clonedVirtualMachineState)(nil)).Elem()
}

type clonedVirtualMachineArgs struct {
	// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
	Cdrom map[string]ClonedVirtualMachineCdrom `pulumi:"cdrom"`
	// Clone settings. Changes require recreation.
	Clone ClonedVirtualMachineClone `pulumi:"clone"`
	// The CPU configuration.
	Cpu *ClonedVirtualMachineCpu `pulumi:"cpu"`
	// Explicit deletions to perform after cloning/updating. Entries persist across applies.
	Delete                           *ClonedVirtualMachineDelete `pulumi:"delete"`
	DeleteUnreferencedDisksOnDestroy *bool                       `pulumi:"deleteUnreferencedDisksOnDestroy"`
	// Optional VM description applied after cloning.
	Description *string `pulumi:"description"`
	// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
	Disk map[string]ClonedVirtualMachineDisk `pulumi:"disk"`
	// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
	Memory *ClonedVirtualMachineMemory `pulumi:"memory"`
	// Optional VM name override applied after cloning.
	Name *string `pulumi:"name"`
	// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
	Network map[string]ClonedVirtualMachineNetwork `pulumi:"network"`
	// Target node for the cloned VM.
	NodeName string `pulumi:"nodeName"`
	// Purge backup configuration on destroy.
	PurgeOnDestroy *bool `pulumi:"purgeOnDestroy"`
	// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
	Rng *ClonedVirtualMachineRng `pulumi:"rng"`
	// Stop the VM on destroy (instead of shutdown).
	StopOnDestroy *bool `pulumi:"stopOnDestroy"`
	// Tags applied after cloning.
	Tags     []string                      `pulumi:"tags"`
	Timeouts *ClonedVirtualMachineTimeouts `pulumi:"timeouts"`
	// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
	Vga *ClonedVirtualMachineVga `pulumi:"vga"`
	// The VM identifier in the Proxmox cluster.
	VmId *string `pulumi:"vmId"`
}

// The set of arguments for constructing a ClonedVirtualMachine resource.
type ClonedVirtualMachineArgs struct {
	// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
	Cdrom ClonedVirtualMachineCdromMapInput
	// Clone settings. Changes require recreation.
	Clone ClonedVirtualMachineCloneInput
	// The CPU configuration.
	Cpu ClonedVirtualMachineCpuPtrInput
	// Explicit deletions to perform after cloning/updating. Entries persist across applies.
	Delete                           ClonedVirtualMachineDeletePtrInput
	DeleteUnreferencedDisksOnDestroy pulumi.BoolPtrInput
	// Optional VM description applied after cloning.
	Description pulumi.StringPtrInput
	// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
	Disk ClonedVirtualMachineDiskMapInput
	// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
	Memory ClonedVirtualMachineMemoryPtrInput
	// Optional VM name override applied after cloning.
	Name pulumi.StringPtrInput
	// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
	Network ClonedVirtualMachineNetworkMapInput
	// Target node for the cloned VM.
	NodeName pulumi.StringInput
	// Purge backup configuration on destroy.
	PurgeOnDestroy pulumi.BoolPtrInput
	// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
	Rng ClonedVirtualMachineRngPtrInput
	// Stop the VM on destroy (instead of shutdown).
	StopOnDestroy pulumi.BoolPtrInput
	// Tags applied after cloning.
	Tags     pulumi.StringArrayInput
	Timeouts ClonedVirtualMachineTimeoutsPtrInput
	// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
	Vga ClonedVirtualMachineVgaPtrInput
	// The VM identifier in the Proxmox cluster.
	VmId pulumi.StringPtrInput
}

func (ClonedVirtualMachineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clonedVirtualMachineArgs)(nil)).Elem()
}

type ClonedVirtualMachineInput interface {
	pulumi.Input

	ToClonedVirtualMachineOutput() ClonedVirtualMachineOutput
	ToClonedVirtualMachineOutputWithContext(ctx context.Context) ClonedVirtualMachineOutput
}

func (*ClonedVirtualMachine) ElementType() reflect.Type {
	return reflect.TypeOf((**ClonedVirtualMachine)(nil)).Elem()
}

func (i *ClonedVirtualMachine) ToClonedVirtualMachineOutput() ClonedVirtualMachineOutput {
	return i.ToClonedVirtualMachineOutputWithContext(context.Background())
}

func (i *ClonedVirtualMachine) ToClonedVirtualMachineOutputWithContext(ctx context.Context) ClonedVirtualMachineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClonedVirtualMachineOutput)
}

// ClonedVirtualMachineArrayInput is an input type that accepts ClonedVirtualMachineArray and ClonedVirtualMachineArrayOutput values.
// You can construct a concrete instance of `ClonedVirtualMachineArrayInput` via:
//
//	ClonedVirtualMachineArray{ ClonedVirtualMachineArgs{...} }
type ClonedVirtualMachineArrayInput interface {
	pulumi.Input

	ToClonedVirtualMachineArrayOutput() ClonedVirtualMachineArrayOutput
	ToClonedVirtualMachineArrayOutputWithContext(context.Context) ClonedVirtualMachineArrayOutput
}

type ClonedVirtualMachineArray []ClonedVirtualMachineInput

func (ClonedVirtualMachineArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClonedVirtualMachine)(nil)).Elem()
}

func (i ClonedVirtualMachineArray) ToClonedVirtualMachineArrayOutput() ClonedVirtualMachineArrayOutput {
	return i.ToClonedVirtualMachineArrayOutputWithContext(context.Background())
}

func (i ClonedVirtualMachineArray) ToClonedVirtualMachineArrayOutputWithContext(ctx context.Context) ClonedVirtualMachineArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClonedVirtualMachineArrayOutput)
}

// ClonedVirtualMachineMapInput is an input type that accepts ClonedVirtualMachineMap and ClonedVirtualMachineMapOutput values.
// You can construct a concrete instance of `ClonedVirtualMachineMapInput` via:
//
//	ClonedVirtualMachineMap{ "key": ClonedVirtualMachineArgs{...} }
type ClonedVirtualMachineMapInput interface {
	pulumi.Input

	ToClonedVirtualMachineMapOutput() ClonedVirtualMachineMapOutput
	ToClonedVirtualMachineMapOutputWithContext(context.Context) ClonedVirtualMachineMapOutput
}

type ClonedVirtualMachineMap map[string]ClonedVirtualMachineInput

func (ClonedVirtualMachineMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClonedVirtualMachine)(nil)).Elem()
}

func (i ClonedVirtualMachineMap) ToClonedVirtualMachineMapOutput() ClonedVirtualMachineMapOutput {
	return i.ToClonedVirtualMachineMapOutputWithContext(context.Background())
}

func (i ClonedVirtualMachineMap) ToClonedVirtualMachineMapOutputWithContext(ctx context.Context) ClonedVirtualMachineMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClonedVirtualMachineMapOutput)
}

type ClonedVirtualMachineOutput struct{ *pulumi.OutputState }

func (ClonedVirtualMachineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClonedVirtualMachine)(nil)).Elem()
}

func (o ClonedVirtualMachineOutput) ToClonedVirtualMachineOutput() ClonedVirtualMachineOutput {
	return o
}

func (o ClonedVirtualMachineOutput) ToClonedVirtualMachineOutputWithContext(ctx context.Context) ClonedVirtualMachineOutput {
	return o
}

// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
func (o ClonedVirtualMachineOutput) Cdrom() ClonedVirtualMachineCdromMapOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineCdromMapOutput { return v.Cdrom }).(ClonedVirtualMachineCdromMapOutput)
}

// Clone settings. Changes require recreation.
func (o ClonedVirtualMachineOutput) Clone() ClonedVirtualMachineCloneOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineCloneOutput { return v.Clone }).(ClonedVirtualMachineCloneOutput)
}

// The CPU configuration.
func (o ClonedVirtualMachineOutput) Cpu() ClonedVirtualMachineCpuPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineCpuPtrOutput { return v.Cpu }).(ClonedVirtualMachineCpuPtrOutput)
}

// Explicit deletions to perform after cloning/updating. Entries persist across applies.
func (o ClonedVirtualMachineOutput) Delete() ClonedVirtualMachineDeletePtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineDeletePtrOutput { return v.Delete }).(ClonedVirtualMachineDeletePtrOutput)
}

func (o ClonedVirtualMachineOutput) DeleteUnreferencedDisksOnDestroy() pulumi.BoolOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.BoolOutput { return v.DeleteUnreferencedDisksOnDestroy }).(pulumi.BoolOutput)
}

// Optional VM description applied after cloning.
func (o ClonedVirtualMachineOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
func (o ClonedVirtualMachineOutput) Disk() ClonedVirtualMachineDiskMapOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineDiskMapOutput { return v.Disk }).(ClonedVirtualMachineDiskMapOutput)
}

// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
func (o ClonedVirtualMachineOutput) Memory() ClonedVirtualMachineMemoryPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineMemoryPtrOutput { return v.Memory }).(ClonedVirtualMachineMemoryPtrOutput)
}

// Optional VM name override applied after cloning.
func (o ClonedVirtualMachineOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
func (o ClonedVirtualMachineOutput) Network() ClonedVirtualMachineNetworkMapOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineNetworkMapOutput { return v.Network }).(ClonedVirtualMachineNetworkMapOutput)
}

// Target node for the cloned VM.
func (o ClonedVirtualMachineOutput) NodeName() pulumi.StringOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.StringOutput { return v.NodeName }).(pulumi.StringOutput)
}

// Purge backup configuration on destroy.
func (o ClonedVirtualMachineOutput) PurgeOnDestroy() pulumi.BoolOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.BoolOutput { return v.PurgeOnDestroy }).(pulumi.BoolOutput)
}

// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
func (o ClonedVirtualMachineOutput) Rng() ClonedVirtualMachineRngPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineRngPtrOutput { return v.Rng }).(ClonedVirtualMachineRngPtrOutput)
}

// Stop the VM on destroy (instead of shutdown).
func (o ClonedVirtualMachineOutput) StopOnDestroy() pulumi.BoolOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.BoolOutput { return v.StopOnDestroy }).(pulumi.BoolOutput)
}

// Tags applied after cloning.
func (o ClonedVirtualMachineOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

func (o ClonedVirtualMachineOutput) Timeouts() ClonedVirtualMachineTimeoutsPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineTimeoutsPtrOutput { return v.Timeouts }).(ClonedVirtualMachineTimeoutsPtrOutput)
}

// Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
func (o ClonedVirtualMachineOutput) Vga() ClonedVirtualMachineVgaPtrOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) ClonedVirtualMachineVgaPtrOutput { return v.Vga }).(ClonedVirtualMachineVgaPtrOutput)
}

// The VM identifier in the Proxmox cluster.
func (o ClonedVirtualMachineOutput) VmId() pulumi.StringOutput {
	return o.ApplyT(func(v *ClonedVirtualMachine) pulumi.StringOutput { return v.VmId }).(pulumi.StringOutput)
}

type ClonedVirtualMachineArrayOutput struct{ *pulumi.OutputState }

func (ClonedVirtualMachineArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClonedVirtualMachine)(nil)).Elem()
}

func (o ClonedVirtualMachineArrayOutput) ToClonedVirtualMachineArrayOutput() ClonedVirtualMachineArrayOutput {
	return o
}

func (o ClonedVirtualMachineArrayOutput) ToClonedVirtualMachineArrayOutputWithContext(ctx context.Context) ClonedVirtualMachineArrayOutput {
	return o
}

func (o ClonedVirtualMachineArrayOutput) Index(i pulumi.IntInput) ClonedVirtualMachineOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClonedVirtualMachine {
		return vs[0].([]*ClonedVirtualMachine)[vs[1].(int)]
	}).(ClonedVirtualMachineOutput)
}

type ClonedVirtualMachineMapOutput struct{ *pulumi.OutputState }

func (ClonedVirtualMachineMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClonedVirtualMachine)(nil)).Elem()
}

func (o ClonedVirtualMachineMapOutput) ToClonedVirtualMachineMapOutput() ClonedVirtualMachineMapOutput {
	return o
}

func (o ClonedVirtualMachineMapOutput) ToClonedVirtualMachineMapOutputWithContext(ctx context.Context) ClonedVirtualMachineMapOutput {
	return o
}

func (o ClonedVirtualMachineMapOutput) MapIndex(k pulumi.StringInput) ClonedVirtualMachineOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClonedVirtualMachine {
		return vs[0].(map[string]*ClonedVirtualMachine)[vs[1].(string)]
	}).(ClonedVirtualMachineOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClonedVirtualMachineInput)(nil)).Elem(), &ClonedVirtualMachine{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClonedVirtualMachineArrayInput)(nil)).Elem(), ClonedVirtualMachineArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClonedVirtualMachineMapInput)(nil)).Elem(), ClonedVirtualMachineMap{})
	pulumi.RegisterOutputType(ClonedVirtualMachineOutput{})
	pulumi.RegisterOutputType(ClonedVirtualMachineArrayOutput{})
	pulumi.RegisterOutputType(ClonedVirtualMachineMapOutput{})
}
