// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mapping

import (
	"context"
	"reflect"

	"github.com/muhlba91/pulumi-proxmoxve/sdk/v6/go/proxmoxve/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type PciMapType struct {
	// The comment of the mapped PCI device.
	Comment *string `pulumi:"comment"`
	// The ID of the map.
	Id string `pulumi:"id"`
	// The IOMMU group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
	IommuGroup *int `pulumi:"iommuGroup"`
	// The node name of the map.
	Node string `pulumi:"node"`
	// The path of the map.
	Path string `pulumi:"path"`
	// The subsystem ID group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
	SubsystemId *string `pulumi:"subsystemId"`
}

// PciMapTypeInput is an input type that accepts PciMapTypeArgs and PciMapTypeOutput values.
// You can construct a concrete instance of `PciMapTypeInput` via:
//
//	PciMapTypeArgs{...}
type PciMapTypeInput interface {
	pulumi.Input

	ToPciMapTypeOutput() PciMapTypeOutput
	ToPciMapTypeOutputWithContext(context.Context) PciMapTypeOutput
}

type PciMapTypeArgs struct {
	// The comment of the mapped PCI device.
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// The ID of the map.
	Id pulumi.StringInput `pulumi:"id"`
	// The IOMMU group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
	IommuGroup pulumi.IntPtrInput `pulumi:"iommuGroup"`
	// The node name of the map.
	Node pulumi.StringInput `pulumi:"node"`
	// The path of the map.
	Path pulumi.StringInput `pulumi:"path"`
	// The subsystem ID group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
	SubsystemId pulumi.StringPtrInput `pulumi:"subsystemId"`
}

func (PciMapTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PciMapType)(nil)).Elem()
}

func (i PciMapTypeArgs) ToPciMapTypeOutput() PciMapTypeOutput {
	return i.ToPciMapTypeOutputWithContext(context.Background())
}

func (i PciMapTypeArgs) ToPciMapTypeOutputWithContext(ctx context.Context) PciMapTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PciMapTypeOutput)
}

// PciMapTypeArrayInput is an input type that accepts PciMapTypeArray and PciMapTypeArrayOutput values.
// You can construct a concrete instance of `PciMapTypeArrayInput` via:
//
//	PciMapTypeArray{ PciMapTypeArgs{...} }
type PciMapTypeArrayInput interface {
	pulumi.Input

	ToPciMapTypeArrayOutput() PciMapTypeArrayOutput
	ToPciMapTypeArrayOutputWithContext(context.Context) PciMapTypeArrayOutput
}

type PciMapTypeArray []PciMapTypeInput

func (PciMapTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PciMapType)(nil)).Elem()
}

func (i PciMapTypeArray) ToPciMapTypeArrayOutput() PciMapTypeArrayOutput {
	return i.ToPciMapTypeArrayOutputWithContext(context.Background())
}

func (i PciMapTypeArray) ToPciMapTypeArrayOutputWithContext(ctx context.Context) PciMapTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PciMapTypeArrayOutput)
}

type PciMapTypeOutput struct{ *pulumi.OutputState }

func (PciMapTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PciMapType)(nil)).Elem()
}

func (o PciMapTypeOutput) ToPciMapTypeOutput() PciMapTypeOutput {
	return o
}

func (o PciMapTypeOutput) ToPciMapTypeOutputWithContext(ctx context.Context) PciMapTypeOutput {
	return o
}

// The comment of the mapped PCI device.
func (o PciMapTypeOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PciMapType) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// The ID of the map.
func (o PciMapTypeOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v PciMapType) string { return v.Id }).(pulumi.StringOutput)
}

// The IOMMU group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
func (o PciMapTypeOutput) IommuGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PciMapType) *int { return v.IommuGroup }).(pulumi.IntPtrOutput)
}

// The node name of the map.
func (o PciMapTypeOutput) Node() pulumi.StringOutput {
	return o.ApplyT(func(v PciMapType) string { return v.Node }).(pulumi.StringOutput)
}

// The path of the map.
func (o PciMapTypeOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v PciMapType) string { return v.Path }).(pulumi.StringOutput)
}

// The subsystem ID group of the map. Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set
func (o PciMapTypeOutput) SubsystemId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PciMapType) *string { return v.SubsystemId }).(pulumi.StringPtrOutput)
}

type PciMapTypeArrayOutput struct{ *pulumi.OutputState }

func (PciMapTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PciMapType)(nil)).Elem()
}

func (o PciMapTypeArrayOutput) ToPciMapTypeArrayOutput() PciMapTypeArrayOutput {
	return o
}

func (o PciMapTypeArrayOutput) ToPciMapTypeArrayOutputWithContext(ctx context.Context) PciMapTypeArrayOutput {
	return o
}

func (o PciMapTypeArrayOutput) Index(i pulumi.IntInput) PciMapTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PciMapType {
		return vs[0].([]PciMapType)[vs[1].(int)]
	}).(PciMapTypeOutput)
}

type UsbMapType struct {
	// The comment of the mapped USB device.
	Comment *string `pulumi:"comment"`
	// The ID of the map.
	Id string `pulumi:"id"`
	// The node name of the map.
	Node string `pulumi:"node"`
	// The path of the map. For hardware mappings of type USB the path is optional and indicates that the device is mapped through the device ID instead of ports.
	Path *string `pulumi:"path"`
}

// UsbMapTypeInput is an input type that accepts UsbMapTypeArgs and UsbMapTypeOutput values.
// You can construct a concrete instance of `UsbMapTypeInput` via:
//
//	UsbMapTypeArgs{...}
type UsbMapTypeInput interface {
	pulumi.Input

	ToUsbMapTypeOutput() UsbMapTypeOutput
	ToUsbMapTypeOutputWithContext(context.Context) UsbMapTypeOutput
}

type UsbMapTypeArgs struct {
	// The comment of the mapped USB device.
	Comment pulumi.StringPtrInput `pulumi:"comment"`
	// The ID of the map.
	Id pulumi.StringInput `pulumi:"id"`
	// The node name of the map.
	Node pulumi.StringInput `pulumi:"node"`
	// The path of the map. For hardware mappings of type USB the path is optional and indicates that the device is mapped through the device ID instead of ports.
	Path pulumi.StringPtrInput `pulumi:"path"`
}

func (UsbMapTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UsbMapType)(nil)).Elem()
}

func (i UsbMapTypeArgs) ToUsbMapTypeOutput() UsbMapTypeOutput {
	return i.ToUsbMapTypeOutputWithContext(context.Background())
}

func (i UsbMapTypeArgs) ToUsbMapTypeOutputWithContext(ctx context.Context) UsbMapTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsbMapTypeOutput)
}

// UsbMapTypeArrayInput is an input type that accepts UsbMapTypeArray and UsbMapTypeArrayOutput values.
// You can construct a concrete instance of `UsbMapTypeArrayInput` via:
//
//	UsbMapTypeArray{ UsbMapTypeArgs{...} }
type UsbMapTypeArrayInput interface {
	pulumi.Input

	ToUsbMapTypeArrayOutput() UsbMapTypeArrayOutput
	ToUsbMapTypeArrayOutputWithContext(context.Context) UsbMapTypeArrayOutput
}

type UsbMapTypeArray []UsbMapTypeInput

func (UsbMapTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UsbMapType)(nil)).Elem()
}

func (i UsbMapTypeArray) ToUsbMapTypeArrayOutput() UsbMapTypeArrayOutput {
	return i.ToUsbMapTypeArrayOutputWithContext(context.Background())
}

func (i UsbMapTypeArray) ToUsbMapTypeArrayOutputWithContext(ctx context.Context) UsbMapTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsbMapTypeArrayOutput)
}

type UsbMapTypeOutput struct{ *pulumi.OutputState }

func (UsbMapTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UsbMapType)(nil)).Elem()
}

func (o UsbMapTypeOutput) ToUsbMapTypeOutput() UsbMapTypeOutput {
	return o
}

func (o UsbMapTypeOutput) ToUsbMapTypeOutputWithContext(ctx context.Context) UsbMapTypeOutput {
	return o
}

// The comment of the mapped USB device.
func (o UsbMapTypeOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UsbMapType) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

// The ID of the map.
func (o UsbMapTypeOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v UsbMapType) string { return v.Id }).(pulumi.StringOutput)
}

// The node name of the map.
func (o UsbMapTypeOutput) Node() pulumi.StringOutput {
	return o.ApplyT(func(v UsbMapType) string { return v.Node }).(pulumi.StringOutput)
}

// The path of the map. For hardware mappings of type USB the path is optional and indicates that the device is mapped through the device ID instead of ports.
func (o UsbMapTypeOutput) Path() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UsbMapType) *string { return v.Path }).(pulumi.StringPtrOutput)
}

type UsbMapTypeArrayOutput struct{ *pulumi.OutputState }

func (UsbMapTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UsbMapType)(nil)).Elem()
}

func (o UsbMapTypeArrayOutput) ToUsbMapTypeArrayOutput() UsbMapTypeArrayOutput {
	return o
}

func (o UsbMapTypeArrayOutput) ToUsbMapTypeArrayOutputWithContext(ctx context.Context) UsbMapTypeArrayOutput {
	return o
}

func (o UsbMapTypeArrayOutput) Index(i pulumi.IntInput) UsbMapTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UsbMapType {
		return vs[0].([]UsbMapType)[vs[1].(int)]
	}).(UsbMapTypeOutput)
}

type GetPciMap struct {
	// The comment of the mapped PCI device.
	Comment string `pulumi:"comment"`
	// The ID attribute of the map.
	Id string `pulumi:"id"`
	// The IOMMU group attribute of the map.
	IommuGroup int `pulumi:"iommuGroup"`
	// The node name attribute of the map.
	Node string `pulumi:"node"`
	// The path attribute of the map.
	Path string `pulumi:"path"`
	// The subsystem ID attribute of the map.Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set.
	SubsystemId string `pulumi:"subsystemId"`
}

// GetPciMapInput is an input type that accepts GetPciMap and GetPciMapOutput values.
// You can construct a concrete instance of `GetPciMapInput` via:
//
//	GetPciMap{ "key": GetPciArgs{...} }
type GetPciMapInput interface {
	pulumi.Input

	ToGetPciMapOutput() GetPciMapOutput
	ToGetPciMapOutputWithContext(context.Context) GetPciMapOutput
}

type GetPciMapArgs struct {
	// The comment of the mapped PCI device.
	Comment pulumi.StringInput `pulumi:"comment"`
	// The ID attribute of the map.
	Id pulumi.StringInput `pulumi:"id"`
	// The IOMMU group attribute of the map.
	IommuGroup pulumi.IntInput `pulumi:"iommuGroup"`
	// The node name attribute of the map.
	Node pulumi.StringInput `pulumi:"node"`
	// The path attribute of the map.
	Path pulumi.StringInput `pulumi:"path"`
	// The subsystem ID attribute of the map.Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set.
	SubsystemId pulumi.StringInput `pulumi:"subsystemId"`
}

func (GetPciMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetPciMap)(nil)).Elem()
}

func (i GetPciMapArgs) ToGetPciMapOutput() GetPciMapOutput {
	return i.ToGetPciMapOutputWithContext(context.Background())
}

func (i GetPciMapArgs) ToGetPciMapOutputWithContext(ctx context.Context) GetPciMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetPciMapOutput)
}

// GetPciMapArrayInput is an input type that accepts GetPciMapArray and GetPciMapArrayOutput values.
// You can construct a concrete instance of `GetPciMapArrayInput` via:
//
//	GetPciMapArray{ GetPciMapArgs{...} }
type GetPciMapArrayInput interface {
	pulumi.Input

	ToGetPciMapArrayOutput() GetPciMapArrayOutput
	ToGetPciMapArrayOutputWithContext(context.Context) GetPciMapArrayOutput
}

type GetPciMapArray []GetPciMapInput

func (GetPciMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetPciMap)(nil)).Elem()
}

func (i GetPciMapArray) ToGetPciMapArrayOutput() GetPciMapArrayOutput {
	return i.ToGetPciMapArrayOutputWithContext(context.Background())
}

func (i GetPciMapArray) ToGetPciMapArrayOutputWithContext(ctx context.Context) GetPciMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetPciMapArrayOutput)
}

type GetPciMapOutput struct{ *pulumi.OutputState }

func (GetPciMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetPciMap)(nil)).Elem()
}

func (o GetPciMapOutput) ToGetPciMapOutput() GetPciMapOutput {
	return o
}

func (o GetPciMapOutput) ToGetPciMapOutputWithContext(ctx context.Context) GetPciMapOutput {
	return o
}

// The comment of the mapped PCI device.
func (o GetPciMapOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v GetPciMap) string { return v.Comment }).(pulumi.StringOutput)
}

// The ID attribute of the map.
func (o GetPciMapOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetPciMap) string { return v.Id }).(pulumi.StringOutput)
}

// The IOMMU group attribute of the map.
func (o GetPciMapOutput) IommuGroup() pulumi.IntOutput {
	return o.ApplyT(func(v GetPciMap) int { return v.IommuGroup }).(pulumi.IntOutput)
}

// The node name attribute of the map.
func (o GetPciMapOutput) Node() pulumi.StringOutput {
	return o.ApplyT(func(v GetPciMap) string { return v.Node }).(pulumi.StringOutput)
}

// The path attribute of the map.
func (o GetPciMapOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v GetPciMap) string { return v.Path }).(pulumi.StringOutput)
}

// The subsystem ID attribute of the map.Not mandatory for the Proxmox VE API call, but causes a PCI hardware mapping to be incomplete when not set.
func (o GetPciMapOutput) SubsystemId() pulumi.StringOutput {
	return o.ApplyT(func(v GetPciMap) string { return v.SubsystemId }).(pulumi.StringOutput)
}

type GetPciMapArrayOutput struct{ *pulumi.OutputState }

func (GetPciMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetPciMap)(nil)).Elem()
}

func (o GetPciMapArrayOutput) ToGetPciMapArrayOutput() GetPciMapArrayOutput {
	return o
}

func (o GetPciMapArrayOutput) ToGetPciMapArrayOutputWithContext(ctx context.Context) GetPciMapArrayOutput {
	return o
}

func (o GetPciMapArrayOutput) Index(i pulumi.IntInput) GetPciMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetPciMap {
		return vs[0].([]GetPciMap)[vs[1].(int)]
	}).(GetPciMapOutput)
}

type GetUsbMap struct {
	// The comment of the mapped USB device.
	Comment string `pulumi:"comment"`
	// The ID attribute of the map.
	Id string `pulumi:"id"`
	// The node name attribute of the map.
	Node string `pulumi:"node"`
	// The path attribute of the map.
	Path string `pulumi:"path"`
}

// GetUsbMapInput is an input type that accepts GetUsbMap and GetUsbMapOutput values.
// You can construct a concrete instance of `GetUsbMapInput` via:
//
//	GetUsbMap{ "key": GetUsbArgs{...} }
type GetUsbMapInput interface {
	pulumi.Input

	ToGetUsbMapOutput() GetUsbMapOutput
	ToGetUsbMapOutputWithContext(context.Context) GetUsbMapOutput
}

type GetUsbMapArgs struct {
	// The comment of the mapped USB device.
	Comment pulumi.StringInput `pulumi:"comment"`
	// The ID attribute of the map.
	Id pulumi.StringInput `pulumi:"id"`
	// The node name attribute of the map.
	Node pulumi.StringInput `pulumi:"node"`
	// The path attribute of the map.
	Path pulumi.StringInput `pulumi:"path"`
}

func (GetUsbMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUsbMap)(nil)).Elem()
}

func (i GetUsbMapArgs) ToGetUsbMapOutput() GetUsbMapOutput {
	return i.ToGetUsbMapOutputWithContext(context.Background())
}

func (i GetUsbMapArgs) ToGetUsbMapOutputWithContext(ctx context.Context) GetUsbMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUsbMapOutput)
}

// GetUsbMapArrayInput is an input type that accepts GetUsbMapArray and GetUsbMapArrayOutput values.
// You can construct a concrete instance of `GetUsbMapArrayInput` via:
//
//	GetUsbMapArray{ GetUsbMapArgs{...} }
type GetUsbMapArrayInput interface {
	pulumi.Input

	ToGetUsbMapArrayOutput() GetUsbMapArrayOutput
	ToGetUsbMapArrayOutputWithContext(context.Context) GetUsbMapArrayOutput
}

type GetUsbMapArray []GetUsbMapInput

func (GetUsbMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUsbMap)(nil)).Elem()
}

func (i GetUsbMapArray) ToGetUsbMapArrayOutput() GetUsbMapArrayOutput {
	return i.ToGetUsbMapArrayOutputWithContext(context.Background())
}

func (i GetUsbMapArray) ToGetUsbMapArrayOutputWithContext(ctx context.Context) GetUsbMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GetUsbMapArrayOutput)
}

type GetUsbMapOutput struct{ *pulumi.OutputState }

func (GetUsbMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GetUsbMap)(nil)).Elem()
}

func (o GetUsbMapOutput) ToGetUsbMapOutput() GetUsbMapOutput {
	return o
}

func (o GetUsbMapOutput) ToGetUsbMapOutputWithContext(ctx context.Context) GetUsbMapOutput {
	return o
}

// The comment of the mapped USB device.
func (o GetUsbMapOutput) Comment() pulumi.StringOutput {
	return o.ApplyT(func(v GetUsbMap) string { return v.Comment }).(pulumi.StringOutput)
}

// The ID attribute of the map.
func (o GetUsbMapOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v GetUsbMap) string { return v.Id }).(pulumi.StringOutput)
}

// The node name attribute of the map.
func (o GetUsbMapOutput) Node() pulumi.StringOutput {
	return o.ApplyT(func(v GetUsbMap) string { return v.Node }).(pulumi.StringOutput)
}

// The path attribute of the map.
func (o GetUsbMapOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v GetUsbMap) string { return v.Path }).(pulumi.StringOutput)
}

type GetUsbMapArrayOutput struct{ *pulumi.OutputState }

func (GetUsbMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GetUsbMap)(nil)).Elem()
}

func (o GetUsbMapArrayOutput) ToGetUsbMapArrayOutput() GetUsbMapArrayOutput {
	return o
}

func (o GetUsbMapArrayOutput) ToGetUsbMapArrayOutputWithContext(ctx context.Context) GetUsbMapArrayOutput {
	return o
}

func (o GetUsbMapArrayOutput) Index(i pulumi.IntInput) GetUsbMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GetUsbMap {
		return vs[0].([]GetUsbMap)[vs[1].(int)]
	}).(GetUsbMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PciMapTypeInput)(nil)).Elem(), PciMapTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PciMapTypeArrayInput)(nil)).Elem(), PciMapTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsbMapTypeInput)(nil)).Elem(), UsbMapTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsbMapTypeArrayInput)(nil)).Elem(), UsbMapTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetPciMapInput)(nil)).Elem(), GetPciMapArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetPciMapArrayInput)(nil)).Elem(), GetPciMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetUsbMapInput)(nil)).Elem(), GetUsbMapArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GetUsbMapArrayInput)(nil)).Elem(), GetUsbMapArray{})
	pulumi.RegisterOutputType(PciMapTypeOutput{})
	pulumi.RegisterOutputType(PciMapTypeArrayOutput{})
	pulumi.RegisterOutputType(UsbMapTypeOutput{})
	pulumi.RegisterOutputType(UsbMapTypeArrayOutput{})
	pulumi.RegisterOutputType(GetPciMapOutput{})
	pulumi.RegisterOutputType(GetPciMapArrayOutput{})
	pulumi.RegisterOutputType(GetUsbMapOutput{})
	pulumi.RegisterOutputType(GetUsbMapArrayOutput{})
}
