// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sdnzone

import (
	"context"
	"reflect"

	"errors"
	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/sdnzone"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := sdnzone.NewVxlan(ctx, "example", &sdnzone.VxlanArgs{
//				Dns:     pulumi.String("1.1.1.1"),
//				DnsZone: pulumi.String("example.com"),
//				ZoneId:  pulumi.String("vxlan1"),
//				Ipam:    pulumi.String("pve"),
//				Mtu:     pulumi.Int(1450),
//				Nodes: pulumi.StringArray{
//					pulumi.String("pve"),
//				},
//				Peers: pulumi.StringArray{
//					pulumi.String("10.0.0.1"),
//					pulumi.String("10.0.0.2"),
//					pulumi.String("10.0.0.3"),
//				},
//				ReverseDns: pulumi.String("1.1.1.1"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// #!/usr/bin/env sh
//
// VXLAN SDN zone can be imported using its unique identifier (zone ID)
//
// ```sh
// $ pulumi import proxmoxve:SDNZone/vxlan:Vxlan example vxlan1
// ```
type Vxlan struct {
	pulumi.CustomResourceState

	// DNS API server address.
	Dns pulumi.StringPtrOutput `pulumi:"dns"`
	// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
	DnsZone pulumi.StringPtrOutput `pulumi:"dnsZone"`
	// IP Address Management system.
	Ipam pulumi.StringPtrOutput `pulumi:"ipam"`
	// MTU value for the zone.
	Mtu pulumi.IntPtrOutput `pulumi:"mtu"`
	// The Proxmox nodes which the zone and associated VNets should be deployed on
	Nodes pulumi.StringArrayOutput `pulumi:"nodes"`
	// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
	Peers pulumi.StringArrayOutput `pulumi:"peers"`
	// Indicates if the zone has pending configuration changes that need to be applied.
	Pending pulumi.BoolOutput `pulumi:"pending"`
	// Reverse DNS API server address.
	ReverseDns pulumi.StringPtrOutput `pulumi:"reverseDns"`
	// Indicates the current state of the zone.
	State pulumi.StringOutput `pulumi:"state"`
	// The unique identifier of the SDN zone.
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewVxlan registers a new resource with the given unique name, arguments, and options.
func NewVxlan(ctx *pulumi.Context,
	name string, args *VxlanArgs, opts ...pulumi.ResourceOption) (*Vxlan, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Nodes == nil {
		return nil, errors.New("invalid value for required argument 'Nodes'")
	}
	if args.Peers == nil {
		return nil, errors.New("invalid value for required argument 'Peers'")
	}
	if args.ZoneId == nil {
		return nil, errors.New("invalid value for required argument 'ZoneId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Vxlan
	err := ctx.RegisterResource("proxmoxve:SDNZone/vxlan:Vxlan", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVxlan gets an existing Vxlan resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVxlan(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VxlanState, opts ...pulumi.ResourceOption) (*Vxlan, error) {
	var resource Vxlan
	err := ctx.ReadResource("proxmoxve:SDNZone/vxlan:Vxlan", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Vxlan resources.
type vxlanState struct {
	// DNS API server address.
	Dns *string `pulumi:"dns"`
	// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
	DnsZone *string `pulumi:"dnsZone"`
	// IP Address Management system.
	Ipam *string `pulumi:"ipam"`
	// MTU value for the zone.
	Mtu *int `pulumi:"mtu"`
	// The Proxmox nodes which the zone and associated VNets should be deployed on
	Nodes []string `pulumi:"nodes"`
	// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
	Peers []string `pulumi:"peers"`
	// Indicates if the zone has pending configuration changes that need to be applied.
	Pending *bool `pulumi:"pending"`
	// Reverse DNS API server address.
	ReverseDns *string `pulumi:"reverseDns"`
	// Indicates the current state of the zone.
	State *string `pulumi:"state"`
	// The unique identifier of the SDN zone.
	ZoneId *string `pulumi:"zoneId"`
}

type VxlanState struct {
	// DNS API server address.
	Dns pulumi.StringPtrInput
	// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
	DnsZone pulumi.StringPtrInput
	// IP Address Management system.
	Ipam pulumi.StringPtrInput
	// MTU value for the zone.
	Mtu pulumi.IntPtrInput
	// The Proxmox nodes which the zone and associated VNets should be deployed on
	Nodes pulumi.StringArrayInput
	// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
	Peers pulumi.StringArrayInput
	// Indicates if the zone has pending configuration changes that need to be applied.
	Pending pulumi.BoolPtrInput
	// Reverse DNS API server address.
	ReverseDns pulumi.StringPtrInput
	// Indicates the current state of the zone.
	State pulumi.StringPtrInput
	// The unique identifier of the SDN zone.
	ZoneId pulumi.StringPtrInput
}

func (VxlanState) ElementType() reflect.Type {
	return reflect.TypeOf((*vxlanState)(nil)).Elem()
}

type vxlanArgs struct {
	// DNS API server address.
	Dns *string `pulumi:"dns"`
	// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
	DnsZone *string `pulumi:"dnsZone"`
	// IP Address Management system.
	Ipam *string `pulumi:"ipam"`
	// MTU value for the zone.
	Mtu *int `pulumi:"mtu"`
	// The Proxmox nodes which the zone and associated VNets should be deployed on
	Nodes []string `pulumi:"nodes"`
	// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
	Peers []string `pulumi:"peers"`
	// Reverse DNS API server address.
	ReverseDns *string `pulumi:"reverseDns"`
	// The unique identifier of the SDN zone.
	ZoneId string `pulumi:"zoneId"`
}

// The set of arguments for constructing a Vxlan resource.
type VxlanArgs struct {
	// DNS API server address.
	Dns pulumi.StringPtrInput
	// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
	DnsZone pulumi.StringPtrInput
	// IP Address Management system.
	Ipam pulumi.StringPtrInput
	// MTU value for the zone.
	Mtu pulumi.IntPtrInput
	// The Proxmox nodes which the zone and associated VNets should be deployed on
	Nodes pulumi.StringArrayInput
	// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
	Peers pulumi.StringArrayInput
	// Reverse DNS API server address.
	ReverseDns pulumi.StringPtrInput
	// The unique identifier of the SDN zone.
	ZoneId pulumi.StringInput
}

func (VxlanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vxlanArgs)(nil)).Elem()
}

type VxlanInput interface {
	pulumi.Input

	ToVxlanOutput() VxlanOutput
	ToVxlanOutputWithContext(ctx context.Context) VxlanOutput
}

func (*Vxlan) ElementType() reflect.Type {
	return reflect.TypeOf((**Vxlan)(nil)).Elem()
}

func (i *Vxlan) ToVxlanOutput() VxlanOutput {
	return i.ToVxlanOutputWithContext(context.Background())
}

func (i *Vxlan) ToVxlanOutputWithContext(ctx context.Context) VxlanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VxlanOutput)
}

// VxlanArrayInput is an input type that accepts VxlanArray and VxlanArrayOutput values.
// You can construct a concrete instance of `VxlanArrayInput` via:
//
//	VxlanArray{ VxlanArgs{...} }
type VxlanArrayInput interface {
	pulumi.Input

	ToVxlanArrayOutput() VxlanArrayOutput
	ToVxlanArrayOutputWithContext(context.Context) VxlanArrayOutput
}

type VxlanArray []VxlanInput

func (VxlanArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vxlan)(nil)).Elem()
}

func (i VxlanArray) ToVxlanArrayOutput() VxlanArrayOutput {
	return i.ToVxlanArrayOutputWithContext(context.Background())
}

func (i VxlanArray) ToVxlanArrayOutputWithContext(ctx context.Context) VxlanArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VxlanArrayOutput)
}

// VxlanMapInput is an input type that accepts VxlanMap and VxlanMapOutput values.
// You can construct a concrete instance of `VxlanMapInput` via:
//
//	VxlanMap{ "key": VxlanArgs{...} }
type VxlanMapInput interface {
	pulumi.Input

	ToVxlanMapOutput() VxlanMapOutput
	ToVxlanMapOutputWithContext(context.Context) VxlanMapOutput
}

type VxlanMap map[string]VxlanInput

func (VxlanMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vxlan)(nil)).Elem()
}

func (i VxlanMap) ToVxlanMapOutput() VxlanMapOutput {
	return i.ToVxlanMapOutputWithContext(context.Background())
}

func (i VxlanMap) ToVxlanMapOutputWithContext(ctx context.Context) VxlanMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VxlanMapOutput)
}

type VxlanOutput struct{ *pulumi.OutputState }

func (VxlanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Vxlan)(nil)).Elem()
}

func (o VxlanOutput) ToVxlanOutput() VxlanOutput {
	return o
}

func (o VxlanOutput) ToVxlanOutputWithContext(ctx context.Context) VxlanOutput {
	return o
}

// DNS API server address.
func (o VxlanOutput) Dns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringPtrOutput { return v.Dns }).(pulumi.StringPtrOutput)
}

// DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
func (o VxlanOutput) DnsZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringPtrOutput { return v.DnsZone }).(pulumi.StringPtrOutput)
}

// IP Address Management system.
func (o VxlanOutput) Ipam() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringPtrOutput { return v.Ipam }).(pulumi.StringPtrOutput)
}

// MTU value for the zone.
func (o VxlanOutput) Mtu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.IntPtrOutput { return v.Mtu }).(pulumi.IntPtrOutput)
}

// The Proxmox nodes which the zone and associated VNets should be deployed on
func (o VxlanOutput) Nodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringArrayOutput { return v.Nodes }).(pulumi.StringArrayOutput)
}

// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
func (o VxlanOutput) Peers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringArrayOutput { return v.Peers }).(pulumi.StringArrayOutput)
}

// Indicates if the zone has pending configuration changes that need to be applied.
func (o VxlanOutput) Pending() pulumi.BoolOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.BoolOutput { return v.Pending }).(pulumi.BoolOutput)
}

// Reverse DNS API server address.
func (o VxlanOutput) ReverseDns() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringPtrOutput { return v.ReverseDns }).(pulumi.StringPtrOutput)
}

// Indicates the current state of the zone.
func (o VxlanOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The unique identifier of the SDN zone.
func (o VxlanOutput) ZoneId() pulumi.StringOutput {
	return o.ApplyT(func(v *Vxlan) pulumi.StringOutput { return v.ZoneId }).(pulumi.StringOutput)
}

type VxlanArrayOutput struct{ *pulumi.OutputState }

func (VxlanArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Vxlan)(nil)).Elem()
}

func (o VxlanArrayOutput) ToVxlanArrayOutput() VxlanArrayOutput {
	return o
}

func (o VxlanArrayOutput) ToVxlanArrayOutputWithContext(ctx context.Context) VxlanArrayOutput {
	return o
}

func (o VxlanArrayOutput) Index(i pulumi.IntInput) VxlanOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Vxlan {
		return vs[0].([]*Vxlan)[vs[1].(int)]
	}).(VxlanOutput)
}

type VxlanMapOutput struct{ *pulumi.OutputState }

func (VxlanMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Vxlan)(nil)).Elem()
}

func (o VxlanMapOutput) ToVxlanMapOutput() VxlanMapOutput {
	return o
}

func (o VxlanMapOutput) ToVxlanMapOutputWithContext(ctx context.Context) VxlanMapOutput {
	return o
}

func (o VxlanMapOutput) MapIndex(k pulumi.StringInput) VxlanOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Vxlan {
		return vs[0].(map[string]*Vxlan)[vs[1].(string)]
	}).(VxlanOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VxlanInput)(nil)).Elem(), &Vxlan{})
	pulumi.RegisterInputType(reflect.TypeOf((*VxlanArrayInput)(nil)).Elem(), VxlanArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VxlanMapInput)(nil)).Elem(), VxlanMap{})
	pulumi.RegisterOutputType(VxlanOutput{})
	pulumi.RegisterOutputType(VxlanArrayOutput{})
	pulumi.RegisterOutputType(VxlanMapOutput{})
}
