// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package storage

import (
	"context"
	"reflect"

	"errors"
	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages an SMB/CIFS based storage server in Proxmox VE.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := storage.NewCIFS(ctx, "example", &storage.CIFSArgs{
//				CifsId: pulumi.String("example-cifs"),
//				Nodes: pulumi.StringArray{
//					pulumi.String("pve"),
//				},
//				Server:   pulumi.String("10.0.0.20"),
//				Share:    pulumi.String("proxmox"),
//				Username: pulumi.String("cifs-user"),
//				Password: pulumi.String("cifs-password"),
//				Contents: pulumi.StringArray{
//					pulumi.String("images"),
//				},
//				Domain:                pulumi.String("WORKGROUP"),
//				Subdirectory:          pulumi.String("terraform"),
//				Preallocation:         pulumi.String("metadata"),
//				SnapshotAsVolumeChain: pulumi.Bool(true),
//				Backups: &storage.CIFSBackupsArgs{
//					MaxProtectedBackups: pulumi.Int(5),
//					KeepDaily:           pulumi.Int(7),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type CIFS struct {
	pulumi.CustomResourceState

	// Configure backup retention settings for the storage type.
	Backups CIFSBackupsPtrOutput `pulumi:"backups"`
	// The unique identifier of the storage.
	CifsId pulumi.StringOutput `pulumi:"cifsId"`
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayOutput `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable pulumi.BoolOutput `pulumi:"disable"`
	// The SMB/CIFS domain.
	Domain pulumi.StringPtrOutput `pulumi:"domain"`
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayOutput `pulumi:"nodes"`
	// The password for authenticating with the SMB/CIFS server.
	Password pulumi.StringOutput `pulumi:"password"`
	// The preallocation mode for raw and qcow2 images.
	Preallocation pulumi.StringPtrOutput `pulumi:"preallocation"`
	// The IP address or DNS name of the SMB/CIFS server.
	Server pulumi.StringOutput `pulumi:"server"`
	// The name of the SMB/CIFS share.
	Share pulumi.StringOutput `pulumi:"share"`
	// Whether the storage is shared across all nodes.
	Shared pulumi.BoolOutput `pulumi:"shared"`
	// Enable support for creating snapshots through volume backing-chains.
	SnapshotAsVolumeChain pulumi.BoolPtrOutput `pulumi:"snapshotAsVolumeChain"`
	// A subdirectory to mount within the share.
	Subdirectory pulumi.StringPtrOutput `pulumi:"subdirectory"`
	// The username for authenticating with the SMB/CIFS server.
	Username pulumi.StringOutput `pulumi:"username"`
}

// NewCIFS registers a new resource with the given unique name, arguments, and options.
func NewCIFS(ctx *pulumi.Context,
	name string, args *CIFSArgs, opts ...pulumi.ResourceOption) (*CIFS, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CifsId == nil {
		return nil, errors.New("invalid value for required argument 'CifsId'")
	}
	if args.Password == nil {
		return nil, errors.New("invalid value for required argument 'Password'")
	}
	if args.Server == nil {
		return nil, errors.New("invalid value for required argument 'Server'")
	}
	if args.Share == nil {
		return nil, errors.New("invalid value for required argument 'Share'")
	}
	if args.Username == nil {
		return nil, errors.New("invalid value for required argument 'Username'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CIFS
	err := ctx.RegisterResource("proxmoxve:Storage/cIFS:CIFS", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCIFS gets an existing CIFS resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCIFS(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CIFSState, opts ...pulumi.ResourceOption) (*CIFS, error) {
	var resource CIFS
	err := ctx.ReadResource("proxmoxve:Storage/cIFS:CIFS", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CIFS resources.
type cifsState struct {
	// Configure backup retention settings for the storage type.
	Backups *CIFSBackups `pulumi:"backups"`
	// The unique identifier of the storage.
	CifsId *string `pulumi:"cifsId"`
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents []string `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable *bool `pulumi:"disable"`
	// The SMB/CIFS domain.
	Domain *string `pulumi:"domain"`
	// A list of nodes where this storage is available.
	Nodes []string `pulumi:"nodes"`
	// The password for authenticating with the SMB/CIFS server.
	Password *string `pulumi:"password"`
	// The preallocation mode for raw and qcow2 images.
	Preallocation *string `pulumi:"preallocation"`
	// The IP address or DNS name of the SMB/CIFS server.
	Server *string `pulumi:"server"`
	// The name of the SMB/CIFS share.
	Share *string `pulumi:"share"`
	// Whether the storage is shared across all nodes.
	Shared *bool `pulumi:"shared"`
	// Enable support for creating snapshots through volume backing-chains.
	SnapshotAsVolumeChain *bool `pulumi:"snapshotAsVolumeChain"`
	// A subdirectory to mount within the share.
	Subdirectory *string `pulumi:"subdirectory"`
	// The username for authenticating with the SMB/CIFS server.
	Username *string `pulumi:"username"`
}

type CIFSState struct {
	// Configure backup retention settings for the storage type.
	Backups CIFSBackupsPtrInput
	// The unique identifier of the storage.
	CifsId pulumi.StringPtrInput
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayInput
	// Whether the storage is disabled.
	Disable pulumi.BoolPtrInput
	// The SMB/CIFS domain.
	Domain pulumi.StringPtrInput
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayInput
	// The password for authenticating with the SMB/CIFS server.
	Password pulumi.StringPtrInput
	// The preallocation mode for raw and qcow2 images.
	Preallocation pulumi.StringPtrInput
	// The IP address or DNS name of the SMB/CIFS server.
	Server pulumi.StringPtrInput
	// The name of the SMB/CIFS share.
	Share pulumi.StringPtrInput
	// Whether the storage is shared across all nodes.
	Shared pulumi.BoolPtrInput
	// Enable support for creating snapshots through volume backing-chains.
	SnapshotAsVolumeChain pulumi.BoolPtrInput
	// A subdirectory to mount within the share.
	Subdirectory pulumi.StringPtrInput
	// The username for authenticating with the SMB/CIFS server.
	Username pulumi.StringPtrInput
}

func (CIFSState) ElementType() reflect.Type {
	return reflect.TypeOf((*cifsState)(nil)).Elem()
}

type cifsArgs struct {
	// Configure backup retention settings for the storage type.
	Backups *CIFSBackups `pulumi:"backups"`
	// The unique identifier of the storage.
	CifsId string `pulumi:"cifsId"`
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents []string `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable *bool `pulumi:"disable"`
	// The SMB/CIFS domain.
	Domain *string `pulumi:"domain"`
	// A list of nodes where this storage is available.
	Nodes []string `pulumi:"nodes"`
	// The password for authenticating with the SMB/CIFS server.
	Password string `pulumi:"password"`
	// The preallocation mode for raw and qcow2 images.
	Preallocation *string `pulumi:"preallocation"`
	// The IP address or DNS name of the SMB/CIFS server.
	Server string `pulumi:"server"`
	// The name of the SMB/CIFS share.
	Share string `pulumi:"share"`
	// Enable support for creating snapshots through volume backing-chains.
	SnapshotAsVolumeChain *bool `pulumi:"snapshotAsVolumeChain"`
	// A subdirectory to mount within the share.
	Subdirectory *string `pulumi:"subdirectory"`
	// The username for authenticating with the SMB/CIFS server.
	Username string `pulumi:"username"`
}

// The set of arguments for constructing a CIFS resource.
type CIFSArgs struct {
	// Configure backup retention settings for the storage type.
	Backups CIFSBackupsPtrInput
	// The unique identifier of the storage.
	CifsId pulumi.StringInput
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayInput
	// Whether the storage is disabled.
	Disable pulumi.BoolPtrInput
	// The SMB/CIFS domain.
	Domain pulumi.StringPtrInput
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayInput
	// The password for authenticating with the SMB/CIFS server.
	Password pulumi.StringInput
	// The preallocation mode for raw and qcow2 images.
	Preallocation pulumi.StringPtrInput
	// The IP address or DNS name of the SMB/CIFS server.
	Server pulumi.StringInput
	// The name of the SMB/CIFS share.
	Share pulumi.StringInput
	// Enable support for creating snapshots through volume backing-chains.
	SnapshotAsVolumeChain pulumi.BoolPtrInput
	// A subdirectory to mount within the share.
	Subdirectory pulumi.StringPtrInput
	// The username for authenticating with the SMB/CIFS server.
	Username pulumi.StringInput
}

func (CIFSArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cifsArgs)(nil)).Elem()
}

type CIFSInput interface {
	pulumi.Input

	ToCIFSOutput() CIFSOutput
	ToCIFSOutputWithContext(ctx context.Context) CIFSOutput
}

func (*CIFS) ElementType() reflect.Type {
	return reflect.TypeOf((**CIFS)(nil)).Elem()
}

func (i *CIFS) ToCIFSOutput() CIFSOutput {
	return i.ToCIFSOutputWithContext(context.Background())
}

func (i *CIFS) ToCIFSOutputWithContext(ctx context.Context) CIFSOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CIFSOutput)
}

// CIFSArrayInput is an input type that accepts CIFSArray and CIFSArrayOutput values.
// You can construct a concrete instance of `CIFSArrayInput` via:
//
//	CIFSArray{ CIFSArgs{...} }
type CIFSArrayInput interface {
	pulumi.Input

	ToCIFSArrayOutput() CIFSArrayOutput
	ToCIFSArrayOutputWithContext(context.Context) CIFSArrayOutput
}

type CIFSArray []CIFSInput

func (CIFSArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CIFS)(nil)).Elem()
}

func (i CIFSArray) ToCIFSArrayOutput() CIFSArrayOutput {
	return i.ToCIFSArrayOutputWithContext(context.Background())
}

func (i CIFSArray) ToCIFSArrayOutputWithContext(ctx context.Context) CIFSArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CIFSArrayOutput)
}

// CIFSMapInput is an input type that accepts CIFSMap and CIFSMapOutput values.
// You can construct a concrete instance of `CIFSMapInput` via:
//
//	CIFSMap{ "key": CIFSArgs{...} }
type CIFSMapInput interface {
	pulumi.Input

	ToCIFSMapOutput() CIFSMapOutput
	ToCIFSMapOutputWithContext(context.Context) CIFSMapOutput
}

type CIFSMap map[string]CIFSInput

func (CIFSMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CIFS)(nil)).Elem()
}

func (i CIFSMap) ToCIFSMapOutput() CIFSMapOutput {
	return i.ToCIFSMapOutputWithContext(context.Background())
}

func (i CIFSMap) ToCIFSMapOutputWithContext(ctx context.Context) CIFSMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CIFSMapOutput)
}

type CIFSOutput struct{ *pulumi.OutputState }

func (CIFSOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CIFS)(nil)).Elem()
}

func (o CIFSOutput) ToCIFSOutput() CIFSOutput {
	return o
}

func (o CIFSOutput) ToCIFSOutputWithContext(ctx context.Context) CIFSOutput {
	return o
}

// Configure backup retention settings for the storage type.
func (o CIFSOutput) Backups() CIFSBackupsPtrOutput {
	return o.ApplyT(func(v *CIFS) CIFSBackupsPtrOutput { return v.Backups }).(CIFSBackupsPtrOutput)
}

// The unique identifier of the storage.
func (o CIFSOutput) CifsId() pulumi.StringOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringOutput { return v.CifsId }).(pulumi.StringOutput)
}

// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
func (o CIFSOutput) Contents() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringArrayOutput { return v.Contents }).(pulumi.StringArrayOutput)
}

// Whether the storage is disabled.
func (o CIFSOutput) Disable() pulumi.BoolOutput {
	return o.ApplyT(func(v *CIFS) pulumi.BoolOutput { return v.Disable }).(pulumi.BoolOutput)
}

// The SMB/CIFS domain.
func (o CIFSOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringPtrOutput { return v.Domain }).(pulumi.StringPtrOutput)
}

// A list of nodes where this storage is available.
func (o CIFSOutput) Nodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringArrayOutput { return v.Nodes }).(pulumi.StringArrayOutput)
}

// The password for authenticating with the SMB/CIFS server.
func (o CIFSOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringOutput { return v.Password }).(pulumi.StringOutput)
}

// The preallocation mode for raw and qcow2 images.
func (o CIFSOutput) Preallocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringPtrOutput { return v.Preallocation }).(pulumi.StringPtrOutput)
}

// The IP address or DNS name of the SMB/CIFS server.
func (o CIFSOutput) Server() pulumi.StringOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringOutput { return v.Server }).(pulumi.StringOutput)
}

// The name of the SMB/CIFS share.
func (o CIFSOutput) Share() pulumi.StringOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringOutput { return v.Share }).(pulumi.StringOutput)
}

// Whether the storage is shared across all nodes.
func (o CIFSOutput) Shared() pulumi.BoolOutput {
	return o.ApplyT(func(v *CIFS) pulumi.BoolOutput { return v.Shared }).(pulumi.BoolOutput)
}

// Enable support for creating snapshots through volume backing-chains.
func (o CIFSOutput) SnapshotAsVolumeChain() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CIFS) pulumi.BoolPtrOutput { return v.SnapshotAsVolumeChain }).(pulumi.BoolPtrOutput)
}

// A subdirectory to mount within the share.
func (o CIFSOutput) Subdirectory() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringPtrOutput { return v.Subdirectory }).(pulumi.StringPtrOutput)
}

// The username for authenticating with the SMB/CIFS server.
func (o CIFSOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v *CIFS) pulumi.StringOutput { return v.Username }).(pulumi.StringOutput)
}

type CIFSArrayOutput struct{ *pulumi.OutputState }

func (CIFSArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CIFS)(nil)).Elem()
}

func (o CIFSArrayOutput) ToCIFSArrayOutput() CIFSArrayOutput {
	return o
}

func (o CIFSArrayOutput) ToCIFSArrayOutputWithContext(ctx context.Context) CIFSArrayOutput {
	return o
}

func (o CIFSArrayOutput) Index(i pulumi.IntInput) CIFSOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CIFS {
		return vs[0].([]*CIFS)[vs[1].(int)]
	}).(CIFSOutput)
}

type CIFSMapOutput struct{ *pulumi.OutputState }

func (CIFSMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CIFS)(nil)).Elem()
}

func (o CIFSMapOutput) ToCIFSMapOutput() CIFSMapOutput {
	return o
}

func (o CIFSMapOutput) ToCIFSMapOutputWithContext(ctx context.Context) CIFSMapOutput {
	return o
}

func (o CIFSMapOutput) MapIndex(k pulumi.StringInput) CIFSOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CIFS {
		return vs[0].(map[string]*CIFS)[vs[1].(string)]
	}).(CIFSOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CIFSInput)(nil)).Elem(), &CIFS{})
	pulumi.RegisterInputType(reflect.TypeOf((*CIFSArrayInput)(nil)).Elem(), CIFSArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CIFSMapInput)(nil)).Elem(), CIFSMap{})
	pulumi.RegisterOutputType(CIFSOutput{})
	pulumi.RegisterOutputType(CIFSArrayOutput{})
	pulumi.RegisterOutputType(CIFSMapOutput{})
}
