// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package storage

import (
	"context"
	"reflect"

	"errors"
	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages LVM-based storage in Proxmox VE.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/muhlba91/pulumi-proxmoxve/sdk/v7/go/proxmoxve/storage"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := storage.NewLVM(ctx, "example", &storage.LVMArgs{
//				LvmId: pulumi.String("example-lvm"),
//				Nodes: pulumi.StringArray{
//					pulumi.String("pve"),
//				},
//				VolumeGroup: pulumi.String("vg0"),
//				Contents: pulumi.StringArray{
//					pulumi.String("images"),
//				},
//				WipeRemovedVolumes: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type LVM struct {
	pulumi.CustomResourceState

	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayOutput `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable pulumi.BoolOutput `pulumi:"disable"`
	// The unique identifier of the storage.
	LvmId pulumi.StringOutput `pulumi:"lvmId"`
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayOutput `pulumi:"nodes"`
	// Whether the storage is shared across all nodes.
	Shared pulumi.BoolOutput `pulumi:"shared"`
	// The name of the volume group to use.
	VolumeGroup pulumi.StringOutput `pulumi:"volumeGroup"`
	// Whether to zero-out data when removing LVMs.
	WipeRemovedVolumes pulumi.BoolOutput `pulumi:"wipeRemovedVolumes"`
}

// NewLVM registers a new resource with the given unique name, arguments, and options.
func NewLVM(ctx *pulumi.Context,
	name string, args *LVMArgs, opts ...pulumi.ResourceOption) (*LVM, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LvmId == nil {
		return nil, errors.New("invalid value for required argument 'LvmId'")
	}
	if args.VolumeGroup == nil {
		return nil, errors.New("invalid value for required argument 'VolumeGroup'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LVM
	err := ctx.RegisterResource("proxmoxve:Storage/lVM:LVM", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLVM gets an existing LVM resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLVM(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LVMState, opts ...pulumi.ResourceOption) (*LVM, error) {
	var resource LVM
	err := ctx.ReadResource("proxmoxve:Storage/lVM:LVM", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LVM resources.
type lvmState struct {
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents []string `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable *bool `pulumi:"disable"`
	// The unique identifier of the storage.
	LvmId *string `pulumi:"lvmId"`
	// A list of nodes where this storage is available.
	Nodes []string `pulumi:"nodes"`
	// Whether the storage is shared across all nodes.
	Shared *bool `pulumi:"shared"`
	// The name of the volume group to use.
	VolumeGroup *string `pulumi:"volumeGroup"`
	// Whether to zero-out data when removing LVMs.
	WipeRemovedVolumes *bool `pulumi:"wipeRemovedVolumes"`
}

type LVMState struct {
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayInput
	// Whether the storage is disabled.
	Disable pulumi.BoolPtrInput
	// The unique identifier of the storage.
	LvmId pulumi.StringPtrInput
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayInput
	// Whether the storage is shared across all nodes.
	Shared pulumi.BoolPtrInput
	// The name of the volume group to use.
	VolumeGroup pulumi.StringPtrInput
	// Whether to zero-out data when removing LVMs.
	WipeRemovedVolumes pulumi.BoolPtrInput
}

func (LVMState) ElementType() reflect.Type {
	return reflect.TypeOf((*lvmState)(nil)).Elem()
}

type lvmArgs struct {
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents []string `pulumi:"contents"`
	// Whether the storage is disabled.
	Disable *bool `pulumi:"disable"`
	// The unique identifier of the storage.
	LvmId string `pulumi:"lvmId"`
	// A list of nodes where this storage is available.
	Nodes []string `pulumi:"nodes"`
	// Whether the storage is shared across all nodes.
	Shared *bool `pulumi:"shared"`
	// The name of the volume group to use.
	VolumeGroup string `pulumi:"volumeGroup"`
	// Whether to zero-out data when removing LVMs.
	WipeRemovedVolumes *bool `pulumi:"wipeRemovedVolumes"`
}

// The set of arguments for constructing a LVM resource.
type LVMArgs struct {
	// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
	Contents pulumi.StringArrayInput
	// Whether the storage is disabled.
	Disable pulumi.BoolPtrInput
	// The unique identifier of the storage.
	LvmId pulumi.StringInput
	// A list of nodes where this storage is available.
	Nodes pulumi.StringArrayInput
	// Whether the storage is shared across all nodes.
	Shared pulumi.BoolPtrInput
	// The name of the volume group to use.
	VolumeGroup pulumi.StringInput
	// Whether to zero-out data when removing LVMs.
	WipeRemovedVolumes pulumi.BoolPtrInput
}

func (LVMArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*lvmArgs)(nil)).Elem()
}

type LVMInput interface {
	pulumi.Input

	ToLVMOutput() LVMOutput
	ToLVMOutputWithContext(ctx context.Context) LVMOutput
}

func (*LVM) ElementType() reflect.Type {
	return reflect.TypeOf((**LVM)(nil)).Elem()
}

func (i *LVM) ToLVMOutput() LVMOutput {
	return i.ToLVMOutputWithContext(context.Background())
}

func (i *LVM) ToLVMOutputWithContext(ctx context.Context) LVMOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LVMOutput)
}

// LVMArrayInput is an input type that accepts LVMArray and LVMArrayOutput values.
// You can construct a concrete instance of `LVMArrayInput` via:
//
//	LVMArray{ LVMArgs{...} }
type LVMArrayInput interface {
	pulumi.Input

	ToLVMArrayOutput() LVMArrayOutput
	ToLVMArrayOutputWithContext(context.Context) LVMArrayOutput
}

type LVMArray []LVMInput

func (LVMArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LVM)(nil)).Elem()
}

func (i LVMArray) ToLVMArrayOutput() LVMArrayOutput {
	return i.ToLVMArrayOutputWithContext(context.Background())
}

func (i LVMArray) ToLVMArrayOutputWithContext(ctx context.Context) LVMArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LVMArrayOutput)
}

// LVMMapInput is an input type that accepts LVMMap and LVMMapOutput values.
// You can construct a concrete instance of `LVMMapInput` via:
//
//	LVMMap{ "key": LVMArgs{...} }
type LVMMapInput interface {
	pulumi.Input

	ToLVMMapOutput() LVMMapOutput
	ToLVMMapOutputWithContext(context.Context) LVMMapOutput
}

type LVMMap map[string]LVMInput

func (LVMMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LVM)(nil)).Elem()
}

func (i LVMMap) ToLVMMapOutput() LVMMapOutput {
	return i.ToLVMMapOutputWithContext(context.Background())
}

func (i LVMMap) ToLVMMapOutputWithContext(ctx context.Context) LVMMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LVMMapOutput)
}

type LVMOutput struct{ *pulumi.OutputState }

func (LVMOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LVM)(nil)).Elem()
}

func (o LVMOutput) ToLVMOutput() LVMOutput {
	return o
}

func (o LVMOutput) ToLVMOutputWithContext(ctx context.Context) LVMOutput {
	return o
}

// The content types that can be stored on this storage. Valid values: `backup` (VM backups), `images` (VM disk images), `import` (VM disk images for import), `iso` (ISO images), `rootdir` (container root directories), `snippets` (cloud-init, hook scripts, etc.), `vztmpl` (container templates).
func (o LVMOutput) Contents() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LVM) pulumi.StringArrayOutput { return v.Contents }).(pulumi.StringArrayOutput)
}

// Whether the storage is disabled.
func (o LVMOutput) Disable() pulumi.BoolOutput {
	return o.ApplyT(func(v *LVM) pulumi.BoolOutput { return v.Disable }).(pulumi.BoolOutput)
}

// The unique identifier of the storage.
func (o LVMOutput) LvmId() pulumi.StringOutput {
	return o.ApplyT(func(v *LVM) pulumi.StringOutput { return v.LvmId }).(pulumi.StringOutput)
}

// A list of nodes where this storage is available.
func (o LVMOutput) Nodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LVM) pulumi.StringArrayOutput { return v.Nodes }).(pulumi.StringArrayOutput)
}

// Whether the storage is shared across all nodes.
func (o LVMOutput) Shared() pulumi.BoolOutput {
	return o.ApplyT(func(v *LVM) pulumi.BoolOutput { return v.Shared }).(pulumi.BoolOutput)
}

// The name of the volume group to use.
func (o LVMOutput) VolumeGroup() pulumi.StringOutput {
	return o.ApplyT(func(v *LVM) pulumi.StringOutput { return v.VolumeGroup }).(pulumi.StringOutput)
}

// Whether to zero-out data when removing LVMs.
func (o LVMOutput) WipeRemovedVolumes() pulumi.BoolOutput {
	return o.ApplyT(func(v *LVM) pulumi.BoolOutput { return v.WipeRemovedVolumes }).(pulumi.BoolOutput)
}

type LVMArrayOutput struct{ *pulumi.OutputState }

func (LVMArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LVM)(nil)).Elem()
}

func (o LVMArrayOutput) ToLVMArrayOutput() LVMArrayOutput {
	return o
}

func (o LVMArrayOutput) ToLVMArrayOutputWithContext(ctx context.Context) LVMArrayOutput {
	return o
}

func (o LVMArrayOutput) Index(i pulumi.IntInput) LVMOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LVM {
		return vs[0].([]*LVM)[vs[1].(int)]
	}).(LVMOutput)
}

type LVMMapOutput struct{ *pulumi.OutputState }

func (LVMMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LVM)(nil)).Elem()
}

func (o LVMMapOutput) ToLVMMapOutput() LVMMapOutput {
	return o
}

func (o LVMMapOutput) ToLVMMapOutputWithContext(ctx context.Context) LVMMapOutput {
	return o
}

func (o LVMMapOutput) MapIndex(k pulumi.StringInput) LVMOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LVM {
		return vs[0].(map[string]*LVM)[vs[1].(string)]
	}).(LVMOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LVMInput)(nil)).Elem(), &LVM{})
	pulumi.RegisterInputType(reflect.TypeOf((*LVMArrayInput)(nil)).Elem(), LVMArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LVMMapInput)(nil)).Elem(), LVMMap{})
	pulumi.RegisterOutputType(LVMOutput{})
	pulumi.RegisterOutputType(LVMArrayOutput{})
	pulumi.RegisterOutputType(LVMMapOutput{})
}
