// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as proxmoxve from "@muhlba91/pulumi-proxmoxve";
 *
 * // Example 1: Basic clone with minimal management
 * const basicClone = new proxmoxve.vm.ClonedVirtualMachine("basic_clone", {
 *     nodeName: "pve",
 *     name: "basic-clone",
 *     clone: {
 *         sourceVmId: 100,
 *         full: true,
 *     },
 *     cpu: {
 *         cores: 4,
 *     },
 * });
 * // Example 2: Clone with explicit network management
 * const networkManaged = new proxmoxve.vm.ClonedVirtualMachine("network_managed", {
 *     nodeName: "pve",
 *     name: "network-clone",
 *     clone: {
 *         sourceVmId: 100,
 *     },
 *     network: {
 *         net0: {
 *             bridge: "vmbr0",
 *             model: "virtio",
 *             tag: 100,
 *         },
 *         net1: {
 *             bridge: "vmbr1",
 *             model: "virtio",
 *             firewall: true,
 *             macAddress: "BC:24:11:2E:C5:00",
 *         },
 *     },
 *     cpu: {
 *         cores: 2,
 *     },
 * });
 * // Example 3: Clone with disk management
 * const diskManaged = new proxmoxve.vm.ClonedVirtualMachine("disk_managed", {
 *     nodeName: "pve",
 *     name: "disk-clone",
 *     clone: {
 *         sourceVmId: 100,
 *         targetDatastore: "local-lvm",
 *     },
 *     disk: {
 *         scsi0: {
 *             datastoreId: "local-lvm",
 *             sizeGb: 50,
 *             discard: "on",
 *             ssd: true,
 *         },
 *         scsi1: {
 *             datastoreId: "local-lvm",
 *             sizeGb: 100,
 *             backup: false,
 *         },
 *     },
 * });
 * // Example 4: Clone with explicit device deletion
 * const selectiveDelete = new proxmoxve.vm.ClonedVirtualMachine("selective_delete", {
 *     nodeName: "pve",
 *     name: "minimal-clone",
 *     clone: {
 *         sourceVmId: 100,
 *     },
 *     network: {
 *         net0: {
 *             bridge: "vmbr0",
 *             model: "virtio",
 *         },
 *     },
 *     "delete": {
 *         networks: [
 *             "net1",
 *             "net2",
 *         ],
 *     },
 * });
 * // Example 5: Full-featured clone with multiple settings
 * const fullFeatured = new proxmoxve.vm.ClonedVirtualMachine("full_featured", {
 *     nodeName: "pve",
 *     name: "production-vm",
 *     description: "Production VM cloned from template",
 *     tags: [
 *         "production",
 *         "web",
 *     ],
 *     clone: {
 *         sourceVmId: 100,
 *         sourceNodeName: "pve",
 *         full: true,
 *         targetDatastore: "local-lvm",
 *         retries: 3,
 *     },
 *     cpu: {
 *         cores: 8,
 *         sockets: 1,
 *         architecture: "x86_64",
 *         type: "host",
 *     },
 *     memory: {
 *         size: 8192,
 *         balloon: 2048,
 *         shares: 2000,
 *     },
 *     network: {
 *         net0: {
 *             bridge: "vmbr0",
 *             model: "virtio",
 *             tag: 100,
 *             firewall: true,
 *             rateLimit: 100,
 *         },
 *     },
 *     disk: {
 *         scsi0: {
 *             datastoreId: "local-lvm",
 *             sizeGb: 100,
 *             discard: "on",
 *             iothread: true,
 *             ssd: true,
 *             cache: "writethrough",
 *         },
 *     },
 *     vga: {
 *         type: "std",
 *         memory: 16,
 *     },
 *     "delete": {
 *         disks: ["ide2"],
 *     },
 *     stopOnDestroy: false,
 *     purgeOnDestroy: true,
 *     deleteUnreferencedDisksOnDestroy: false,
 *     timeouts: {
 *         create: "30m",
 *         update: "30m",
 *         "delete": "10m",
 *     },
 * });
 * // Example 6: Linked clone for testing
 * const testClone = new proxmoxve.vm.ClonedVirtualMachine("test_clone", {
 *     nodeName: "pve",
 *     name: "test-vm",
 *     clone: {
 *         sourceVmId: 100,
 *         full: false,
 *     },
 *     cpu: {
 *         cores: 2,
 *     },
 *     network: {
 *         net0: {
 *             bridge: "vmbr0",
 *             model: "virtio",
 *         },
 *     },
 * });
 * // Example 7: Clone with pool assignment
 * const pooledClone = new proxmoxve.vm.ClonedVirtualMachine("pooled_clone", {
 *     nodeName: "pve",
 *     name: "pooled-vm",
 *     clone: {
 *         sourceVmId: 100,
 *         poolId: "production",
 *     },
 *     cpu: {
 *         cores: 4,
 *     },
 * });
 * // Example 8: Import existing cloned VM
 * const imported = new proxmoxve.vm.ClonedVirtualMachine("imported", {
 *     vmId: "123",
 *     nodeName: "pve",
 *     clone: {
 *         sourceVmId: 100,
 *     },
 *     cpu: {
 *         cores: 4,
 *     },
 * });
 * ```
 */
export class ClonedVirtualMachine extends pulumi.CustomResource {
    /**
     * Get an existing ClonedVirtualMachine resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClonedVirtualMachineState, opts?: pulumi.CustomResourceOptions): ClonedVirtualMachine {
        return new ClonedVirtualMachine(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine';

    /**
     * Returns true if the given object is an instance of ClonedVirtualMachine.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ClonedVirtualMachine {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ClonedVirtualMachine.__pulumiType;
    }

    /**
     * The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
     */
    declare public readonly cdrom: pulumi.Output<{[key: string]: outputs.VM.ClonedVirtualMachineCdrom} | undefined>;
    /**
     * Clone settings. Changes require recreation.
     */
    declare public readonly clone: pulumi.Output<outputs.VM.ClonedVirtualMachineClone>;
    /**
     * The CPU configuration.
     */
    declare public readonly cpu: pulumi.Output<outputs.VM.ClonedVirtualMachineCpu | undefined>;
    /**
     * Explicit deletions to perform after cloning/updating. Entries persist across applies.
     */
    declare public readonly delete: pulumi.Output<outputs.VM.ClonedVirtualMachineDelete | undefined>;
    declare public readonly deleteUnreferencedDisksOnDestroy: pulumi.Output<boolean>;
    /**
     * Optional VM description applied after cloning.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
     */
    declare public readonly disk: pulumi.Output<{[key: string]: outputs.VM.ClonedVirtualMachineDisk} | undefined>;
    /**
     * Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
     */
    declare public readonly memory: pulumi.Output<outputs.VM.ClonedVirtualMachineMemory | undefined>;
    /**
     * Optional VM name override applied after cloning.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
     */
    declare public readonly network: pulumi.Output<{[key: string]: outputs.VM.ClonedVirtualMachineNetwork} | undefined>;
    /**
     * Target node for the cloned VM.
     */
    declare public readonly nodeName: pulumi.Output<string>;
    /**
     * Purge backup configuration on destroy.
     */
    declare public readonly purgeOnDestroy: pulumi.Output<boolean>;
    /**
     * Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
     */
    declare public readonly rng: pulumi.Output<outputs.VM.ClonedVirtualMachineRng | undefined>;
    /**
     * Stop the VM on destroy (instead of shutdown).
     */
    declare public readonly stopOnDestroy: pulumi.Output<boolean>;
    /**
     * Tags applied after cloning.
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    declare public readonly timeouts: pulumi.Output<outputs.VM.ClonedVirtualMachineTimeouts | undefined>;
    /**
     * Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
     */
    declare public readonly vga: pulumi.Output<outputs.VM.ClonedVirtualMachineVga | undefined>;
    /**
     * The VM identifier in the Proxmox cluster.
     */
    declare public readonly vmId: pulumi.Output<string>;

    /**
     * Create a ClonedVirtualMachine resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClonedVirtualMachineArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClonedVirtualMachineArgs | ClonedVirtualMachineState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClonedVirtualMachineState | undefined;
            resourceInputs["cdrom"] = state?.cdrom;
            resourceInputs["clone"] = state?.clone;
            resourceInputs["cpu"] = state?.cpu;
            resourceInputs["delete"] = state?.delete;
            resourceInputs["deleteUnreferencedDisksOnDestroy"] = state?.deleteUnreferencedDisksOnDestroy;
            resourceInputs["description"] = state?.description;
            resourceInputs["disk"] = state?.disk;
            resourceInputs["memory"] = state?.memory;
            resourceInputs["name"] = state?.name;
            resourceInputs["network"] = state?.network;
            resourceInputs["nodeName"] = state?.nodeName;
            resourceInputs["purgeOnDestroy"] = state?.purgeOnDestroy;
            resourceInputs["rng"] = state?.rng;
            resourceInputs["stopOnDestroy"] = state?.stopOnDestroy;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["timeouts"] = state?.timeouts;
            resourceInputs["vga"] = state?.vga;
            resourceInputs["vmId"] = state?.vmId;
        } else {
            const args = argsOrState as ClonedVirtualMachineArgs | undefined;
            if (args?.clone === undefined && !opts.urn) {
                throw new Error("Missing required property 'clone'");
            }
            if (args?.nodeName === undefined && !opts.urn) {
                throw new Error("Missing required property 'nodeName'");
            }
            resourceInputs["cdrom"] = args?.cdrom;
            resourceInputs["clone"] = args?.clone;
            resourceInputs["cpu"] = args?.cpu;
            resourceInputs["delete"] = args?.delete;
            resourceInputs["deleteUnreferencedDisksOnDestroy"] = args?.deleteUnreferencedDisksOnDestroy;
            resourceInputs["description"] = args?.description;
            resourceInputs["disk"] = args?.disk;
            resourceInputs["memory"] = args?.memory;
            resourceInputs["name"] = args?.name;
            resourceInputs["network"] = args?.network;
            resourceInputs["nodeName"] = args?.nodeName;
            resourceInputs["purgeOnDestroy"] = args?.purgeOnDestroy;
            resourceInputs["rng"] = args?.rng;
            resourceInputs["stopOnDestroy"] = args?.stopOnDestroy;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["timeouts"] = args?.timeouts;
            resourceInputs["vga"] = args?.vga;
            resourceInputs["vmId"] = args?.vmId;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ClonedVirtualMachine.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ClonedVirtualMachine resources.
 */
export interface ClonedVirtualMachineState {
    /**
     * The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
     */
    cdrom?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineCdrom>}>;
    /**
     * Clone settings. Changes require recreation.
     */
    clone?: pulumi.Input<inputs.VM.ClonedVirtualMachineClone>;
    /**
     * The CPU configuration.
     */
    cpu?: pulumi.Input<inputs.VM.ClonedVirtualMachineCpu>;
    /**
     * Explicit deletions to perform after cloning/updating. Entries persist across applies.
     */
    delete?: pulumi.Input<inputs.VM.ClonedVirtualMachineDelete>;
    deleteUnreferencedDisksOnDestroy?: pulumi.Input<boolean>;
    /**
     * Optional VM description applied after cloning.
     */
    description?: pulumi.Input<string>;
    /**
     * Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
     */
    disk?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineDisk>}>;
    /**
     * Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
     */
    memory?: pulumi.Input<inputs.VM.ClonedVirtualMachineMemory>;
    /**
     * Optional VM name override applied after cloning.
     */
    name?: pulumi.Input<string>;
    /**
     * Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
     */
    network?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineNetwork>}>;
    /**
     * Target node for the cloned VM.
     */
    nodeName?: pulumi.Input<string>;
    /**
     * Purge backup configuration on destroy.
     */
    purgeOnDestroy?: pulumi.Input<boolean>;
    /**
     * Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
     */
    rng?: pulumi.Input<inputs.VM.ClonedVirtualMachineRng>;
    /**
     * Stop the VM on destroy (instead of shutdown).
     */
    stopOnDestroy?: pulumi.Input<boolean>;
    /**
     * Tags applied after cloning.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    timeouts?: pulumi.Input<inputs.VM.ClonedVirtualMachineTimeouts>;
    /**
     * Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
     */
    vga?: pulumi.Input<inputs.VM.ClonedVirtualMachineVga>;
    /**
     * The VM identifier in the Proxmox cluster.
     */
    vmId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ClonedVirtualMachine resource.
 */
export interface ClonedVirtualMachineArgs {
    /**
     * The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
     */
    cdrom?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineCdrom>}>;
    /**
     * Clone settings. Changes require recreation.
     */
    clone: pulumi.Input<inputs.VM.ClonedVirtualMachineClone>;
    /**
     * The CPU configuration.
     */
    cpu?: pulumi.Input<inputs.VM.ClonedVirtualMachineCpu>;
    /**
     * Explicit deletions to perform after cloning/updating. Entries persist across applies.
     */
    delete?: pulumi.Input<inputs.VM.ClonedVirtualMachineDelete>;
    deleteUnreferencedDisksOnDestroy?: pulumi.Input<boolean>;
    /**
     * Optional VM description applied after cloning.
     */
    description?: pulumi.Input<string>;
    /**
     * Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
     */
    disk?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineDisk>}>;
    /**
     * Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
     */
    memory?: pulumi.Input<inputs.VM.ClonedVirtualMachineMemory>;
    /**
     * Optional VM name override applied after cloning.
     */
    name?: pulumi.Input<string>;
    /**
     * Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
     */
    network?: pulumi.Input<{[key: string]: pulumi.Input<inputs.VM.ClonedVirtualMachineNetwork>}>;
    /**
     * Target node for the cloned VM.
     */
    nodeName: pulumi.Input<string>;
    /**
     * Purge backup configuration on destroy.
     */
    purgeOnDestroy?: pulumi.Input<boolean>;
    /**
     * Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
     */
    rng?: pulumi.Input<inputs.VM.ClonedVirtualMachineRng>;
    /**
     * Stop the VM on destroy (instead of shutdown).
     */
    stopOnDestroy?: pulumi.Input<boolean>;
    /**
     * Tags applied after cloning.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    timeouts?: pulumi.Input<inputs.VM.ClonedVirtualMachineTimeouts>;
    /**
     * Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
     */
    vga?: pulumi.Input<inputs.VM.ClonedVirtualMachineVga>;
    /**
     * The VM identifier in the Proxmox cluster.
     */
    vmId?: pulumi.Input<string>;
}
