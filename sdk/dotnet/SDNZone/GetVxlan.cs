// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ProxmoxVE.SDNZone
{
    public static class GetVxlan
    {
        /// <summary>
        /// Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using ProxmoxVE = Pulumi.ProxmoxVE;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var example = ProxmoxVE.SDNZone.GetVxlan.Invoke(new()
        ///     {
        ///         Id = "vxlan1",
        ///     });
        /// 
        ///     return new Dictionary&lt;string, object?&gt;
        ///     {
        ///         ["dataProxmoxVirtualEnvironmentSdnZoneVxlan"] = 
        ///         {
        ///             { "id", example.Apply(getVxlanResult =&gt; getVxlanResult.Id) },
        ///             { "nodes", example.Apply(getVxlanResult =&gt; getVxlanResult.Nodes) },
        ///             { "peers", example.Apply(getVxlanResult =&gt; getVxlanResult.Peers) },
        ///             { "mtu", example.Apply(getVxlanResult =&gt; getVxlanResult.Mtu) },
        ///             { "dns", example.Apply(getVxlanResult =&gt; getVxlanResult.Dns) },
        ///             { "dnsZone", example.Apply(getVxlanResult =&gt; getVxlanResult.DnsZone) },
        ///             { "ipam", example.Apply(getVxlanResult =&gt; getVxlanResult.Ipam) },
        ///             { "reverseDns", example.Apply(getVxlanResult =&gt; getVxlanResult.ReverseDns) },
        ///         },
        ///     };
        /// });
        /// ```
        /// </summary>
        public static Task<GetVxlanResult> InvokeAsync(GetVxlanArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetVxlanResult>("proxmoxve:SDNZone/getVxlan:getVxlan", args ?? new GetVxlanArgs(), options.WithDefaults());

        /// <summary>
        /// Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using ProxmoxVE = Pulumi.ProxmoxVE;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var example = ProxmoxVE.SDNZone.GetVxlan.Invoke(new()
        ///     {
        ///         Id = "vxlan1",
        ///     });
        /// 
        ///     return new Dictionary&lt;string, object?&gt;
        ///     {
        ///         ["dataProxmoxVirtualEnvironmentSdnZoneVxlan"] = 
        ///         {
        ///             { "id", example.Apply(getVxlanResult =&gt; getVxlanResult.Id) },
        ///             { "nodes", example.Apply(getVxlanResult =&gt; getVxlanResult.Nodes) },
        ///             { "peers", example.Apply(getVxlanResult =&gt; getVxlanResult.Peers) },
        ///             { "mtu", example.Apply(getVxlanResult =&gt; getVxlanResult.Mtu) },
        ///             { "dns", example.Apply(getVxlanResult =&gt; getVxlanResult.Dns) },
        ///             { "dnsZone", example.Apply(getVxlanResult =&gt; getVxlanResult.DnsZone) },
        ///             { "ipam", example.Apply(getVxlanResult =&gt; getVxlanResult.Ipam) },
        ///             { "reverseDns", example.Apply(getVxlanResult =&gt; getVxlanResult.ReverseDns) },
        ///         },
        ///     };
        /// });
        /// ```
        /// </summary>
        public static Output<GetVxlanResult> Invoke(GetVxlanInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetVxlanResult>("proxmoxve:SDNZone/getVxlan:getVxlan", args ?? new GetVxlanInvokeArgs(), options.WithDefaults());

        /// <summary>
        /// Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
        /// 
        /// ## Example Usage
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using ProxmoxVE = Pulumi.ProxmoxVE;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var example = ProxmoxVE.SDNZone.GetVxlan.Invoke(new()
        ///     {
        ///         Id = "vxlan1",
        ///     });
        /// 
        ///     return new Dictionary&lt;string, object?&gt;
        ///     {
        ///         ["dataProxmoxVirtualEnvironmentSdnZoneVxlan"] = 
        ///         {
        ///             { "id", example.Apply(getVxlanResult =&gt; getVxlanResult.Id) },
        ///             { "nodes", example.Apply(getVxlanResult =&gt; getVxlanResult.Nodes) },
        ///             { "peers", example.Apply(getVxlanResult =&gt; getVxlanResult.Peers) },
        ///             { "mtu", example.Apply(getVxlanResult =&gt; getVxlanResult.Mtu) },
        ///             { "dns", example.Apply(getVxlanResult =&gt; getVxlanResult.Dns) },
        ///             { "dnsZone", example.Apply(getVxlanResult =&gt; getVxlanResult.DnsZone) },
        ///             { "ipam", example.Apply(getVxlanResult =&gt; getVxlanResult.Ipam) },
        ///             { "reverseDns", example.Apply(getVxlanResult =&gt; getVxlanResult.ReverseDns) },
        ///         },
        ///     };
        /// });
        /// ```
        /// </summary>
        public static Output<GetVxlanResult> Invoke(GetVxlanInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetVxlanResult>("proxmoxve:SDNZone/getVxlan:getVxlan", args ?? new GetVxlanInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetVxlanArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The unique identifier of the SDN zone.
        /// </summary>
        [Input("id", required: true)]
        public string Id { get; set; } = null!;

        public GetVxlanArgs()
        {
        }
        public static new GetVxlanArgs Empty => new GetVxlanArgs();
    }

    public sealed class GetVxlanInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// The unique identifier of the SDN zone.
        /// </summary>
        [Input("id", required: true)]
        public Input<string> Id { get; set; } = null!;

        public GetVxlanInvokeArgs()
        {
        }
        public static new GetVxlanInvokeArgs Empty => new GetVxlanInvokeArgs();
    }


    [OutputType]
    public sealed class GetVxlanResult
    {
        /// <summary>
        /// DNS API server address.
        /// </summary>
        public readonly string Dns;
        /// <summary>
        /// DNS domain name. Used to register hostnames, such as `&lt;hostname&gt;.&lt;domain&gt;`. The DNS zone must already exist on the DNS server.
        /// </summary>
        public readonly string DnsZone;
        /// <summary>
        /// The unique identifier of the SDN zone.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// IP Address Management system.
        /// </summary>
        public readonly string Ipam;
        /// <summary>
        /// MTU value for the zone.
        /// </summary>
        public readonly int Mtu;
        /// <summary>
        /// The Proxmox nodes which the zone and associated VNets are deployed on
        /// </summary>
        public readonly ImmutableArray<string> Nodes;
        /// <summary>
        /// A list of IP addresses of each node in the VXLAN zone. This can be external nodes reachable at this IP address. All nodes in the cluster need to be mentioned here
        /// </summary>
        public readonly ImmutableArray<string> Peers;
        /// <summary>
        /// Indicates if the zone has pending configuration changes that need to be applied.
        /// </summary>
        public readonly bool Pending;
        /// <summary>
        /// Reverse DNS API server address.
        /// </summary>
        public readonly string ReverseDns;
        /// <summary>
        /// Indicates the current state of the zone.
        /// </summary>
        public readonly string State;

        [OutputConstructor]
        private GetVxlanResult(
            string dns,

            string dnsZone,

            string id,

            string ipam,

            int mtu,

            ImmutableArray<string> nodes,

            ImmutableArray<string> peers,

            bool pending,

            string reverseDns,

            string state)
        {
            Dns = dns;
            DnsZone = dnsZone;
            Id = id;
            Ipam = ipam;
            Mtu = mtu;
            Nodes = nodes;
            Peers = peers;
            Pending = pending;
            ReverseDns = reverseDns;
            State = state;
        }
    }
}
