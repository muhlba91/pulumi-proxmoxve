// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ProxmoxVE.VM
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using ProxmoxVE = Pulumi.ProxmoxVE;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Example 1: Basic clone with minimal management
    ///     var basicClone = new ProxmoxVE.VM.ClonedVirtualMachine("basic_clone", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "basic-clone",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///             Full = true,
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 4,
    ///         },
    ///     });
    /// 
    ///     // Example 2: Clone with explicit network management
    ///     var networkManaged = new ProxmoxVE.VM.ClonedVirtualMachine("network_managed", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "network-clone",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///         },
    ///         Network = 
    ///         {
    ///             { "net0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineNetworkArgs
    ///             {
    ///                 Bridge = "vmbr0",
    ///                 Model = "virtio",
    ///                 Tag = 100,
    ///             } },
    ///             { "net1", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineNetworkArgs
    ///             {
    ///                 Bridge = "vmbr1",
    ///                 Model = "virtio",
    ///                 Firewall = true,
    ///                 MacAddress = "BC:24:11:2E:C5:00",
    ///             } },
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 2,
    ///         },
    ///     });
    /// 
    ///     // Example 3: Clone with disk management
    ///     var diskManaged = new ProxmoxVE.VM.ClonedVirtualMachine("disk_managed", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "disk-clone",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///             TargetDatastore = "local-lvm",
    ///         },
    ///         Disk = 
    ///         {
    ///             { "scsi0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineDiskArgs
    ///             {
    ///                 DatastoreId = "local-lvm",
    ///                 SizeGb = 50,
    ///                 Discard = "on",
    ///                 Ssd = true,
    ///             } },
    ///             { "scsi1", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineDiskArgs
    ///             {
    ///                 DatastoreId = "local-lvm",
    ///                 SizeGb = 100,
    ///                 Backup = false,
    ///             } },
    ///         },
    ///     });
    /// 
    ///     // Example 4: Clone with explicit device deletion
    ///     var selectiveDelete = new ProxmoxVE.VM.ClonedVirtualMachine("selective_delete", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "minimal-clone",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///         },
    ///         Network = 
    ///         {
    ///             { "net0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineNetworkArgs
    ///             {
    ///                 Bridge = "vmbr0",
    ///                 Model = "virtio",
    ///             } },
    ///         },
    ///         Delete = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineDeleteArgs
    ///         {
    ///             Networks = new[]
    ///             {
    ///                 "net1",
    ///                 "net2",
    ///             },
    ///         },
    ///     });
    /// 
    ///     // Example 5: Full-featured clone with multiple settings
    ///     var fullFeatured = new ProxmoxVE.VM.ClonedVirtualMachine("full_featured", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "production-vm",
    ///         Description = "Production VM cloned from template",
    ///         Tags = new[]
    ///         {
    ///             "production",
    ///             "web",
    ///         },
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///             SourceNodeName = "pve",
    ///             Full = true,
    ///             TargetDatastore = "local-lvm",
    ///             Retries = 3,
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 8,
    ///             Sockets = 1,
    ///             Architecture = "x86_64",
    ///             Type = "host",
    ///         },
    ///         Memory = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineMemoryArgs
    ///         {
    ///             Size = 8192,
    ///             Balloon = 2048,
    ///             Shares = 2000,
    ///         },
    ///         Network = 
    ///         {
    ///             { "net0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineNetworkArgs
    ///             {
    ///                 Bridge = "vmbr0",
    ///                 Model = "virtio",
    ///                 Tag = 100,
    ///                 Firewall = true,
    ///                 RateLimit = 100,
    ///             } },
    ///         },
    ///         Disk = 
    ///         {
    ///             { "scsi0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineDiskArgs
    ///             {
    ///                 DatastoreId = "local-lvm",
    ///                 SizeGb = 100,
    ///                 Discard = "on",
    ///                 Iothread = true,
    ///                 Ssd = true,
    ///                 Cache = "writethrough",
    ///             } },
    ///         },
    ///         Vga = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineVgaArgs
    ///         {
    ///             Type = "std",
    ///             Memory = 16,
    ///         },
    ///         Delete = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineDeleteArgs
    ///         {
    ///             Disks = new[]
    ///             {
    ///                 "ide2",
    ///             },
    ///         },
    ///         StopOnDestroy = false,
    ///         PurgeOnDestroy = true,
    ///         DeleteUnreferencedDisksOnDestroy = false,
    ///         Timeouts = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineTimeoutsArgs
    ///         {
    ///             Create = "30m",
    ///             Update = "30m",
    ///             Delete = "10m",
    ///         },
    ///     });
    /// 
    ///     // Example 6: Linked clone for testing
    ///     var testClone = new ProxmoxVE.VM.ClonedVirtualMachine("test_clone", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "test-vm",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///             Full = false,
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 2,
    ///         },
    ///         Network = 
    ///         {
    ///             { "net0", new ProxmoxVE.VM.Inputs.ClonedVirtualMachineNetworkArgs
    ///             {
    ///                 Bridge = "vmbr0",
    ///                 Model = "virtio",
    ///             } },
    ///         },
    ///     });
    /// 
    ///     // Example 7: Clone with pool assignment
    ///     var pooledClone = new ProxmoxVE.VM.ClonedVirtualMachine("pooled_clone", new()
    ///     {
    ///         NodeName = "pve",
    ///         Name = "pooled-vm",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///             PoolId = "production",
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 4,
    ///         },
    ///     });
    /// 
    ///     // Example 8: Import existing cloned VM
    ///     var imported = new ProxmoxVE.VM.ClonedVirtualMachine("imported", new()
    ///     {
    ///         VmId = "123",
    ///         NodeName = "pve",
    ///         Clone = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCloneArgs
    ///         {
    ///             SourceVmId = 100,
    ///         },
    ///         Cpu = new ProxmoxVE.VM.Inputs.ClonedVirtualMachineCpuArgs
    ///         {
    ///             Cores = 4,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [ProxmoxVEResourceType("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine")]
    public partial class ClonedVirtualMachine : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `Q35` machine type only supports `Ide0` and `Ide2` of IDE interfaces.
        /// </summary>
        [Output("cdrom")]
        public Output<ImmutableDictionary<string, Outputs.ClonedVirtualMachineCdrom>?> Cdrom { get; private set; } = null!;

        /// <summary>
        /// Clone settings. Changes require recreation.
        /// </summary>
        [Output("clone")]
        public Output<Outputs.ClonedVirtualMachineClone> Clone { get; private set; } = null!;

        /// <summary>
        /// The CPU configuration.
        /// </summary>
        [Output("cpu")]
        public Output<Outputs.ClonedVirtualMachineCpu?> Cpu { get; private set; } = null!;

        /// <summary>
        /// Explicit deletions to perform after cloning/updating. Entries persist across applies.
        /// </summary>
        [Output("delete")]
        public Output<Outputs.ClonedVirtualMachineDelete?> Delete { get; private set; } = null!;

        [Output("deleteUnreferencedDisksOnDestroy")]
        public Output<bool> DeleteUnreferencedDisksOnDestroy { get; private set; } = null!;

        /// <summary>
        /// Optional VM description applied after cloning.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        /// </summary>
        [Output("disk")]
        public Output<ImmutableDictionary<string, Outputs.ClonedVirtualMachineDisk>?> Disk { get; private set; } = null!;

        /// <summary>
        /// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `Size` sets the total available RAM, while `Balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        /// </summary>
        [Output("memory")]
        public Output<Outputs.ClonedVirtualMachineMemory?> Memory { get; private set; } = null!;

        /// <summary>
        /// Optional VM name override applied after cloning.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        /// </summary>
        [Output("network")]
        public Output<ImmutableDictionary<string, Outputs.ClonedVirtualMachineNetwork>?> Network { get; private set; } = null!;

        /// <summary>
        /// Target node for the cloned VM.
        /// </summary>
        [Output("nodeName")]
        public Output<string> NodeName { get; private set; } = null!;

        /// <summary>
        /// Purge backup configuration on destroy.
        /// </summary>
        [Output("purgeOnDestroy")]
        public Output<bool> PurgeOnDestroy { get; private set; } = null!;

        /// <summary>
        /// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        /// </summary>
        [Output("rng")]
        public Output<Outputs.ClonedVirtualMachineRng?> Rng { get; private set; } = null!;

        /// <summary>
        /// Stop the VM on destroy (instead of shutdown).
        /// </summary>
        [Output("stopOnDestroy")]
        public Output<bool> StopOnDestroy { get; private set; } = null!;

        /// <summary>
        /// Tags applied after cloning.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        [Output("timeouts")]
        public Output<Outputs.ClonedVirtualMachineTimeouts?> Timeouts { get; private set; } = null!;

        /// <summary>
        /// Configure the VGA Hardware. If you want to use high resolution modes (&gt;= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `Std` for all OS types besides some Windows versions (XP and older) which use `Cirrus`. The `Qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        /// </summary>
        [Output("vga")]
        public Output<Outputs.ClonedVirtualMachineVga?> Vga { get; private set; } = null!;

        /// <summary>
        /// The VM identifier in the Proxmox cluster.
        /// </summary>
        [Output("vmId")]
        public Output<string> VmId { get; private set; } = null!;


        /// <summary>
        /// Create a ClonedVirtualMachine resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ClonedVirtualMachine(string name, ClonedVirtualMachineArgs args, CustomResourceOptions? options = null)
            : base("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine", name, args ?? new ClonedVirtualMachineArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ClonedVirtualMachine(string name, Input<string> id, ClonedVirtualMachineState? state = null, CustomResourceOptions? options = null)
            : base("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/muhlba91/pulumi-proxmoxve",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ClonedVirtualMachine resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ClonedVirtualMachine Get(string name, Input<string> id, ClonedVirtualMachineState? state = null, CustomResourceOptions? options = null)
        {
            return new ClonedVirtualMachine(name, id, state, options);
        }
    }

    public sealed class ClonedVirtualMachineArgs : global::Pulumi.ResourceArgs
    {
        [Input("cdrom")]
        private InputMap<Inputs.ClonedVirtualMachineCdromArgs>? _cdrom;

        /// <summary>
        /// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `Q35` machine type only supports `Ide0` and `Ide2` of IDE interfaces.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineCdromArgs> Cdrom
        {
            get => _cdrom ?? (_cdrom = new InputMap<Inputs.ClonedVirtualMachineCdromArgs>());
            set => _cdrom = value;
        }

        /// <summary>
        /// Clone settings. Changes require recreation.
        /// </summary>
        [Input("clone", required: true)]
        public Input<Inputs.ClonedVirtualMachineCloneArgs> Clone { get; set; } = null!;

        /// <summary>
        /// The CPU configuration.
        /// </summary>
        [Input("cpu")]
        public Input<Inputs.ClonedVirtualMachineCpuArgs>? Cpu { get; set; }

        /// <summary>
        /// Explicit deletions to perform after cloning/updating. Entries persist across applies.
        /// </summary>
        [Input("delete")]
        public Input<Inputs.ClonedVirtualMachineDeleteArgs>? Delete { get; set; }

        [Input("deleteUnreferencedDisksOnDestroy")]
        public Input<bool>? DeleteUnreferencedDisksOnDestroy { get; set; }

        /// <summary>
        /// Optional VM description applied after cloning.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disk")]
        private InputMap<Inputs.ClonedVirtualMachineDiskArgs>? _disk;

        /// <summary>
        /// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineDiskArgs> Disk
        {
            get => _disk ?? (_disk = new InputMap<Inputs.ClonedVirtualMachineDiskArgs>());
            set => _disk = value;
        }

        /// <summary>
        /// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `Size` sets the total available RAM, while `Balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        /// </summary>
        [Input("memory")]
        public Input<Inputs.ClonedVirtualMachineMemoryArgs>? Memory { get; set; }

        /// <summary>
        /// Optional VM name override applied after cloning.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("network")]
        private InputMap<Inputs.ClonedVirtualMachineNetworkArgs>? _network;

        /// <summary>
        /// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineNetworkArgs> Network
        {
            get => _network ?? (_network = new InputMap<Inputs.ClonedVirtualMachineNetworkArgs>());
            set => _network = value;
        }

        /// <summary>
        /// Target node for the cloned VM.
        /// </summary>
        [Input("nodeName", required: true)]
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// Purge backup configuration on destroy.
        /// </summary>
        [Input("purgeOnDestroy")]
        public Input<bool>? PurgeOnDestroy { get; set; }

        /// <summary>
        /// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        /// </summary>
        [Input("rng")]
        public Input<Inputs.ClonedVirtualMachineRngArgs>? Rng { get; set; }

        /// <summary>
        /// Stop the VM on destroy (instead of shutdown).
        /// </summary>
        [Input("stopOnDestroy")]
        public Input<bool>? StopOnDestroy { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// Tags applied after cloning.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        [Input("timeouts")]
        public Input<Inputs.ClonedVirtualMachineTimeoutsArgs>? Timeouts { get; set; }

        /// <summary>
        /// Configure the VGA Hardware. If you want to use high resolution modes (&gt;= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `Std` for all OS types besides some Windows versions (XP and older) which use `Cirrus`. The `Qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        /// </summary>
        [Input("vga")]
        public Input<Inputs.ClonedVirtualMachineVgaArgs>? Vga { get; set; }

        /// <summary>
        /// The VM identifier in the Proxmox cluster.
        /// </summary>
        [Input("vmId")]
        public Input<string>? VmId { get; set; }

        public ClonedVirtualMachineArgs()
        {
        }
        public static new ClonedVirtualMachineArgs Empty => new ClonedVirtualMachineArgs();
    }

    public sealed class ClonedVirtualMachineState : global::Pulumi.ResourceArgs
    {
        [Input("cdrom")]
        private InputMap<Inputs.ClonedVirtualMachineCdromGetArgs>? _cdrom;

        /// <summary>
        /// The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `Q35` machine type only supports `Ide0` and `Ide2` of IDE interfaces.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineCdromGetArgs> Cdrom
        {
            get => _cdrom ?? (_cdrom = new InputMap<Inputs.ClonedVirtualMachineCdromGetArgs>());
            set => _cdrom = value;
        }

        /// <summary>
        /// Clone settings. Changes require recreation.
        /// </summary>
        [Input("clone")]
        public Input<Inputs.ClonedVirtualMachineCloneGetArgs>? Clone { get; set; }

        /// <summary>
        /// The CPU configuration.
        /// </summary>
        [Input("cpu")]
        public Input<Inputs.ClonedVirtualMachineCpuGetArgs>? Cpu { get; set; }

        /// <summary>
        /// Explicit deletions to perform after cloning/updating. Entries persist across applies.
        /// </summary>
        [Input("delete")]
        public Input<Inputs.ClonedVirtualMachineDeleteGetArgs>? Delete { get; set; }

        [Input("deleteUnreferencedDisksOnDestroy")]
        public Input<bool>? DeleteUnreferencedDisksOnDestroy { get; set; }

        /// <summary>
        /// Optional VM description applied after cloning.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("disk")]
        private InputMap<Inputs.ClonedVirtualMachineDiskGetArgs>? _disk;

        /// <summary>
        /// Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineDiskGetArgs> Disk
        {
            get => _disk ?? (_disk = new InputMap<Inputs.ClonedVirtualMachineDiskGetArgs>());
            set => _disk = value;
        }

        /// <summary>
        /// Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `Size` sets the total available RAM, while `Balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        /// </summary>
        [Input("memory")]
        public Input<Inputs.ClonedVirtualMachineMemoryGetArgs>? Memory { get; set; }

        /// <summary>
        /// Optional VM name override applied after cloning.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("network")]
        private InputMap<Inputs.ClonedVirtualMachineNetworkGetArgs>? _network;

        /// <summary>
        /// Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        /// </summary>
        public InputMap<Inputs.ClonedVirtualMachineNetworkGetArgs> Network
        {
            get => _network ?? (_network = new InputMap<Inputs.ClonedVirtualMachineNetworkGetArgs>());
            set => _network = value;
        }

        /// <summary>
        /// Target node for the cloned VM.
        /// </summary>
        [Input("nodeName")]
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// Purge backup configuration on destroy.
        /// </summary>
        [Input("purgeOnDestroy")]
        public Input<bool>? PurgeOnDestroy { get; set; }

        /// <summary>
        /// Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        /// </summary>
        [Input("rng")]
        public Input<Inputs.ClonedVirtualMachineRngGetArgs>? Rng { get; set; }

        /// <summary>
        /// Stop the VM on destroy (instead of shutdown).
        /// </summary>
        [Input("stopOnDestroy")]
        public Input<bool>? StopOnDestroy { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// Tags applied after cloning.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        [Input("timeouts")]
        public Input<Inputs.ClonedVirtualMachineTimeoutsGetArgs>? Timeouts { get; set; }

        /// <summary>
        /// Configure the VGA Hardware. If you want to use high resolution modes (&gt;= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `Std` for all OS types besides some Windows versions (XP and older) which use `Cirrus`. The `Qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        /// </summary>
        [Input("vga")]
        public Input<Inputs.ClonedVirtualMachineVgaGetArgs>? Vga { get; set; }

        /// <summary>
        /// The VM identifier in the Proxmox cluster.
        /// </summary>
        [Input("vmId")]
        public Input<string>? VmId { get; set; }

        public ClonedVirtualMachineState()
        {
        }
        public static new ClonedVirtualMachineState Empty => new ClonedVirtualMachineState();
    }
}
