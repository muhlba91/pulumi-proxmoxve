// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.ProxmoxVE.Download
{
    /// <summary>
    /// Manages files upload using PVE download-url API. It can be fully compatible and faster replacement for image files created using `proxmoxve.Storage.File`. Supports images for VMs (ISO images) and LXC (CT Templates).
    /// 
    /// &gt; Besides the `Datastore.AllocateTemplate` privilege, this resource requires both the `Sys.Audit` and `Sys.Modify` privileges.&lt;br&gt;&lt;br&gt;
    /// For more details, see the [`download-url`](https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/storage/{storage}/download-url) API documentation under the "Required permissions" section.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using ProxmoxVE = Pulumi.ProxmoxVE;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var release20231228Debian12BookwormQcow2Img = new ProxmoxVE.Download.File("release20231228Debian12BookwormQcow2Img", new()
    ///     {
    ///         Checksum = "d2fbcf11fb28795842e91364d8c7b69f1870db09ff299eb94e4fbbfa510eb78d141e74c1f4bf6dfa0b7e33d0c3b66e6751886feadb4e9916f778bab1776bdf1b",
    ///         ChecksumAlgorithm = "sha512",
    ///         ContentType = "iso",
    ///         DatastoreId = "local",
    ///         FileName = "debian-12-generic-amd64-20231228-1609.img",
    ///         NodeName = "pve",
    ///         Url = "https://cloud.debian.org/images/cloud/bookworm/20231228-1609/debian-12-generic-amd64-20231228-1609.qcow2",
    ///     });
    /// 
    ///     var latestDebian12BookwormQcow2Img = new ProxmoxVE.Download.File("latestDebian12BookwormQcow2Img", new()
    ///     {
    ///         ContentType = "iso",
    ///         DatastoreId = "local",
    ///         FileName = "debian-12-generic-amd64.qcow2.img",
    ///         NodeName = "pve",
    ///         Url = "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2",
    ///     });
    /// 
    ///     var latestUbuntu22JammyQcow2Img = new ProxmoxVE.Download.File("latestUbuntu22JammyQcow2Img", new()
    ///     {
    ///         ContentType = "iso",
    ///         DatastoreId = "local",
    ///         NodeName = "pve",
    ///         Url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img",
    ///     });
    /// 
    ///     var latestStaticUbuntu24NobleQcow2Img = new ProxmoxVE.Download.File("latestStaticUbuntu24NobleQcow2Img", new()
    ///     {
    ///         ContentType = "iso",
    ///         DatastoreId = "local",
    ///         NodeName = "pve",
    ///         Overwrite = false,
    ///         Url = "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img",
    ///     });
    /// 
    ///     var release20231211Ubuntu22JammyLxcImg = new ProxmoxVE.Download.File("release20231211Ubuntu22JammyLxcImg", new()
    ///     {
    ///         Checksum = "c9997dcfea5d826fd04871f960c513665f2e87dd7450bba99f68a97e60e4586e",
    ///         ChecksumAlgorithm = "sha256",
    ///         ContentType = "vztmpl",
    ///         DatastoreId = "local",
    ///         NodeName = "pve",
    ///         UploadTimeout = 4444,
    ///         Url = "https://cloud-images.ubuntu.com/releases/22.04/release-20231211/ubuntu-22.04-server-cloudimg-amd64-root.tar.xz",
    ///     });
    /// 
    ///     var latestUbuntu22JammyLxcImg = new ProxmoxVE.Download.File("latestUbuntu22JammyLxcImg", new()
    ///     {
    ///         ContentType = "vztmpl",
    ///         DatastoreId = "local",
    ///         NodeName = "pve",
    ///         Url = "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.tar.gz",
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [ProxmoxVEResourceType("proxmoxve:Download/file:File")]
    public partial class File : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The expected checksum of the file.
        /// </summary>
        [Output("checksum")]
        public Output<string?> Checksum { get; private set; } = null!;

        /// <summary>
        /// The algorithm to calculate the checksum of the file. Must be `md5` | `sha1` | `sha224` | `sha256` | `sha384` | `sha512`.
        /// </summary>
        [Output("checksumAlgorithm")]
        public Output<string?> ChecksumAlgorithm { get; private set; } = null!;

        /// <summary>
        /// The file content type. Must be `iso` for VM images or `vztmpl` for LXC images.
        /// </summary>
        [Output("contentType")]
        public Output<string> ContentType { get; private set; } = null!;

        /// <summary>
        /// The identifier for the target datastore.
        /// </summary>
        [Output("datastoreId")]
        public Output<string> DatastoreId { get; private set; } = null!;

        /// <summary>
        /// Decompress the downloaded file using the specified compression algorithm. Must be one of `gz` | `lzo` | `zst`.
        /// </summary>
        [Output("decompressionAlgorithm")]
        public Output<string?> DecompressionAlgorithm { get; private set; } = null!;

        /// <summary>
        /// The file name. If not provided, it is calculated using `url`. PVE will raise 'wrong file extension' error for some popular extensions file `.raw` or `.qcow2`. Workaround is to use e.g. `.img` instead.
        /// </summary>
        [Output("fileName")]
        public Output<string> FileName { get; private set; } = null!;

        /// <summary>
        /// The node name.
        /// </summary>
        [Output("nodeName")]
        public Output<string> NodeName { get; private set; } = null!;

        /// <summary>
        /// If `true` and size of uploaded file is different, than size from `url` Content-Length header, file will be downloaded again. If `false`, there will be no checks.
        /// </summary>
        [Output("overwrite")]
        public Output<bool> Overwrite { get; private set; } = null!;

        /// <summary>
        /// If `true` and a file with the same name already exists in the datastore, it will be deleted and the new file will be downloaded. If `false` and the file already exists, an error will be returned.
        /// </summary>
        [Output("overwriteUnmanaged")]
        public Output<bool> OverwriteUnmanaged { get; private set; } = null!;

        /// <summary>
        /// The file size.
        /// </summary>
        [Output("size")]
        public Output<int> Size { get; private set; } = null!;

        /// <summary>
        /// The file download timeout seconds. Default is 600 (10min).
        /// </summary>
        [Output("uploadTimeout")]
        public Output<int> UploadTimeout { get; private set; } = null!;

        /// <summary>
        /// The URL to download the file from. Format `https?://.*`.
        /// </summary>
        [Output("url")]
        public Output<string> Url { get; private set; } = null!;

        /// <summary>
        /// By default `true`. If `false`, no SSL/TLS certificates will be verified.
        /// </summary>
        [Output("verify")]
        public Output<bool> Verify { get; private set; } = null!;


        /// <summary>
        /// Create a File resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public File(string name, FileArgs args, CustomResourceOptions? options = null)
            : base("proxmoxve:Download/file:File", name, args ?? new FileArgs(), MakeResourceOptions(options, ""))
        {
        }

        private File(string name, Input<string> id, FileState? state = null, CustomResourceOptions? options = null)
            : base("proxmoxve:Download/file:File", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/muhlba91/pulumi-proxmoxve",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing File resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static File Get(string name, Input<string> id, FileState? state = null, CustomResourceOptions? options = null)
        {
            return new File(name, id, state, options);
        }
    }

    public sealed class FileArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The expected checksum of the file.
        /// </summary>
        [Input("checksum")]
        public Input<string>? Checksum { get; set; }

        /// <summary>
        /// The algorithm to calculate the checksum of the file. Must be `md5` | `sha1` | `sha224` | `sha256` | `sha384` | `sha512`.
        /// </summary>
        [Input("checksumAlgorithm")]
        public Input<string>? ChecksumAlgorithm { get; set; }

        /// <summary>
        /// The file content type. Must be `iso` for VM images or `vztmpl` for LXC images.
        /// </summary>
        [Input("contentType", required: true)]
        public Input<string> ContentType { get; set; } = null!;

        /// <summary>
        /// The identifier for the target datastore.
        /// </summary>
        [Input("datastoreId", required: true)]
        public Input<string> DatastoreId { get; set; } = null!;

        /// <summary>
        /// Decompress the downloaded file using the specified compression algorithm. Must be one of `gz` | `lzo` | `zst`.
        /// </summary>
        [Input("decompressionAlgorithm")]
        public Input<string>? DecompressionAlgorithm { get; set; }

        /// <summary>
        /// The file name. If not provided, it is calculated using `url`. PVE will raise 'wrong file extension' error for some popular extensions file `.raw` or `.qcow2`. Workaround is to use e.g. `.img` instead.
        /// </summary>
        [Input("fileName")]
        public Input<string>? FileName { get; set; }

        /// <summary>
        /// The node name.
        /// </summary>
        [Input("nodeName", required: true)]
        public Input<string> NodeName { get; set; } = null!;

        /// <summary>
        /// If `true` and size of uploaded file is different, than size from `url` Content-Length header, file will be downloaded again. If `false`, there will be no checks.
        /// </summary>
        [Input("overwrite")]
        public Input<bool>? Overwrite { get; set; }

        /// <summary>
        /// If `true` and a file with the same name already exists in the datastore, it will be deleted and the new file will be downloaded. If `false` and the file already exists, an error will be returned.
        /// </summary>
        [Input("overwriteUnmanaged")]
        public Input<bool>? OverwriteUnmanaged { get; set; }

        /// <summary>
        /// The file download timeout seconds. Default is 600 (10min).
        /// </summary>
        [Input("uploadTimeout")]
        public Input<int>? UploadTimeout { get; set; }

        /// <summary>
        /// The URL to download the file from. Format `https?://.*`.
        /// </summary>
        [Input("url", required: true)]
        public Input<string> Url { get; set; } = null!;

        /// <summary>
        /// By default `true`. If `false`, no SSL/TLS certificates will be verified.
        /// </summary>
        [Input("verify")]
        public Input<bool>? Verify { get; set; }

        public FileArgs()
        {
        }
        public static new FileArgs Empty => new FileArgs();
    }

    public sealed class FileState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The expected checksum of the file.
        /// </summary>
        [Input("checksum")]
        public Input<string>? Checksum { get; set; }

        /// <summary>
        /// The algorithm to calculate the checksum of the file. Must be `md5` | `sha1` | `sha224` | `sha256` | `sha384` | `sha512`.
        /// </summary>
        [Input("checksumAlgorithm")]
        public Input<string>? ChecksumAlgorithm { get; set; }

        /// <summary>
        /// The file content type. Must be `iso` for VM images or `vztmpl` for LXC images.
        /// </summary>
        [Input("contentType")]
        public Input<string>? ContentType { get; set; }

        /// <summary>
        /// The identifier for the target datastore.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        /// <summary>
        /// Decompress the downloaded file using the specified compression algorithm. Must be one of `gz` | `lzo` | `zst`.
        /// </summary>
        [Input("decompressionAlgorithm")]
        public Input<string>? DecompressionAlgorithm { get; set; }

        /// <summary>
        /// The file name. If not provided, it is calculated using `url`. PVE will raise 'wrong file extension' error for some popular extensions file `.raw` or `.qcow2`. Workaround is to use e.g. `.img` instead.
        /// </summary>
        [Input("fileName")]
        public Input<string>? FileName { get; set; }

        /// <summary>
        /// The node name.
        /// </summary>
        [Input("nodeName")]
        public Input<string>? NodeName { get; set; }

        /// <summary>
        /// If `true` and size of uploaded file is different, than size from `url` Content-Length header, file will be downloaded again. If `false`, there will be no checks.
        /// </summary>
        [Input("overwrite")]
        public Input<bool>? Overwrite { get; set; }

        /// <summary>
        /// If `true` and a file with the same name already exists in the datastore, it will be deleted and the new file will be downloaded. If `false` and the file already exists, an error will be returned.
        /// </summary>
        [Input("overwriteUnmanaged")]
        public Input<bool>? OverwriteUnmanaged { get; set; }

        /// <summary>
        /// The file size.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// The file download timeout seconds. Default is 600 (10min).
        /// </summary>
        [Input("uploadTimeout")]
        public Input<int>? UploadTimeout { get; set; }

        /// <summary>
        /// The URL to download the file from. Format `https?://.*`.
        /// </summary>
        [Input("url")]
        public Input<string>? Url { get; set; }

        /// <summary>
        /// By default `true`. If `false`, no SSL/TLS certificates will be verified.
        /// </summary>
        [Input("verify")]
        public Input<bool>? Verify { get; set; }

        public FileState()
        {
        }
        public static new FileState Empty => new FileState();
    }
}
