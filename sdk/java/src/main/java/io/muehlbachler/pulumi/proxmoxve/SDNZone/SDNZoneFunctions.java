// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.muehlbachler.pulumi.proxmoxve.SDNZone;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.deployment.InvokeOutputOptions;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetEvpnPlainArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetQinqPlainArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetSimplePlainArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetVlanPlainArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.inputs.GetVxlanPlainArgs;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.outputs.GetEvpnResult;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.outputs.GetQinqResult;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.outputs.GetSimpleResult;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.outputs.GetVlanResult;
import io.muehlbachler.pulumi.proxmoxve.SDNZone.outputs.GetVxlanResult;
import io.muehlbachler.pulumi.proxmoxve.Utilities;
import java.util.concurrent.CompletableFuture;

public final class SDNZoneFunctions {
    /**
     * Retrieves information about an EVPN Zone in Proxmox SDN. The EVPN zone creates a routable Layer 3 network, capable of spanning across multiple clusters.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getEvpn(GetEvpnArgs.builder()
     *             .id("evpn1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneEvpn", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("controller", example.controller()),
     *             Map.entry("vrf_vxlan", example.vrfVxlan()),
     *             Map.entry("advertise_subnets", example.advertiseSubnets()),
     *             Map.entry("disable_arp_nd_suppression", example.disableArpNdSuppression()),
     *             Map.entry("exit_nodes", example.exitNodes()),
     *             Map.entry("exit_nodes_local_routing", example.exitNodesLocalRouting()),
     *             Map.entry("primary_exit_node", example.primaryExitNode()),
     *             Map.entry("rt_import", example.rtImport()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetEvpnResult> getEvpn(GetEvpnArgs args) {
        return getEvpn(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about an EVPN Zone in Proxmox SDN. The EVPN zone creates a routable Layer 3 network, capable of spanning across multiple clusters.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getEvpn(GetEvpnArgs.builder()
     *             .id("evpn1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneEvpn", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("controller", example.controller()),
     *             Map.entry("vrf_vxlan", example.vrfVxlan()),
     *             Map.entry("advertise_subnets", example.advertiseSubnets()),
     *             Map.entry("disable_arp_nd_suppression", example.disableArpNdSuppression()),
     *             Map.entry("exit_nodes", example.exitNodes()),
     *             Map.entry("exit_nodes_local_routing", example.exitNodesLocalRouting()),
     *             Map.entry("primary_exit_node", example.primaryExitNode()),
     *             Map.entry("rt_import", example.rtImport()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetEvpnResult> getEvpnPlain(GetEvpnPlainArgs args) {
        return getEvpnPlain(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about an EVPN Zone in Proxmox SDN. The EVPN zone creates a routable Layer 3 network, capable of spanning across multiple clusters.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getEvpn(GetEvpnArgs.builder()
     *             .id("evpn1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneEvpn", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("controller", example.controller()),
     *             Map.entry("vrf_vxlan", example.vrfVxlan()),
     *             Map.entry("advertise_subnets", example.advertiseSubnets()),
     *             Map.entry("disable_arp_nd_suppression", example.disableArpNdSuppression()),
     *             Map.entry("exit_nodes", example.exitNodes()),
     *             Map.entry("exit_nodes_local_routing", example.exitNodesLocalRouting()),
     *             Map.entry("primary_exit_node", example.primaryExitNode()),
     *             Map.entry("rt_import", example.rtImport()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetEvpnResult> getEvpn(GetEvpnArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getEvpn:getEvpn", TypeShape.of(GetEvpnResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about an EVPN Zone in Proxmox SDN. The EVPN zone creates a routable Layer 3 network, capable of spanning across multiple clusters.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getEvpn(GetEvpnArgs.builder()
     *             .id("evpn1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneEvpn", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("controller", example.controller()),
     *             Map.entry("vrf_vxlan", example.vrfVxlan()),
     *             Map.entry("advertise_subnets", example.advertiseSubnets()),
     *             Map.entry("disable_arp_nd_suppression", example.disableArpNdSuppression()),
     *             Map.entry("exit_nodes", example.exitNodes()),
     *             Map.entry("exit_nodes_local_routing", example.exitNodesLocalRouting()),
     *             Map.entry("primary_exit_node", example.primaryExitNode()),
     *             Map.entry("rt_import", example.rtImport()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetEvpnResult> getEvpn(GetEvpnArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getEvpn:getEvpn", TypeShape.of(GetEvpnResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about an EVPN Zone in Proxmox SDN. The EVPN zone creates a routable Layer 3 network, capable of spanning across multiple clusters.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetEvpnArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getEvpn(GetEvpnArgs.builder()
     *             .id("evpn1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneEvpn", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("controller", example.controller()),
     *             Map.entry("vrf_vxlan", example.vrfVxlan()),
     *             Map.entry("advertise_subnets", example.advertiseSubnets()),
     *             Map.entry("disable_arp_nd_suppression", example.disableArpNdSuppression()),
     *             Map.entry("exit_nodes", example.exitNodes()),
     *             Map.entry("exit_nodes_local_routing", example.exitNodesLocalRouting()),
     *             Map.entry("primary_exit_node", example.primaryExitNode()),
     *             Map.entry("rt_import", example.rtImport()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetEvpnResult> getEvpnPlain(GetEvpnPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("proxmoxve:SDNZone/getEvpn:getEvpn", TypeShape.of(GetEvpnResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a QinQ Zone in Proxmox SDN. QinQ also known as VLAN stacking, that uses multiple layers of VLAN tags for isolation. The QinQ zone defines the outer VLAN tag (the Service VLAN) whereas the inner VLAN tag is defined by the VNet. Your physical network switches must support stacked VLANs for this configuration. Due to the double stacking of tags, you need 4 more bytes for QinQ VLANs. For example, you must reduce the MTU to 1496 if you physical interface MTU is 1500.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getQinq(GetQinqArgs.builder()
     *             .id("qinq1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneQinq", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("service_vlan", example.serviceVlan()),
     *             Map.entry("service_vlan_protocol", example.serviceVlanProtocol()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetQinqResult> getQinq(GetQinqArgs args) {
        return getQinq(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a QinQ Zone in Proxmox SDN. QinQ also known as VLAN stacking, that uses multiple layers of VLAN tags for isolation. The QinQ zone defines the outer VLAN tag (the Service VLAN) whereas the inner VLAN tag is defined by the VNet. Your physical network switches must support stacked VLANs for this configuration. Due to the double stacking of tags, you need 4 more bytes for QinQ VLANs. For example, you must reduce the MTU to 1496 if you physical interface MTU is 1500.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getQinq(GetQinqArgs.builder()
     *             .id("qinq1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneQinq", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("service_vlan", example.serviceVlan()),
     *             Map.entry("service_vlan_protocol", example.serviceVlanProtocol()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetQinqResult> getQinqPlain(GetQinqPlainArgs args) {
        return getQinqPlain(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a QinQ Zone in Proxmox SDN. QinQ also known as VLAN stacking, that uses multiple layers of VLAN tags for isolation. The QinQ zone defines the outer VLAN tag (the Service VLAN) whereas the inner VLAN tag is defined by the VNet. Your physical network switches must support stacked VLANs for this configuration. Due to the double stacking of tags, you need 4 more bytes for QinQ VLANs. For example, you must reduce the MTU to 1496 if you physical interface MTU is 1500.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getQinq(GetQinqArgs.builder()
     *             .id("qinq1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneQinq", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("service_vlan", example.serviceVlan()),
     *             Map.entry("service_vlan_protocol", example.serviceVlanProtocol()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetQinqResult> getQinq(GetQinqArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getQinq:getQinq", TypeShape.of(GetQinqResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a QinQ Zone in Proxmox SDN. QinQ also known as VLAN stacking, that uses multiple layers of VLAN tags for isolation. The QinQ zone defines the outer VLAN tag (the Service VLAN) whereas the inner VLAN tag is defined by the VNet. Your physical network switches must support stacked VLANs for this configuration. Due to the double stacking of tags, you need 4 more bytes for QinQ VLANs. For example, you must reduce the MTU to 1496 if you physical interface MTU is 1500.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getQinq(GetQinqArgs.builder()
     *             .id("qinq1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneQinq", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("service_vlan", example.serviceVlan()),
     *             Map.entry("service_vlan_protocol", example.serviceVlanProtocol()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetQinqResult> getQinq(GetQinqArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getQinq:getQinq", TypeShape.of(GetQinqResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a QinQ Zone in Proxmox SDN. QinQ also known as VLAN stacking, that uses multiple layers of VLAN tags for isolation. The QinQ zone defines the outer VLAN tag (the Service VLAN) whereas the inner VLAN tag is defined by the VNet. Your physical network switches must support stacked VLANs for this configuration. Due to the double stacking of tags, you need 4 more bytes for QinQ VLANs. For example, you must reduce the MTU to 1496 if you physical interface MTU is 1500.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetQinqArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getQinq(GetQinqArgs.builder()
     *             .id("qinq1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneQinq", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("service_vlan", example.serviceVlan()),
     *             Map.entry("service_vlan_protocol", example.serviceVlanProtocol()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetQinqResult> getQinqPlain(GetQinqPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("proxmoxve:SDNZone/getQinq:getQinq", TypeShape.of(GetQinqResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a Simple Zone in Proxmox SDN. It will create an isolated VNet bridge. This bridge is not linked to a physical interface, and VM traffic is only local on each the node. It can be used in NAT or routed setups.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getSimple(GetSimpleArgs.builder()
     *             .id("simple1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneSimple", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSimpleResult> getSimple(GetSimpleArgs args) {
        return getSimple(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a Simple Zone in Proxmox SDN. It will create an isolated VNet bridge. This bridge is not linked to a physical interface, and VM traffic is only local on each the node. It can be used in NAT or routed setups.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getSimple(GetSimpleArgs.builder()
     *             .id("simple1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneSimple", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetSimpleResult> getSimplePlain(GetSimplePlainArgs args) {
        return getSimplePlain(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a Simple Zone in Proxmox SDN. It will create an isolated VNet bridge. This bridge is not linked to a physical interface, and VM traffic is only local on each the node. It can be used in NAT or routed setups.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getSimple(GetSimpleArgs.builder()
     *             .id("simple1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneSimple", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSimpleResult> getSimple(GetSimpleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getSimple:getSimple", TypeShape.of(GetSimpleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a Simple Zone in Proxmox SDN. It will create an isolated VNet bridge. This bridge is not linked to a physical interface, and VM traffic is only local on each the node. It can be used in NAT or routed setups.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getSimple(GetSimpleArgs.builder()
     *             .id("simple1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneSimple", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetSimpleResult> getSimple(GetSimpleArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getSimple:getSimple", TypeShape.of(GetSimpleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a Simple Zone in Proxmox SDN. It will create an isolated VNet bridge. This bridge is not linked to a physical interface, and VM traffic is only local on each the node. It can be used in NAT or routed setups.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetSimpleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getSimple(GetSimpleArgs.builder()
     *             .id("simple1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneSimple", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetSimpleResult> getSimplePlain(GetSimplePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("proxmoxve:SDNZone/getSimple:getSimple", TypeShape.of(GetSimpleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node&#39;s physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVlan(GetVlanArgs.builder()
     *             .id("vlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVlanResult> getVlan(GetVlanArgs args) {
        return getVlan(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node&#39;s physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVlan(GetVlanArgs.builder()
     *             .id("vlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVlanResult> getVlanPlain(GetVlanPlainArgs args) {
        return getVlanPlain(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node&#39;s physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVlan(GetVlanArgs.builder()
     *             .id("vlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVlanResult> getVlan(GetVlanArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getVlan:getVlan", TypeShape.of(GetVlanResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node&#39;s physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVlan(GetVlanArgs.builder()
     *             .id("vlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVlanResult> getVlan(GetVlanArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getVlan:getVlan", TypeShape.of(GetVlanResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node&#39;s physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVlan(GetVlanArgs.builder()
     *             .id("vlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("bridge", example.bridge()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVlanResult> getVlanPlain(GetVlanPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("proxmoxve:SDNZone/getVlan:getVlan", TypeShape.of(GetVlanResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVxlan(GetVxlanArgs.builder()
     *             .id("vxlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVxlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("peers", example.peers()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVxlanResult> getVxlan(GetVxlanArgs args) {
        return getVxlan(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVxlan(GetVxlanArgs.builder()
     *             .id("vxlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVxlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("peers", example.peers()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVxlanResult> getVxlanPlain(GetVxlanPlainArgs args) {
        return getVxlanPlain(args, InvokeOptions.Empty);
    }
    /**
     * Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVxlan(GetVxlanArgs.builder()
     *             .id("vxlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVxlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("peers", example.peers()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVxlanResult> getVxlan(GetVxlanArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getVxlan:getVxlan", TypeShape.of(GetVxlanResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVxlan(GetVxlanArgs.builder()
     *             .id("vxlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVxlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("peers", example.peers()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static Output<GetVxlanResult> getVxlan(GetVxlanArgs args, InvokeOutputOptions options) {
        return Deployment.getInstance().invoke("proxmoxve:SDNZone/getVxlan:getVxlan", TypeShape.of(GetVxlanResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Retrieves information about a VXLAN Zone in Proxmox SDN. It establishes a tunnel (overlay) on top of an existing network (underlay). This encapsulates layer 2 Ethernet frames within layer 4 UDP datagrams using the default destination port 4789. You have to configure the underlay network yourself to enable UDP connectivity between all peers. Because VXLAN encapsulation uses 50 bytes, the MTU needs to be 50 bytes lower than the outgoing physical interface.
     * 
     * ## Example Usage
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * <pre>
     * {@code
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.proxmoxve.SDNZone.SDNZoneFunctions;
     * import com.pulumi.proxmoxve.SDNZone.inputs.GetVxlanArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var example = SDNZoneFunctions.getVxlan(GetVxlanArgs.builder()
     *             .id("vxlan1")
     *             .build());
     * 
     *         ctx.export("dataProxmoxVirtualEnvironmentSdnZoneVxlan", Map.ofEntries(
     *             Map.entry("id", example.id()),
     *             Map.entry("nodes", example.nodes()),
     *             Map.entry("peers", example.peers()),
     *             Map.entry("mtu", example.mtu()),
     *             Map.entry("dns", example.dns()),
     *             Map.entry("dns_zone", example.dnsZone()),
     *             Map.entry("ipam", example.ipam()),
     *             Map.entry("reverse_dns", example.reverseDns())
     *         ));
     *     }
     * }
     * }
     * </pre>
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public static CompletableFuture<GetVxlanResult> getVxlanPlain(GetVxlanPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("proxmoxve:SDNZone/getVxlan:getVxlan", TypeShape.of(GetVxlanResult.class), args, Utilities.withVersion(options));
    }
}
