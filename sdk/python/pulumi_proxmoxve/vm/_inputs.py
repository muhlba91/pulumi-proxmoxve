# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'VirtualMachineAgentArgs',
    'VirtualMachineAudioDeviceArgs',
    'VirtualMachineCdromArgs',
    'VirtualMachineCloneArgs',
    'VirtualMachineCpuArgs',
    'VirtualMachineDiskArgs',
    'VirtualMachineDiskSpeedArgs',
    'VirtualMachineEfiDiskArgs',
    'VirtualMachineHostpciArgs',
    'VirtualMachineInitializationArgs',
    'VirtualMachineInitializationDnsArgs',
    'VirtualMachineInitializationIpConfigArgs',
    'VirtualMachineInitializationIpConfigIpv4Args',
    'VirtualMachineInitializationIpConfigIpv6Args',
    'VirtualMachineInitializationUserAccountArgs',
    'VirtualMachineMemoryArgs',
    'VirtualMachineNetworkDeviceArgs',
    'VirtualMachineOperatingSystemArgs',
    'VirtualMachineSerialDeviceArgs',
    'VirtualMachineSmbiosArgs',
    'VirtualMachineStartupArgs',
    'VirtualMachineVgaArgs',
]

@pulumi.input_type
class VirtualMachineAgentArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[str]] = None,
                 trim: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable the VGA device (defaults
               to `true`).
        :param pulumi.Input[str] timeout: The maximum amount of time to wait for data from
               the QEMU agent to become available ( defaults to `15m`).
        :param pulumi.Input[bool] trim: Whether to enable the FSTRIM feature in the QEMU agent
               (defaults to `false`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        VirtualMachineAgentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            timeout=timeout,
            trim=trim,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             timeout: Optional[pulumi.Input[str]] = None,
             trim: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if timeout is not None:
            _setter("timeout", timeout)
        if trim is not None:
            _setter("trim", trim)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the VGA device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum amount of time to wait for data from
        the QEMU agent to become available ( defaults to `15m`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def trim(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the FSTRIM feature in the QEMU agent
        (defaults to `false`).
        """
        return pulumi.get(self, "trim")

    @trim.setter
    def trim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trim", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineAudioDeviceArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[str]] = None,
                 driver: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] device: The device (defaults to `socket`).
               - `/dev/*` - A host serial device.
        :param pulumi.Input[str] driver: The driver (defaults to `spice`).
        :param pulumi.Input[bool] enabled: Whether to enable the VGA device (defaults
               to `true`).
        """
        VirtualMachineAudioDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
            driver=driver,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: Optional[pulumi.Input[str]] = None,
             driver: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if device is not None:
            _setter("device", device)
        if driver is not None:
            _setter("driver", driver)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def driver(self) -> Optional[pulumi.Input[str]]:
        """
        The driver (defaults to `spice`).
        """
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the VGA device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VirtualMachineCdromArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 file_id: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable the VGA device (defaults
               to `true`).
        :param pulumi.Input[str] file_id: The file ID for a disk image (experimental -
               might cause high CPU utilization during import, especially with large
               disk images).
        :param pulumi.Input[str] interface: The hardware interface to connect the cloud-init
               image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
               detected if the setting is missing but a cloud-init image is present,
               otherwise defaults to `ide2`.
        """
        VirtualMachineCdromArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            file_id=file_id,
            interface=interface,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             file_id: Optional[pulumi.Input[str]] = None,
             interface: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'fileId' in kwargs:
            file_id = kwargs['fileId']

        if enabled is not None:
            _setter("enabled", enabled)
        if file_id is not None:
            _setter("file_id", file_id)
        if interface is not None:
            _setter("interface", interface)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the VGA device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The file ID for a disk image (experimental -
        might cause high CPU utilization during import, especially with large
        disk images).
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)


@pulumi.input_type
class VirtualMachineCloneArgs:
    def __init__(__self__, *,
                 vm_id: pulumi.Input[int],
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 full: Optional[pulumi.Input[bool]] = None,
                 node_name: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] vm_id: The VM identifier.
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] node_name: The name of the node to assign the virtual machine
               to.
        :param pulumi.Input[int] retries: Number of retries in Proxmox for clone vm.
               Sometimes Proxmox errors with timeout when creating multiple clones at
               once.
        """
        VirtualMachineCloneArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vm_id=vm_id,
            datastore_id=datastore_id,
            full=full,
            node_name=node_name,
            retries=retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vm_id: pulumi.Input[int],
             datastore_id: Optional[pulumi.Input[str]] = None,
             full: Optional[pulumi.Input[bool]] = None,
             node_name: Optional[pulumi.Input[str]] = None,
             retries: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'vmId' in kwargs:
            vm_id = kwargs['vmId']
        if 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if 'nodeName' in kwargs:
            node_name = kwargs['nodeName']

        _setter("vm_id", vm_id)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if full is not None:
            _setter("full", full)
        if node_name is not None:
            _setter("node_name", node_name)
        if retries is not None:
            _setter("retries", retries)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Input[int]:
        """
        The VM identifier.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vm_id", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def full(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "full")

    @full.setter
    def full(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full", value)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the node to assign the virtual machine
        to.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries in Proxmox for clone vm.
        Sometimes Proxmox errors with timeout when creating multiple clones at
        once.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


@pulumi.input_type
class VirtualMachineCpuArgs:
    def __init__(__self__, *,
                 architecture: Optional[pulumi.Input[str]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hotplugged: Optional[pulumi.Input[int]] = None,
                 numa: Optional[pulumi.Input[bool]] = None,
                 sockets: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] architecture: The CPU architecture (defaults to `x86_64`).
        :param pulumi.Input[int] cores: The number of CPU cores (defaults to `1`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: The CPU flags.
               - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
               - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
               vulnerable for Spectre on AMD CPUs.
               - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
               AMD CPUs, best used with "virt-ssbd".
               - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
               virtualization (only supported on Intel CPUs).
               - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
               Windows guests (may lead to guest BSOD on old CPUs).
               - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
               - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
               mitigated correctly.
               - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
               Ivy Bridge Intel CPUs.
               - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
               host HW supports it.
               - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
               Intel CPUs.
               - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
               models.
               - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
               protection for AMD models.
        :param pulumi.Input[int] hotplugged: The number of hotplugged vCPUs (defaults
               to `0`).
        :param pulumi.Input[bool] numa: Enable/disable NUMA. (default to `false`)
        :param pulumi.Input[int] sockets: The number of CPU sockets (defaults to `1`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        :param pulumi.Input[int] units: The CPU units (defaults to `1024`).
        """
        VirtualMachineCpuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architecture=architecture,
            cores=cores,
            flags=flags,
            hotplugged=hotplugged,
            numa=numa,
            sockets=sockets,
            type=type,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architecture: Optional[pulumi.Input[str]] = None,
             cores: Optional[pulumi.Input[int]] = None,
             flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             hotplugged: Optional[pulumi.Input[int]] = None,
             numa: Optional[pulumi.Input[bool]] = None,
             sockets: Optional[pulumi.Input[int]] = None,
             type: Optional[pulumi.Input[str]] = None,
             units: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if architecture is not None:
            _setter("architecture", architecture)
        if cores is not None:
            _setter("cores", cores)
        if flags is not None:
            _setter("flags", flags)
        if hotplugged is not None:
            _setter("hotplugged", hotplugged)
        if numa is not None:
            _setter("numa", numa)
        if sockets is not None:
            _setter("sockets", sockets)
        if type is not None:
            _setter("type", type)
        if units is not None:
            _setter("units", units)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU architecture (defaults to `x86_64`).
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The CPU flags.
        - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
        - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
        vulnerable for Spectre on AMD CPUs.
        - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
        AMD CPUs, best used with "virt-ssbd".
        - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
        virtualization (only supported on Intel CPUs).
        - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
        Windows guests (may lead to guest BSOD on old CPUs).
        - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
        - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
        mitigated correctly.
        - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
        Ivy Bridge Intel CPUs.
        - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
        host HW supports it.
        - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
        Intel CPUs.
        - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
        models.
        - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
        protection for AMD models.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hotplugged vCPUs (defaults
        to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @hotplugged.setter
    def hotplugged(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hotplugged", value)

    @property
    @pulumi.getter
    def numa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable NUMA. (default to `false`)
        """
        return pulumi.get(self, "numa")

    @numa.setter
    def numa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "numa", value)

    @property
    @pulumi.getter
    def sockets(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @sockets.setter
    def sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sockets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[int]]:
        """
        The CPU units (defaults to `1024`).
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class VirtualMachineDiskArgs:
    def __init__(__self__, *,
                 interface: pulumi.Input[str],
                 cache: Optional[pulumi.Input[str]] = None,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 file_format: Optional[pulumi.Input[str]] = None,
                 file_id: Optional[pulumi.Input[str]] = None,
                 iothread: Optional[pulumi.Input[bool]] = None,
                 path_in_datastore: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 speed: Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']] = None,
                 ssd: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] interface: The hardware interface to connect the cloud-init
               image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
               detected if the setting is missing but a cloud-init image is present,
               otherwise defaults to `ide2`.
        :param pulumi.Input[str] cache: The cache type (defaults to `none`).
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] discard: Whether to pass discard/trim requests to the
               underlying storage. Supported values are `on`/`ignore` (defaults
               to `ignore`).
        :param pulumi.Input[str] file_format: The file format.
        :param pulumi.Input[str] file_id: The file ID for a disk image (experimental -
               might cause high CPU utilization during import, especially with large
               disk images).
        :param pulumi.Input[bool] iothread: Whether to use iothreads for this disk (defaults
               to `false`).
        :param pulumi.Input[str] path_in_datastore: The in-datastore path to the disk image.
               ***Experimental.***Use to attach another VM's disks,
               or (as root only) host's filesystem paths (`datastore_id` empty string).
               See "*Example: Attached disks*".
        :param pulumi.Input[int] size: The disk size in gigabytes (defaults to `8`).
        :param pulumi.Input['VirtualMachineDiskSpeedArgs'] speed: The speed limits.
        :param pulumi.Input[bool] ssd: Whether to use an SSD emulation option for this disk (
               defaults to `false`). Note that SSD emulation is not supported on VirtIO
               Block drives.
        """
        VirtualMachineDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interface=interface,
            cache=cache,
            datastore_id=datastore_id,
            discard=discard,
            file_format=file_format,
            file_id=file_id,
            iothread=iothread,
            path_in_datastore=path_in_datastore,
            size=size,
            speed=speed,
            ssd=ssd,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interface: pulumi.Input[str],
             cache: Optional[pulumi.Input[str]] = None,
             datastore_id: Optional[pulumi.Input[str]] = None,
             discard: Optional[pulumi.Input[str]] = None,
             file_format: Optional[pulumi.Input[str]] = None,
             file_id: Optional[pulumi.Input[str]] = None,
             iothread: Optional[pulumi.Input[bool]] = None,
             path_in_datastore: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[int]] = None,
             speed: Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']] = None,
             ssd: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if 'fileFormat' in kwargs:
            file_format = kwargs['fileFormat']
        if 'fileId' in kwargs:
            file_id = kwargs['fileId']
        if 'pathInDatastore' in kwargs:
            path_in_datastore = kwargs['pathInDatastore']

        _setter("interface", interface)
        if cache is not None:
            _setter("cache", cache)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if discard is not None:
            _setter("discard", discard)
        if file_format is not None:
            _setter("file_format", file_format)
        if file_id is not None:
            _setter("file_id", file_id)
        if iothread is not None:
            _setter("iothread", iothread)
        if path_in_datastore is not None:
            _setter("path_in_datastore", path_in_datastore)
        if size is not None:
            _setter("size", size)
        if speed is not None:
            _setter("speed", speed)
        if ssd is not None:
            _setter("ssd", ssd)

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Input[str]:
        """
        The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input[str]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[str]]:
        """
        The cache type (defaults to `none`).
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to pass discard/trim requests to the
        underlying storage. Supported values are `on`/`ignore` (defaults
        to `ignore`).
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The file format.
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The file ID for a disk image (experimental -
        might cause high CPU utilization during import, especially with large
        disk images).
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)

    @property
    @pulumi.getter
    def iothread(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use iothreads for this disk (defaults
        to `false`).
        """
        return pulumi.get(self, "iothread")

    @iothread.setter
    def iothread(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "iothread", value)

    @property
    @pulumi.getter(name="pathInDatastore")
    def path_in_datastore(self) -> Optional[pulumi.Input[str]]:
        """
        The in-datastore path to the disk image.
        ***Experimental.***Use to attach another VM's disks,
        or (as root only) host's filesystem paths (`datastore_id` empty string).
        See "*Example: Attached disks*".
        """
        return pulumi.get(self, "path_in_datastore")

    @path_in_datastore.setter
    def path_in_datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_in_datastore", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The disk size in gigabytes (defaults to `8`).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']]:
        """
        The speed limits.
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter
    def ssd(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use an SSD emulation option for this disk (
        defaults to `false`). Note that SSD emulation is not supported on VirtIO
        Block drives.
        """
        return pulumi.get(self, "ssd")

    @ssd.setter
    def ssd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssd", value)


@pulumi.input_type
class VirtualMachineDiskSpeedArgs:
    def __init__(__self__, *,
                 read: Optional[pulumi.Input[int]] = None,
                 read_burstable: Optional[pulumi.Input[int]] = None,
                 write: Optional[pulumi.Input[int]] = None,
                 write_burstable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] read: The maximum read speed in megabytes per second.
        :param pulumi.Input[int] read_burstable: The maximum burstable read speed in
               megabytes per second.
        :param pulumi.Input[int] write: The maximum write speed in megabytes per second.
        :param pulumi.Input[int] write_burstable: The maximum burstable write speed in
               megabytes per second.
        """
        VirtualMachineDiskSpeedArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
            read_burstable=read_burstable,
            write=write,
            write_burstable=write_burstable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[pulumi.Input[int]] = None,
             read_burstable: Optional[pulumi.Input[int]] = None,
             write: Optional[pulumi.Input[int]] = None,
             write_burstable: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'readBurstable' in kwargs:
            read_burstable = kwargs['readBurstable']
        if 'writeBurstable' in kwargs:
            write_burstable = kwargs['writeBurstable']

        if read is not None:
            _setter("read", read)
        if read_burstable is not None:
            _setter("read_burstable", read_burstable)
        if write is not None:
            _setter("write", write)
        if write_burstable is not None:
            _setter("write_burstable", write_burstable)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum read speed in megabytes per second.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter(name="readBurstable")
    def read_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum burstable read speed in
        megabytes per second.
        """
        return pulumi.get(self, "read_burstable")

    @read_burstable.setter
    def read_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_burstable", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum write speed in megabytes per second.
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "write", value)

    @property
    @pulumi.getter(name="writeBurstable")
    def write_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum burstable write speed in
        megabytes per second.
        """
        return pulumi.get(self, "write_burstable")

    @write_burstable.setter
    def write_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "write_burstable", value)


@pulumi.input_type
class VirtualMachineEfiDiskArgs:
    def __init__(__self__, *,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 file_format: Optional[pulumi.Input[str]] = None,
                 pre_enrolled_keys: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] file_format: The file format.
        :param pulumi.Input[bool] pre_enrolled_keys: Use am EFI vars template with
               distribution-specific and Microsoft Standard keys enrolled, if used with
               EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
               to `false`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        VirtualMachineEfiDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore_id=datastore_id,
            file_format=file_format,
            pre_enrolled_keys=pre_enrolled_keys,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore_id: Optional[pulumi.Input[str]] = None,
             file_format: Optional[pulumi.Input[str]] = None,
             pre_enrolled_keys: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if 'fileFormat' in kwargs:
            file_format = kwargs['fileFormat']
        if 'preEnrolledKeys' in kwargs:
            pre_enrolled_keys = kwargs['preEnrolledKeys']

        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if file_format is not None:
            _setter("file_format", file_format)
        if pre_enrolled_keys is not None:
            _setter("pre_enrolled_keys", pre_enrolled_keys)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The file format.
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="preEnrolledKeys")
    def pre_enrolled_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        Use am EFI vars template with
        distribution-specific and Microsoft Standard keys enrolled, if used with
        EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `false`).
        """
        return pulumi.get(self, "pre_enrolled_keys")

    @pre_enrolled_keys.setter
    def pre_enrolled_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pre_enrolled_keys", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineHostpciArgs:
    def __init__(__self__, *,
                 device: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 mapping: Optional[pulumi.Input[str]] = None,
                 mdev: Optional[pulumi.Input[str]] = None,
                 pcie: Optional[pulumi.Input[bool]] = None,
                 rom_file: Optional[pulumi.Input[str]] = None,
                 rombar: Optional[pulumi.Input[bool]] = None,
                 xvga: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] device: The device (defaults to `socket`).
               - `/dev/*` - A host serial device.
        :param pulumi.Input[str] id: The PCI device ID. Use either this or `mapping`.
        :param pulumi.Input[str] mapping: The resource mapping name of the device, for
               example gpu. Use either this or `id`.
        :param pulumi.Input[str] mdev: The mediated device ID to use.
        :param pulumi.Input[bool] pcie: Tells Proxmox to use a PCIe or PCI port. Some
               guests/device combination require PCIe rather than PCI. PCIe is only
               available for q35 machine types.
        :param pulumi.Input[str] rom_file: A path to a ROM file for the device to use. This
               is a relative path under `/usr/share/kvm/`.
        :param pulumi.Input[bool] rombar: Makes the firmware ROM visible for the VM (defaults
               to `true`).
        :param pulumi.Input[bool] xvga: Marks the PCI(e) device as the primary GPU of the VM.
               With this enabled the `vga` configuration argument will be ignored.
        """
        VirtualMachineHostpciArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
            id=id,
            mapping=mapping,
            mdev=mdev,
            pcie=pcie,
            rom_file=rom_file,
            rombar=rombar,
            xvga=xvga,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             mapping: Optional[pulumi.Input[str]] = None,
             mdev: Optional[pulumi.Input[str]] = None,
             pcie: Optional[pulumi.Input[bool]] = None,
             rom_file: Optional[pulumi.Input[str]] = None,
             rombar: Optional[pulumi.Input[bool]] = None,
             xvga: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'romFile' in kwargs:
            rom_file = kwargs['romFile']

        _setter("device", device)
        if id is not None:
            _setter("id", id)
        if mapping is not None:
            _setter("mapping", mapping)
        if mdev is not None:
            _setter("mdev", mdev)
        if pcie is not None:
            _setter("pcie", pcie)
        if rom_file is not None:
            _setter("rom_file", rom_file)
        if rombar is not None:
            _setter("rombar", rombar)
        if xvga is not None:
            _setter("xvga", xvga)

    @property
    @pulumi.getter
    def device(self) -> pulumi.Input[str]:
        """
        The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: pulumi.Input[str]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The PCI device ID. Use either this or `mapping`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def mapping(self) -> Optional[pulumi.Input[str]]:
        """
        The resource mapping name of the device, for
        example gpu. Use either this or `id`.
        """
        return pulumi.get(self, "mapping")

    @mapping.setter
    def mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mapping", value)

    @property
    @pulumi.getter
    def mdev(self) -> Optional[pulumi.Input[str]]:
        """
        The mediated device ID to use.
        """
        return pulumi.get(self, "mdev")

    @mdev.setter
    def mdev(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdev", value)

    @property
    @pulumi.getter
    def pcie(self) -> Optional[pulumi.Input[bool]]:
        """
        Tells Proxmox to use a PCIe or PCI port. Some
        guests/device combination require PCIe rather than PCI. PCIe is only
        available for q35 machine types.
        """
        return pulumi.get(self, "pcie")

    @pcie.setter
    def pcie(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pcie", value)

    @property
    @pulumi.getter(name="romFile")
    def rom_file(self) -> Optional[pulumi.Input[str]]:
        """
        A path to a ROM file for the device to use. This
        is a relative path under `/usr/share/kvm/`.
        """
        return pulumi.get(self, "rom_file")

    @rom_file.setter
    def rom_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rom_file", value)

    @property
    @pulumi.getter
    def rombar(self) -> Optional[pulumi.Input[bool]]:
        """
        Makes the firmware ROM visible for the VM (defaults
        to `true`).
        """
        return pulumi.get(self, "rombar")

    @rombar.setter
    def rombar(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rombar", value)

    @property
    @pulumi.getter
    def xvga(self) -> Optional[pulumi.Input[bool]]:
        """
        Marks the PCI(e) device as the primary GPU of the VM.
        With this enabled the `vga` configuration argument will be ignored.
        """
        return pulumi.get(self, "xvga")

    @xvga.setter
    def xvga(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "xvga", value)


@pulumi.input_type
class VirtualMachineInitializationArgs:
    def __init__(__self__, *,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 dns: Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 ip_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]] = None,
                 meta_data_file_id: Optional[pulumi.Input[str]] = None,
                 network_data_file_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_account: Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']] = None,
                 user_data_file_id: Optional[pulumi.Input[str]] = None,
                 vendor_data_file_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param pulumi.Input['VirtualMachineInitializationDnsArgs'] dns: The DNS configuration.
        :param pulumi.Input[str] interface: The hardware interface to connect the cloud-init
               image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
               detected if the setting is missing but a cloud-init image is present,
               otherwise defaults to `ide2`.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]] ip_configs: The IP configuration (one block per network
               device).
        :param pulumi.Input[str] meta_data_file_id: The identifier for a file containing
               all meta data passed to the VM via cloud-init.
        :param pulumi.Input[str] network_data_file_id: The identifier for a file containing
               network configuration data passed to the VM via cloud-init (conflicts
               with `ip_config`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        :param pulumi.Input['VirtualMachineInitializationUserAccountArgs'] user_account: The user account configuration (conflicts
               with `user_data_file_id`).
        :param pulumi.Input[str] user_data_file_id: The identifier for a file containing
               custom user data (conflicts with `user_account`).
        :param pulumi.Input[str] vendor_data_file_id: The identifier for a file containing
               all vendor data passed to the VM via cloud-init.
        """
        VirtualMachineInitializationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore_id=datastore_id,
            dns=dns,
            interface=interface,
            ip_configs=ip_configs,
            meta_data_file_id=meta_data_file_id,
            network_data_file_id=network_data_file_id,
            type=type,
            user_account=user_account,
            user_data_file_id=user_data_file_id,
            vendor_data_file_id=vendor_data_file_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore_id: Optional[pulumi.Input[str]] = None,
             dns: Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']] = None,
             interface: Optional[pulumi.Input[str]] = None,
             ip_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]] = None,
             meta_data_file_id: Optional[pulumi.Input[str]] = None,
             network_data_file_id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             user_account: Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']] = None,
             user_data_file_id: Optional[pulumi.Input[str]] = None,
             vendor_data_file_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'datastoreId' in kwargs:
            datastore_id = kwargs['datastoreId']
        if 'ipConfigs' in kwargs:
            ip_configs = kwargs['ipConfigs']
        if 'metaDataFileId' in kwargs:
            meta_data_file_id = kwargs['metaDataFileId']
        if 'networkDataFileId' in kwargs:
            network_data_file_id = kwargs['networkDataFileId']
        if 'userAccount' in kwargs:
            user_account = kwargs['userAccount']
        if 'userDataFileId' in kwargs:
            user_data_file_id = kwargs['userDataFileId']
        if 'vendorDataFileId' in kwargs:
            vendor_data_file_id = kwargs['vendorDataFileId']

        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if dns is not None:
            _setter("dns", dns)
        if interface is not None:
            _setter("interface", interface)
        if ip_configs is not None:
            _setter("ip_configs", ip_configs)
        if meta_data_file_id is not None:
            _setter("meta_data_file_id", meta_data_file_id)
        if network_data_file_id is not None:
            _setter("network_data_file_id", network_data_file_id)
        if type is not None:
            _setter("type", type)
        if user_account is not None:
            _setter("user_account", user_account)
        if user_data_file_id is not None:
            _setter("user_data_file_id", user_data_file_id)
        if vendor_data_file_id is not None:
            _setter("vendor_data_file_id", vendor_data_file_id)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']]:
        """
        The DNS configuration.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter(name="ipConfigs")
    def ip_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]]:
        """
        The IP configuration (one block per network
        device).
        """
        return pulumi.get(self, "ip_configs")

    @ip_configs.setter
    def ip_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]]):
        pulumi.set(self, "ip_configs", value)

    @property
    @pulumi.getter(name="metaDataFileId")
    def meta_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        all meta data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "meta_data_file_id")

    @meta_data_file_id.setter
    def meta_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "meta_data_file_id", value)

    @property
    @pulumi.getter(name="networkDataFileId")
    def network_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        network configuration data passed to the VM via cloud-init (conflicts
        with `ip_config`).
        """
        return pulumi.get(self, "network_data_file_id")

    @network_data_file_id.setter
    def network_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_data_file_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']]:
        """
        The user account configuration (conflicts
        with `user_data_file_id`).
        """
        return pulumi.get(self, "user_account")

    @user_account.setter
    def user_account(self, value: Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']]):
        pulumi.set(self, "user_account", value)

    @property
    @pulumi.getter(name="userDataFileId")
    def user_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        custom user data (conflicts with `user_account`).
        """
        return pulumi.get(self, "user_data_file_id")

    @user_data_file_id.setter
    def user_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data_file_id", value)

    @property
    @pulumi.getter(name="vendorDataFileId")
    def vendor_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        all vendor data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "vendor_data_file_id")

    @vendor_data_file_id.setter
    def vendor_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor_data_file_id", value)


@pulumi.input_type
class VirtualMachineInitializationDnsArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: The DNS search domain.
        :param pulumi.Input[str] server: The DNS server.
        """
        VirtualMachineInitializationDnsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            server=server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[pulumi.Input[str]] = None,
             server: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if domain is not None:
            _setter("domain", domain)
        if server is not None:
            _setter("server", server)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS search domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS server.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']] = None):
        """
        :param pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args'] ipv4: The IPv4 configuration.
        :param pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args'] ipv6: The IPv4 configuration.
        """
        VirtualMachineInitializationIpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv4=ipv4,
            ipv6=ipv6,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv4: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']] = None,
             ipv6: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if ipv4 is not None:
            _setter("ipv4", ipv4)
        if ipv6 is not None:
            _setter("ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']]:
        """
        The IPv4 configuration.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']]:
        """
        The IPv4 configuration.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']]):
        pulumi.set(self, "ipv6", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The IPv6 address (use `dhcp` for
               autodiscovery).
        :param pulumi.Input[str] gateway: The IPv6 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        VirtualMachineInitializationIpConfigIpv4Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            gateway=gateway,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             gateway: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if gateway is not None:
            _setter("gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 address (use `dhcp` for
        autodiscovery).
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The IPv6 address (use `dhcp` for
               autodiscovery).
        :param pulumi.Input[str] gateway: The IPv6 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        VirtualMachineInitializationIpConfigIpv6Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            gateway=gateway,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             gateway: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if gateway is not None:
            _setter("gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 address (use `dhcp` for
        autodiscovery).
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)


@pulumi.input_type
class VirtualMachineInitializationUserAccountArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: The SSH keys.
        :param pulumi.Input[str] password: The SSH password.
        :param pulumi.Input[str] username: The SSH username.
        """
        VirtualMachineInitializationUserAccountArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keys=keys,
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if keys is not None:
            _setter("keys", keys)
        if password is not None:
            _setter("password", password)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The SSH keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class VirtualMachineMemoryArgs:
    def __init__(__self__, *,
                 dedicated: Optional[pulumi.Input[int]] = None,
                 floating: Optional[pulumi.Input[int]] = None,
                 shared: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] dedicated: The dedicated memory in megabytes (defaults
               to `512`).
        :param pulumi.Input[int] floating: The floating memory in megabytes (defaults
               to `0`).
        :param pulumi.Input[int] shared: The shared memory in megabytes (defaults to `0`).
        """
        VirtualMachineMemoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated=dedicated,
            floating=floating,
            shared=shared,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated: Optional[pulumi.Input[int]] = None,
             floating: Optional[pulumi.Input[int]] = None,
             shared: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dedicated is not None:
            _setter("dedicated", dedicated)
        if floating is not None:
            _setter("floating", floating)
        if shared is not None:
            _setter("shared", shared)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[int]]:
        """
        The dedicated memory in megabytes (defaults
        to `512`).
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dedicated", value)

    @property
    @pulumi.getter
    def floating(self) -> Optional[pulumi.Input[int]]:
        """
        The floating memory in megabytes (defaults
        to `0`).
        """
        return pulumi.get(self, "floating")

    @floating.setter
    def floating(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "floating", value)

    @property
    @pulumi.getter
    def shared(self) -> Optional[pulumi.Input[int]]:
        """
        The shared memory in megabytes (defaults to `0`).
        """
        return pulumi.get(self, "shared")

    @shared.setter
    def shared(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shared", value)


@pulumi.input_type
class VirtualMachineNetworkDeviceArgs:
    def __init__(__self__, *,
                 bridge: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 firewall: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 queues: Optional[pulumi.Input[int]] = None,
                 rate_limit: Optional[pulumi.Input[float]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bridge: The name of the network bridge (defaults
               to `vmbr0`).
        :param pulumi.Input[bool] enabled: Whether to enable the VGA device (defaults
               to `true`).
        :param pulumi.Input[bool] firewall: Whether this interface's firewall rules should be
               used (defaults to `false`).
        :param pulumi.Input[str] mac_address: The MAC address.
        :param pulumi.Input[str] model: The network device model (defaults to `virtio`).
        :param pulumi.Input[int] mtu: Force MTU, for VirtIO only. Set to 1 to use the bridge
               MTU. Cannot be larger than the bridge MTU.
        :param pulumi.Input[int] queues: The number of queues for VirtIO (1..64).
        :param pulumi.Input[float] rate_limit: The rate limit in megabytes per second.
        :param pulumi.Input[int] vlan_id: The VLAN identifier.
        """
        VirtualMachineNetworkDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bridge=bridge,
            enabled=enabled,
            firewall=firewall,
            mac_address=mac_address,
            model=model,
            mtu=mtu,
            queues=queues,
            rate_limit=rate_limit,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bridge: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             firewall: Optional[pulumi.Input[bool]] = None,
             mac_address: Optional[pulumi.Input[str]] = None,
             model: Optional[pulumi.Input[str]] = None,
             mtu: Optional[pulumi.Input[int]] = None,
             queues: Optional[pulumi.Input[int]] = None,
             rate_limit: Optional[pulumi.Input[float]] = None,
             vlan_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']
        if 'rateLimit' in kwargs:
            rate_limit = kwargs['rateLimit']
        if 'vlanId' in kwargs:
            vlan_id = kwargs['vlanId']

        if bridge is not None:
            _setter("bridge", bridge)
        if enabled is not None:
            _setter("enabled", enabled)
        if firewall is not None:
            _setter("firewall", firewall)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if model is not None:
            _setter("model", model)
        if mtu is not None:
            _setter("mtu", mtu)
        if queues is not None:
            _setter("queues", queues)
        if rate_limit is not None:
            _setter("rate_limit", rate_limit)
        if vlan_id is not None:
            _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter
    def bridge(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the network bridge (defaults
        to `vmbr0`).
        """
        return pulumi.get(self, "bridge")

    @bridge.setter
    def bridge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the VGA device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def firewall(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this interface's firewall rules should be
        used (defaults to `false`).
        """
        return pulumi.get(self, "firewall")

    @firewall.setter
    def firewall(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The MAC address.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        The network device model (defaults to `virtio`).
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Force MTU, for VirtIO only. Set to 1 to use the bridge
        MTU. Cannot be larger than the bridge MTU.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def queues(self) -> Optional[pulumi.Input[int]]:
        """
        The number of queues for VirtIO (1..64).
        """
        return pulumi.get(self, "queues")

    @queues.setter
    def queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queues", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The rate limit in megabytes per second.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        The VLAN identifier.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class VirtualMachineOperatingSystemArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        VirtualMachineOperatingSystemArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineSerialDeviceArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device: The device (defaults to `socket`).
               - `/dev/*` - A host serial device.
        """
        VirtualMachineSerialDeviceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device=device,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if device is not None:
            _setter("device", device)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)


@pulumi.input_type
class VirtualMachineSmbiosArgs:
    def __init__(__self__, *,
                 family: Optional[pulumi.Input[str]] = None,
                 manufacturer: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 serial: Optional[pulumi.Input[str]] = None,
                 sku: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] family: The family string.
        :param pulumi.Input[str] manufacturer: The manufacturer.
        :param pulumi.Input[str] product: The product ID.
        :param pulumi.Input[str] serial: The serial number.
        :param pulumi.Input[str] sku: The SKU number.
        :param pulumi.Input[str] uuid: The UUID (defaults to randomly generated UUID).
        :param pulumi.Input[str] version: The version.
        """
        VirtualMachineSmbiosArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            family=family,
            manufacturer=manufacturer,
            product=product,
            serial=serial,
            sku=sku,
            uuid=uuid,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             family: Optional[pulumi.Input[str]] = None,
             manufacturer: Optional[pulumi.Input[str]] = None,
             product: Optional[pulumi.Input[str]] = None,
             serial: Optional[pulumi.Input[str]] = None,
             sku: Optional[pulumi.Input[str]] = None,
             uuid: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if family is not None:
            _setter("family", family)
        if manufacturer is not None:
            _setter("manufacturer", manufacturer)
        if product is not None:
            _setter("product", product)
        if serial is not None:
            _setter("serial", serial)
        if sku is not None:
            _setter("sku", sku)
        if uuid is not None:
            _setter("uuid", uuid)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The family string.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[pulumi.Input[str]]:
        """
        The manufacturer.
        """
        return pulumi.get(self, "manufacturer")

    @manufacturer.setter
    def manufacturer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manufacturer", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        The product ID.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[str]]:
        """
        The serial number.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU number.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID (defaults to randomly generated UUID).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class VirtualMachineStartupArgs:
    def __init__(__self__, *,
                 down_delay: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 up_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] order: A non-negative number defining the general startup
               order.
        """
        VirtualMachineStartupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            down_delay=down_delay,
            order=order,
            up_delay=up_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             down_delay: Optional[pulumi.Input[int]] = None,
             order: Optional[pulumi.Input[int]] = None,
             up_delay: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'downDelay' in kwargs:
            down_delay = kwargs['downDelay']
        if 'upDelay' in kwargs:
            up_delay = kwargs['upDelay']

        if down_delay is not None:
            _setter("down_delay", down_delay)
        if order is not None:
            _setter("order", order)
        if up_delay is not None:
            _setter("up_delay", up_delay)

    @property
    @pulumi.getter(name="downDelay")
    def down_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "down_delay")

    @down_delay.setter
    def down_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "down_delay", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        A non-negative number defining the general startup
        order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="upDelay")
    def up_delay(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "up_delay")

    @up_delay.setter
    def up_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "up_delay", value)


@pulumi.input_type
class VirtualMachineVgaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable the VGA device (defaults
               to `true`).
        :param pulumi.Input[int] memory: The VGA memory in megabytes (defaults to `16`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        VirtualMachineVgaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            memory=memory,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             memory: Optional[pulumi.Input[int]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if memory is not None:
            _setter("memory", memory)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the VGA device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The VGA memory in megabytes (defaults to `16`).
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


