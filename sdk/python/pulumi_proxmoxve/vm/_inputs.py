# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'VirtualMachine2CdromArgs',
    'VirtualMachine2CloneArgs',
    'VirtualMachine2CpuArgs',
    'VirtualMachine2TimeoutsArgs',
    'VirtualMachine2VgaArgs',
    'VirtualMachineAgentArgs',
    'VirtualMachineAudioDeviceArgs',
    'VirtualMachineCdromArgs',
    'VirtualMachineCloneArgs',
    'VirtualMachineCpuArgs',
    'VirtualMachineDiskArgs',
    'VirtualMachineDiskSpeedArgs',
    'VirtualMachineEfiDiskArgs',
    'VirtualMachineHostpciArgs',
    'VirtualMachineInitializationArgs',
    'VirtualMachineInitializationDnsArgs',
    'VirtualMachineInitializationIpConfigArgs',
    'VirtualMachineInitializationIpConfigIpv4Args',
    'VirtualMachineInitializationIpConfigIpv6Args',
    'VirtualMachineInitializationUserAccountArgs',
    'VirtualMachineMemoryArgs',
    'VirtualMachineNetworkDeviceArgs',
    'VirtualMachineNumaArgs',
    'VirtualMachineOperatingSystemArgs',
    'VirtualMachineSerialDeviceArgs',
    'VirtualMachineSmbiosArgs',
    'VirtualMachineStartupArgs',
    'VirtualMachineTpmStateArgs',
    'VirtualMachineUsbArgs',
    'VirtualMachineVgaArgs',
    'GetVirtualMachinesFilterArgs',
]

@pulumi.input_type
class VirtualMachine2CdromArgs:
    def __init__(__self__, *,
                 file_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_id: The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)


@pulumi.input_type
class VirtualMachine2CloneArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[int],
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the VM to clone.
        :param pulumi.Input[int] retries: The number of retries to perform when cloning the VM (default: 3).
        """
        pulumi.set(__self__, "id", id)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[int]:
        """
        The ID of the VM to clone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


@pulumi.input_type
class VirtualMachine2CpuArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[str]] = None,
                 architecture: Optional[pulumi.Input[str]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hotplugged: Optional[pulumi.Input[int]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 numa: Optional[pulumi.Input[bool]] = None,
                 sockets: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] affinity: The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param pulumi.Input[str] architecture: The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param pulumi.Input[int] cores: The number of CPU cores per socket (defaults to `1`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        :param pulumi.Input[int] hotplugged: The number of hotplugged vCPUs (defaults to `0`).
        :param pulumi.Input[int] limit: Limit of CPU usage (defaults to `0` which means no limit).
        :param pulumi.Input[bool] numa: Enable NUMA (defaults to `false`).
        :param pulumi.Input[int] sockets: The number of CPU sockets (defaults to `1`).
        :param pulumi.Input[str] type: Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        :param pulumi.Input[int] units: CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if hotplugged is not None:
            pulumi.set(__self__, "hotplugged", hotplugged)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores per socket (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hotplugged vCPUs (defaults to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @hotplugged.setter
    def hotplugged(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hotplugged", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Limit of CPU usage (defaults to `0` which means no limit).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def numa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable NUMA (defaults to `false`).
        """
        return pulumi.get(self, "numa")

    @numa.setter
    def numa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "numa", value)

    @property
    @pulumi.getter
    def sockets(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @sockets.setter
    def sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sockets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[int]]:
        """
        CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class VirtualMachine2TimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 read: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


@pulumi.input_type
class VirtualMachine2VgaArgs:
    def __init__(__self__, *,
                 clipboard: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] clipboard: Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        :param pulumi.Input[int] memory: The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        if clipboard is not None:
            pulumi.set(__self__, "clipboard", clipboard)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> Optional[pulumi.Input[str]]:
        """
        Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        """
        return pulumi.get(self, "clipboard")

    @clipboard.setter
    def clipboard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clipboard", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineAgentArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[str]] = None,
                 trim: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable the QEMU agent (defaults
               to `false`).
        :param pulumi.Input[str] timeout: The maximum amount of time to wait for data from
               the QEMU agent to become available ( defaults to `15m`).
        :param pulumi.Input[bool] trim: Whether to enable the FSTRIM feature in the QEMU agent
               (defaults to `false`).
        :param pulumi.Input[str] type: The QEMU agent interface type (defaults to `virtio`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if trim is not None:
            pulumi.set(__self__, "trim", trim)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the QEMU agent (defaults
        to `false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum amount of time to wait for data from
        the QEMU agent to become available ( defaults to `15m`).
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def trim(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the FSTRIM feature in the QEMU agent
        (defaults to `false`).
        """
        return pulumi.get(self, "trim")

    @trim.setter
    def trim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trim", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The QEMU agent interface type (defaults to `virtio`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineAudioDeviceArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[str]] = None,
                 driver: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] device: The device (defaults to `intel-hda`).
               - `AC97` - Intel 82801AA AC97 Audio.
               - `ich9-intel-hda` - Intel HD Audio Controller (ich9).
               - `intel-hda` - Intel HD Audio.
        :param pulumi.Input[str] driver: The driver (defaults to `spice`).
        :param pulumi.Input[bool] enabled: Whether to enable the audio device (defaults
               to `true`).
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device (defaults to `intel-hda`).
        - `AC97` - Intel 82801AA AC97 Audio.
        - `ich9-intel-hda` - Intel HD Audio Controller (ich9).
        - `intel-hda` - Intel HD Audio.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def driver(self) -> Optional[pulumi.Input[str]]:
        """
        The driver (defaults to `spice`).
        """
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the audio device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VirtualMachineCdromArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 file_id: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable the CDROM drive (defaults
               to `false`).
        :param pulumi.Input[str] file_id: A file ID for an ISO file (defaults to `cdrom` as
               in the physical drive). Use `none` to leave the CDROM drive empty.
        :param pulumi.Input[str] interface: A hardware interface to connect CDROM drive to,
               must be `ideN` (defaults to `ide3`). Note that `q35` machine type only
               supports `ide0` and `ide2`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the CDROM drive (defaults
        to `false`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        A file ID for an ISO file (defaults to `cdrom` as
        in the physical drive). Use `none` to leave the CDROM drive empty.
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        A hardware interface to connect CDROM drive to,
        must be `ideN` (defaults to `ide3`). Note that `q35` machine type only
        supports `ide0` and `ide2`.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)


@pulumi.input_type
class VirtualMachineCloneArgs:
    def __init__(__self__, *,
                 vm_id: pulumi.Input[int],
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 full: Optional[pulumi.Input[bool]] = None,
                 node_name: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] vm_id: The identifier for the source VM.
        :param pulumi.Input[str] datastore_id: The identifier for the target datastore.
        :param pulumi.Input[bool] full: Full or linked clone (defaults to `true`).
        :param pulumi.Input[str] node_name: The name of the source node (leave blank, if
               equal to the `node_name` argument).
        :param pulumi.Input[int] retries: Number of retries in Proxmox for clone vm.
               Sometimes Proxmox errors with timeout when creating multiple clones at
               once.
        """
        pulumi.set(__self__, "vm_id", vm_id)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if full is not None:
            pulumi.set(__self__, "full", full)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Input[int]:
        """
        The identifier for the source VM.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vm_id", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the target datastore.
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def full(self) -> Optional[pulumi.Input[bool]]:
        """
        Full or linked clone (defaults to `true`).
        """
        return pulumi.get(self, "full")

    @full.setter
    def full(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full", value)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source node (leave blank, if
        equal to the `node_name` argument).
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries in Proxmox for clone vm.
        Sometimes Proxmox errors with timeout when creating multiple clones at
        once.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


@pulumi.input_type
class VirtualMachineCpuArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[str]] = None,
                 architecture: Optional[pulumi.Input[str]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hotplugged: Optional[pulumi.Input[int]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 numa: Optional[pulumi.Input[bool]] = None,
                 sockets: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] affinity: The CPU cores that are used to run the VM’s vCPU. The
               value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.
               For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four
               CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param pulumi.Input[str] architecture: The CPU architecture (defaults to `x86_64`).
        :param pulumi.Input[int] cores: The number of CPU cores (defaults to `1`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: The CPU flags.
               - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
               - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
               vulnerable for Spectre on AMD CPUs.
               - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
               AMD CPUs, best used with "virt-ssbd".
               - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
               virtualization (only supported on Intel CPUs).
               - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
               Windows guests (may lead to guest BSOD on old CPUs).
               - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
               - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
               mitigated correctly.
               - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
               Ivy Bridge Intel CPUs.
               - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
               host HW supports it.
               - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
               Intel CPUs.
               - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
               models.
               - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
               protection for AMD models.
        :param pulumi.Input[int] hotplugged: The number of hotplugged vCPUs (defaults
               to `0`).
        :param pulumi.Input[int] limit: Limit of CPU usage, `0...128`. (defaults to `0` -- no limit).
        :param pulumi.Input[bool] numa: Enable/disable NUMA. (default to `false`)
        :param pulumi.Input[int] sockets: The number of CPU sockets (defaults to `1`).
        :param pulumi.Input[str] type: The emulated CPU type, it's recommended to
               use `x86-64-v2-AES` (defaults to `qemu64`).
        :param pulumi.Input[int] units: The CPU units (defaults to `1024`).
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if hotplugged is not None:
            pulumi.set(__self__, "hotplugged", hotplugged)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU cores that are used to run the VM’s vCPU. The
        value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.
        For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four
        CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU architecture (defaults to `x86_64`).
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The CPU flags.
        - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
        - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
        vulnerable for Spectre on AMD CPUs.
        - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
        AMD CPUs, best used with "virt-ssbd".
        - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
        virtualization (only supported on Intel CPUs).
        - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
        Windows guests (may lead to guest BSOD on old CPUs).
        - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
        - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
        mitigated correctly.
        - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
        Ivy Bridge Intel CPUs.
        - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
        host HW supports it.
        - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
        Intel CPUs.
        - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
        models.
        - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
        protection for AMD models.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hotplugged vCPUs (defaults
        to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @hotplugged.setter
    def hotplugged(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hotplugged", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Limit of CPU usage, `0...128`. (defaults to `0` -- no limit).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def numa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable NUMA. (default to `false`)
        """
        return pulumi.get(self, "numa")

    @numa.setter
    def numa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "numa", value)

    @property
    @pulumi.getter
    def sockets(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @sockets.setter
    def sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sockets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The emulated CPU type, it's recommended to
        use `x86-64-v2-AES` (defaults to `qemu64`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[int]]:
        """
        The CPU units (defaults to `1024`).
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class VirtualMachineDiskArgs:
    def __init__(__self__, *,
                 interface: pulumi.Input[str],
                 aio: Optional[pulumi.Input[str]] = None,
                 backup: Optional[pulumi.Input[bool]] = None,
                 cache: Optional[pulumi.Input[str]] = None,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 file_format: Optional[pulumi.Input[str]] = None,
                 file_id: Optional[pulumi.Input[str]] = None,
                 iothread: Optional[pulumi.Input[bool]] = None,
                 path_in_datastore: Optional[pulumi.Input[str]] = None,
                 replicate: Optional[pulumi.Input[bool]] = None,
                 serial: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 speed: Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']] = None,
                 ssd: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] interface: The disk interface for Proxmox, currently `scsi`,
               `sata` and `virtio` interfaces are supported. Append the disk index at
               the end, for example, `virtio0` for the first virtio disk, `virtio1` for
               the second, etc.
        :param pulumi.Input[str] aio: The disk AIO mode (defaults to `io_uring`).
        :param pulumi.Input[bool] backup: Whether the drive should be included when making backups (defaults to `true`).
        :param pulumi.Input[str] cache: The cache type (defaults to `none`).
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] discard: Whether to pass discard/trim requests to the
               underlying storage. Supported values are `on`/`ignore` (defaults
               to `ignore`).
        :param pulumi.Input[str] file_format: The file format (defaults to `qcow2`).
        :param pulumi.Input[str] file_id: The file ID for a disk image. The ID format is
               `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/centos8.img`. Can be also taken from
               `Download.File` resource.
        :param pulumi.Input[bool] iothread: Whether to use iothreads for this disk (defaults
               to `false`).
        :param pulumi.Input[str] path_in_datastore: The in-datastore path to the disk image.
               ***Experimental.***Use to attach another VM's disks,
               or (as root only) host's filesystem paths (`datastore_id` empty string).
               See "*Example: Attached disks*".
        :param pulumi.Input[bool] replicate: Whether the drive should be considered for replication jobs (defaults to `true`).
        :param pulumi.Input[str] serial: The serial number of the disk, up to 20 bytes long.
        :param pulumi.Input[int] size: The disk size in gigabytes (defaults to `8`).
        :param pulumi.Input['VirtualMachineDiskSpeedArgs'] speed: The speed limits.
        :param pulumi.Input[bool] ssd: Whether to use an SSD emulation option for this disk (
               defaults to `false`). Note that SSD emulation is not supported on VirtIO
               Block drives.
        """
        pulumi.set(__self__, "interface", interface)
        if aio is not None:
            pulumi.set(__self__, "aio", aio)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)
        if iothread is not None:
            pulumi.set(__self__, "iothread", iothread)
        if path_in_datastore is not None:
            pulumi.set(__self__, "path_in_datastore", path_in_datastore)
        if replicate is not None:
            pulumi.set(__self__, "replicate", replicate)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssd is not None:
            pulumi.set(__self__, "ssd", ssd)

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Input[str]:
        """
        The disk interface for Proxmox, currently `scsi`,
        `sata` and `virtio` interfaces are supported. Append the disk index at
        the end, for example, `virtio0` for the first virtio disk, `virtio1` for
        the second, etc.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input[str]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def aio(self) -> Optional[pulumi.Input[str]]:
        """
        The disk AIO mode (defaults to `io_uring`).
        """
        return pulumi.get(self, "aio")

    @aio.setter
    def aio(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aio", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the drive should be included when making backups (defaults to `true`).
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[str]]:
        """
        The cache type (defaults to `none`).
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to pass discard/trim requests to the
        underlying storage. Supported values are `on`/`ignore` (defaults
        to `ignore`).
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The file format (defaults to `qcow2`).
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The file ID for a disk image. The ID format is
        `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/centos8.img`. Can be also taken from
        `Download.File` resource.
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)

    @property
    @pulumi.getter
    def iothread(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use iothreads for this disk (defaults
        to `false`).
        """
        return pulumi.get(self, "iothread")

    @iothread.setter
    def iothread(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "iothread", value)

    @property
    @pulumi.getter(name="pathInDatastore")
    def path_in_datastore(self) -> Optional[pulumi.Input[str]]:
        """
        The in-datastore path to the disk image.
        ***Experimental.***Use to attach another VM's disks,
        or (as root only) host's filesystem paths (`datastore_id` empty string).
        See "*Example: Attached disks*".
        """
        return pulumi.get(self, "path_in_datastore")

    @path_in_datastore.setter
    def path_in_datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_in_datastore", value)

    @property
    @pulumi.getter
    def replicate(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the drive should be considered for replication jobs (defaults to `true`).
        """
        return pulumi.get(self, "replicate")

    @replicate.setter
    def replicate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replicate", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[str]]:
        """
        The serial number of the disk, up to 20 bytes long.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The disk size in gigabytes (defaults to `8`).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def speed(self) -> Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']]:
        """
        The speed limits.
        """
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: Optional[pulumi.Input['VirtualMachineDiskSpeedArgs']]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter
    def ssd(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use an SSD emulation option for this disk (
        defaults to `false`). Note that SSD emulation is not supported on VirtIO
        Block drives.
        """
        return pulumi.get(self, "ssd")

    @ssd.setter
    def ssd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssd", value)


@pulumi.input_type
class VirtualMachineDiskSpeedArgs:
    def __init__(__self__, *,
                 iops_read: Optional[pulumi.Input[int]] = None,
                 iops_read_burstable: Optional[pulumi.Input[int]] = None,
                 iops_write: Optional[pulumi.Input[int]] = None,
                 iops_write_burstable: Optional[pulumi.Input[int]] = None,
                 read: Optional[pulumi.Input[int]] = None,
                 read_burstable: Optional[pulumi.Input[int]] = None,
                 write: Optional[pulumi.Input[int]] = None,
                 write_burstable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] iops_read: The maximum read I/O in operations per second.
        :param pulumi.Input[int] iops_read_burstable: The maximum unthrottled read I/O pool in operations per second.
        :param pulumi.Input[int] iops_write: The maximum write I/O in operations per second.
        :param pulumi.Input[int] iops_write_burstable: The maximum unthrottled write I/O pool in operations per second.
        :param pulumi.Input[int] read: The maximum read speed in megabytes per second.
        :param pulumi.Input[int] read_burstable: The maximum burstable read speed in
               megabytes per second.
        :param pulumi.Input[int] write: The maximum write speed in megabytes per second.
        :param pulumi.Input[int] write_burstable: The maximum burstable write speed in
               megabytes per second.
        """
        if iops_read is not None:
            pulumi.set(__self__, "iops_read", iops_read)
        if iops_read_burstable is not None:
            pulumi.set(__self__, "iops_read_burstable", iops_read_burstable)
        if iops_write is not None:
            pulumi.set(__self__, "iops_write", iops_write)
        if iops_write_burstable is not None:
            pulumi.set(__self__, "iops_write_burstable", iops_write_burstable)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if read_burstable is not None:
            pulumi.set(__self__, "read_burstable", read_burstable)
        if write is not None:
            pulumi.set(__self__, "write", write)
        if write_burstable is not None:
            pulumi.set(__self__, "write_burstable", write_burstable)

    @property
    @pulumi.getter(name="iopsRead")
    def iops_read(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum read I/O in operations per second.
        """
        return pulumi.get(self, "iops_read")

    @iops_read.setter
    def iops_read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops_read", value)

    @property
    @pulumi.getter(name="iopsReadBurstable")
    def iops_read_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum unthrottled read I/O pool in operations per second.
        """
        return pulumi.get(self, "iops_read_burstable")

    @iops_read_burstable.setter
    def iops_read_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops_read_burstable", value)

    @property
    @pulumi.getter(name="iopsWrite")
    def iops_write(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum write I/O in operations per second.
        """
        return pulumi.get(self, "iops_write")

    @iops_write.setter
    def iops_write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops_write", value)

    @property
    @pulumi.getter(name="iopsWriteBurstable")
    def iops_write_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum unthrottled write I/O pool in operations per second.
        """
        return pulumi.get(self, "iops_write_burstable")

    @iops_write_burstable.setter
    def iops_write_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops_write_burstable", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum read speed in megabytes per second.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter(name="readBurstable")
    def read_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum burstable read speed in
        megabytes per second.
        """
        return pulumi.get(self, "read_burstable")

    @read_burstable.setter
    def read_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_burstable", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum write speed in megabytes per second.
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "write", value)

    @property
    @pulumi.getter(name="writeBurstable")
    def write_burstable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum burstable write speed in
        megabytes per second.
        """
        return pulumi.get(self, "write_burstable")

    @write_burstable.setter
    def write_burstable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "write_burstable", value)


@pulumi.input_type
class VirtualMachineEfiDiskArgs:
    def __init__(__self__, *,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 file_format: Optional[pulumi.Input[str]] = None,
                 pre_enrolled_keys: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] file_format: The file format (defaults to `raw`).
        :param pulumi.Input[bool] pre_enrolled_keys: Use am EFI vars template with
               distribution-specific and Microsoft Standard keys enrolled, if used with
               EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
               to `false`).
        :param pulumi.Input[str] type: Size and type of the OVMF EFI disk. `4m` is newer and
               recommended, and required for Secure Boot. For backwards compatibility
               use `2m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
               to `2m`).
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if pre_enrolled_keys is not None:
            pulumi.set(__self__, "pre_enrolled_keys", pre_enrolled_keys)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The file format (defaults to `raw`).
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="preEnrolledKeys")
    def pre_enrolled_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        Use am EFI vars template with
        distribution-specific and Microsoft Standard keys enrolled, if used with
        EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `false`).
        """
        return pulumi.get(self, "pre_enrolled_keys")

    @pre_enrolled_keys.setter
    def pre_enrolled_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pre_enrolled_keys", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Size and type of the OVMF EFI disk. `4m` is newer and
        recommended, and required for Secure Boot. For backwards compatibility
        use `2m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `2m`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineHostpciArgs:
    def __init__(__self__, *,
                 device: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 mapping: Optional[pulumi.Input[str]] = None,
                 mdev: Optional[pulumi.Input[str]] = None,
                 pcie: Optional[pulumi.Input[bool]] = None,
                 rom_file: Optional[pulumi.Input[str]] = None,
                 rombar: Optional[pulumi.Input[bool]] = None,
                 xvga: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] device: The PCI device name for Proxmox, in form
               of `hostpciX` where `X` is a sequential number from 0 to 15.
        :param pulumi.Input[str] id: The PCI device ID. This parameter is not compatible
               with `api_token` and requires the root `username` and `password`
               configured in the proxmox provider. Use either this or `mapping`.
        :param pulumi.Input[str] mapping: The resource mapping name of the device, for
               example gpu. Use either this or `id`.
        :param pulumi.Input[str] mdev: The mediated device ID to use.
        :param pulumi.Input[bool] pcie: Tells Proxmox to use a PCIe or PCI port. Some
               guests/device combination require PCIe rather than PCI. PCIe is only
               available for q35 machine types.
        :param pulumi.Input[str] rom_file: A path to a ROM file for the device to use. This
               is a relative path under `/usr/share/kvm/`.
        :param pulumi.Input[bool] rombar: Makes the firmware ROM visible for the VM (defaults
               to `true`).
        :param pulumi.Input[bool] xvga: Marks the PCI(e) device as the primary GPU of the VM.
               With this enabled the `vga` configuration argument will be ignored.
        """
        pulumi.set(__self__, "device", device)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mapping is not None:
            pulumi.set(__self__, "mapping", mapping)
        if mdev is not None:
            pulumi.set(__self__, "mdev", mdev)
        if pcie is not None:
            pulumi.set(__self__, "pcie", pcie)
        if rom_file is not None:
            pulumi.set(__self__, "rom_file", rom_file)
        if rombar is not None:
            pulumi.set(__self__, "rombar", rombar)
        if xvga is not None:
            pulumi.set(__self__, "xvga", xvga)

    @property
    @pulumi.getter
    def device(self) -> pulumi.Input[str]:
        """
        The PCI device name for Proxmox, in form
        of `hostpciX` where `X` is a sequential number from 0 to 15.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: pulumi.Input[str]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The PCI device ID. This parameter is not compatible
        with `api_token` and requires the root `username` and `password`
        configured in the proxmox provider. Use either this or `mapping`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def mapping(self) -> Optional[pulumi.Input[str]]:
        """
        The resource mapping name of the device, for
        example gpu. Use either this or `id`.
        """
        return pulumi.get(self, "mapping")

    @mapping.setter
    def mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mapping", value)

    @property
    @pulumi.getter
    def mdev(self) -> Optional[pulumi.Input[str]]:
        """
        The mediated device ID to use.
        """
        return pulumi.get(self, "mdev")

    @mdev.setter
    def mdev(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mdev", value)

    @property
    @pulumi.getter
    def pcie(self) -> Optional[pulumi.Input[bool]]:
        """
        Tells Proxmox to use a PCIe or PCI port. Some
        guests/device combination require PCIe rather than PCI. PCIe is only
        available for q35 machine types.
        """
        return pulumi.get(self, "pcie")

    @pcie.setter
    def pcie(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pcie", value)

    @property
    @pulumi.getter(name="romFile")
    def rom_file(self) -> Optional[pulumi.Input[str]]:
        """
        A path to a ROM file for the device to use. This
        is a relative path under `/usr/share/kvm/`.
        """
        return pulumi.get(self, "rom_file")

    @rom_file.setter
    def rom_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rom_file", value)

    @property
    @pulumi.getter
    def rombar(self) -> Optional[pulumi.Input[bool]]:
        """
        Makes the firmware ROM visible for the VM (defaults
        to `true`).
        """
        return pulumi.get(self, "rombar")

    @rombar.setter
    def rombar(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rombar", value)

    @property
    @pulumi.getter
    def xvga(self) -> Optional[pulumi.Input[bool]]:
        """
        Marks the PCI(e) device as the primary GPU of the VM.
        With this enabled the `vga` configuration argument will be ignored.
        """
        return pulumi.get(self, "xvga")

    @xvga.setter
    def xvga(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "xvga", value)


@pulumi.input_type
class VirtualMachineInitializationArgs:
    def __init__(__self__, *,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 dns: Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 ip_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]] = None,
                 meta_data_file_id: Optional[pulumi.Input[str]] = None,
                 network_data_file_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 upgrade: Optional[pulumi.Input[bool]] = None,
                 user_account: Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']] = None,
                 user_data_file_id: Optional[pulumi.Input[str]] = None,
                 vendor_data_file_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param pulumi.Input['VirtualMachineInitializationDnsArgs'] dns: The DNS configuration.
        :param pulumi.Input[str] interface: The hardware interface to connect the cloud-init
               image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
               detected if the setting is missing but a cloud-init image is present,
               otherwise defaults to `ide2`.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]] ip_configs: The IP configuration (one block per network
               device).
        :param pulumi.Input[str] meta_data_file_id: The identifier for a file containing
               all meta data passed to the VM via cloud-init.
        :param pulumi.Input[str] network_data_file_id: The identifier for a file containing
               network configuration data passed to the VM via cloud-init (conflicts
               with `ip_config`).
        :param pulumi.Input[str] type: The cloud-init configuration format
        :param pulumi.Input[bool] upgrade: Whether to do an automatic package upgrade after the first boot
        :param pulumi.Input['VirtualMachineInitializationUserAccountArgs'] user_account: The user account configuration (conflicts
               with `user_data_file_id`).
        :param pulumi.Input[str] user_data_file_id: The identifier for a file containing
               custom user data (conflicts with `user_account`).
        :param pulumi.Input[str] vendor_data_file_id: The identifier for a file containing
               all vendor data passed to the VM via cloud-init.
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip_configs is not None:
            pulumi.set(__self__, "ip_configs", ip_configs)
        if meta_data_file_id is not None:
            pulumi.set(__self__, "meta_data_file_id", meta_data_file_id)
        if network_data_file_id is not None:
            pulumi.set(__self__, "network_data_file_id", network_data_file_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upgrade is not None:
            warnings.warn("""The `upgrade` attribute is deprecated and will be removed in a future release.""", DeprecationWarning)
            pulumi.log.warn("""upgrade is deprecated: The `upgrade` attribute is deprecated and will be removed in a future release.""")
        if upgrade is not None:
            pulumi.set(__self__, "upgrade", upgrade)
        if user_account is not None:
            pulumi.set(__self__, "user_account", user_account)
        if user_data_file_id is not None:
            pulumi.set(__self__, "user_data_file_id", user_data_file_id)
        if vendor_data_file_id is not None:
            pulumi.set(__self__, "vendor_data_file_id", vendor_data_file_id)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']]:
        """
        The DNS configuration.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['VirtualMachineInitializationDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter(name="ipConfigs")
    def ip_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]]:
        """
        The IP configuration (one block per network
        device).
        """
        return pulumi.get(self, "ip_configs")

    @ip_configs.setter
    def ip_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineInitializationIpConfigArgs']]]]):
        pulumi.set(self, "ip_configs", value)

    @property
    @pulumi.getter(name="metaDataFileId")
    def meta_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        all meta data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "meta_data_file_id")

    @meta_data_file_id.setter
    def meta_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "meta_data_file_id", value)

    @property
    @pulumi.getter(name="networkDataFileId")
    def network_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        network configuration data passed to the VM via cloud-init (conflicts
        with `ip_config`).
        """
        return pulumi.get(self, "network_data_file_id")

    @network_data_file_id.setter
    def network_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_data_file_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud-init configuration format
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `upgrade` attribute is deprecated and will be removed in a future release.""")
    def upgrade(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to do an automatic package upgrade after the first boot
        """
        return pulumi.get(self, "upgrade")

    @upgrade.setter
    def upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "upgrade", value)

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']]:
        """
        The user account configuration (conflicts
        with `user_data_file_id`).
        """
        return pulumi.get(self, "user_account")

    @user_account.setter
    def user_account(self, value: Optional[pulumi.Input['VirtualMachineInitializationUserAccountArgs']]):
        pulumi.set(self, "user_account", value)

    @property
    @pulumi.getter(name="userDataFileId")
    def user_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        custom user data (conflicts with `user_account`).
        """
        return pulumi.get(self, "user_data_file_id")

    @user_data_file_id.setter
    def user_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data_file_id", value)

    @property
    @pulumi.getter(name="vendorDataFileId")
    def vendor_data_file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for a file containing
        all vendor data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "vendor_data_file_id")

    @vendor_data_file_id.setter
    def vendor_data_file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor_data_file_id", value)


@pulumi.input_type
class VirtualMachineInitializationDnsArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] domain: The DNS search domain.
        :param pulumi.Input[str] server: The DNS server. The `server` attribute is
               deprecated and will be removed in a future release. Please use the
               `servers` attribute instead.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: The list of DNS servers.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if server is not None:
            warnings.warn("""The `server` attribute is deprecated and will be removed in a future release. Please use the `servers` attribute instead.""", DeprecationWarning)
            pulumi.log.warn("""server is deprecated: The `server` attribute is deprecated and will be removed in a future release. Please use the `servers` attribute instead.""")
        if server is not None:
            pulumi.set(__self__, "server", server)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS search domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `server` attribute is deprecated and will be removed in a future release. Please use the `servers` attribute instead.""")
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS server. The `server` attribute is
        deprecated and will be removed in a future release. Please use the
        `servers` attribute instead.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of DNS servers.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']] = None):
        """
        :param pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args'] ipv4: The IPv4 configuration.
        :param pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args'] ipv6: The IPv6 configuration.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']]:
        """
        The IPv4 configuration.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']]:
        """
        The IPv6 configuration.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['VirtualMachineInitializationIpConfigIpv6Args']]):
        pulumi.set(self, "ipv6", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The IPv4 address in CIDR notation
               (e.g. 192.168.2.2/24). Alternatively, set this to `dhcp` for
               autodiscovery.
        :param pulumi.Input[str] gateway: The IPv4 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 address in CIDR notation
        (e.g. 192.168.2.2/24). Alternatively, set this to `dhcp` for
        autodiscovery.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)


@pulumi.input_type
class VirtualMachineInitializationIpConfigIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 gateway: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The IPv6 address in CIDR notation
               (e.g. fd1c:000:0000::0000:000:7334/64). Alternatively, set this
               to `dhcp` for autodiscovery.
        :param pulumi.Input[str] gateway: The IPv6 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 address in CIDR notation
        (e.g. fd1c:000:0000::0000:000:7334/64). Alternatively, set this
        to `dhcp` for autodiscovery.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv6 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)


@pulumi.input_type
class VirtualMachineInitializationUserAccountArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: The SSH keys.
        :param pulumi.Input[str] password: The SSH password.
        :param pulumi.Input[str] username: The SSH username.
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The SSH keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The SSH username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class VirtualMachineMemoryArgs:
    def __init__(__self__, *,
                 dedicated: Optional[pulumi.Input[int]] = None,
                 floating: Optional[pulumi.Input[int]] = None,
                 hugepages: Optional[pulumi.Input[str]] = None,
                 keep_hugepages: Optional[pulumi.Input[bool]] = None,
                 shared: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] dedicated: The dedicated memory in megabytes (defaults
               to `512`).
        :param pulumi.Input[int] floating: The floating memory in megabytes (defaults
               to `0`).
        :param pulumi.Input[str] hugepages: Enable/disable hugepages memory (defaults to disable).
        :param pulumi.Input[bool] keep_hugepages: Keep hugepages memory after the VM is stopped (defaults
               to `false`).
               
               Settings `hugepages` and `keep_hugepages` are only allowed for `root@pam` authenticated user.
               And required `cpu.numa` to be enabled.
        :param pulumi.Input[int] shared: The shared memory in megabytes (defaults to `0`).
        """
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if floating is not None:
            pulumi.set(__self__, "floating", floating)
        if hugepages is not None:
            pulumi.set(__self__, "hugepages", hugepages)
        if keep_hugepages is not None:
            pulumi.set(__self__, "keep_hugepages", keep_hugepages)
        if shared is not None:
            pulumi.set(__self__, "shared", shared)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[int]]:
        """
        The dedicated memory in megabytes (defaults
        to `512`).
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dedicated", value)

    @property
    @pulumi.getter
    def floating(self) -> Optional[pulumi.Input[int]]:
        """
        The floating memory in megabytes (defaults
        to `0`).
        """
        return pulumi.get(self, "floating")

    @floating.setter
    def floating(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "floating", value)

    @property
    @pulumi.getter
    def hugepages(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable hugepages memory (defaults to disable).
        """
        return pulumi.get(self, "hugepages")

    @hugepages.setter
    def hugepages(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hugepages", value)

    @property
    @pulumi.getter(name="keepHugepages")
    def keep_hugepages(self) -> Optional[pulumi.Input[bool]]:
        """
        Keep hugepages memory after the VM is stopped (defaults
        to `false`).

        Settings `hugepages` and `keep_hugepages` are only allowed for `root@pam` authenticated user.
        And required `cpu.numa` to be enabled.
        """
        return pulumi.get(self, "keep_hugepages")

    @keep_hugepages.setter
    def keep_hugepages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_hugepages", value)

    @property
    @pulumi.getter
    def shared(self) -> Optional[pulumi.Input[int]]:
        """
        The shared memory in megabytes (defaults to `0`).
        """
        return pulumi.get(self, "shared")

    @shared.setter
    def shared(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shared", value)


@pulumi.input_type
class VirtualMachineNetworkDeviceArgs:
    def __init__(__self__, *,
                 bridge: Optional[pulumi.Input[str]] = None,
                 disconnected: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 firewall: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 queues: Optional[pulumi.Input[int]] = None,
                 rate_limit: Optional[pulumi.Input[float]] = None,
                 trunks: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bridge: The name of the network bridge (defaults to `vmbr0`).
        :param pulumi.Input[bool] disconnected: Whether to disconnect the network device from the network (defaults to `false`).
        :param pulumi.Input[bool] enabled: Whether to enable the network device (defaults to `true`).
        :param pulumi.Input[bool] firewall: Whether this interface's firewall rules should be used (defaults to `false`).
        :param pulumi.Input[str] mac_address: The MAC address.
        :param pulumi.Input[str] model: The network device model (defaults to `virtio`).
        :param pulumi.Input[int] mtu: Force MTU, for VirtIO only. Set to 1 to use the bridge MTU. Cannot be larger than the bridge MTU.
        :param pulumi.Input[int] queues: The number of queues for VirtIO (1..64).
        :param pulumi.Input[float] rate_limit: The rate limit in megabytes per second.
        :param pulumi.Input[str] trunks: String containing a `;` separated list of VLAN trunks
               ("10;20;30"). Note that the VLAN-aware feature need to be enabled on the PVE
               Linux Bridge to use trunks.
        :param pulumi.Input[int] vlan_id: The VLAN identifier.
        """
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if disconnected is not None:
            pulumi.set(__self__, "disconnected", disconnected)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if firewall is not None:
            pulumi.set(__self__, "firewall", firewall)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if trunks is not None:
            pulumi.set(__self__, "trunks", trunks)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def bridge(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the network bridge (defaults to `vmbr0`).
        """
        return pulumi.get(self, "bridge")

    @bridge.setter
    def bridge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge", value)

    @property
    @pulumi.getter
    def disconnected(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disconnect the network device from the network (defaults to `false`).
        """
        return pulumi.get(self, "disconnected")

    @disconnected.setter
    def disconnected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disconnected", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the network device (defaults to `true`).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def firewall(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this interface's firewall rules should be used (defaults to `false`).
        """
        return pulumi.get(self, "firewall")

    @firewall.setter
    def firewall(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "firewall", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The MAC address.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        The network device model (defaults to `virtio`).
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Force MTU, for VirtIO only. Set to 1 to use the bridge MTU. Cannot be larger than the bridge MTU.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def queues(self) -> Optional[pulumi.Input[int]]:
        """
        The number of queues for VirtIO (1..64).
        """
        return pulumi.get(self, "queues")

    @queues.setter
    def queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queues", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        The rate limit in megabytes per second.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter
    def trunks(self) -> Optional[pulumi.Input[str]]:
        """
        String containing a `;` separated list of VLAN trunks
        ("10;20;30"). Note that the VLAN-aware feature need to be enabled on the PVE
        Linux Bridge to use trunks.
        """
        return pulumi.get(self, "trunks")

    @trunks.setter
    def trunks(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trunks", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        The VLAN identifier.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class VirtualMachineNumaArgs:
    def __init__(__self__, *,
                 cpus: pulumi.Input[str],
                 device: pulumi.Input[str],
                 memory: pulumi.Input[int],
                 hostnodes: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpus: The CPU cores to assign to the NUMA node (format is `0-7;16-31`).
        :param pulumi.Input[str] device: The NUMA device name for Proxmox, in form
               of `numaX` where `X` is a sequential number from 0 to 7.
        :param pulumi.Input[int] memory: The memory in megabytes to assign to the NUMA node.
        :param pulumi.Input[str] hostnodes: The NUMA host nodes.
        :param pulumi.Input[str] policy: The NUMA policy (defaults to `preferred`).
        """
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "memory", memory)
        if hostnodes is not None:
            pulumi.set(__self__, "hostnodes", hostnodes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def cpus(self) -> pulumi.Input[str]:
        """
        The CPU cores to assign to the NUMA node (format is `0-7;16-31`).
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: pulumi.Input[str]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter
    def device(self) -> pulumi.Input[str]:
        """
        The NUMA device name for Proxmox, in form
        of `numaX` where `X` is a sequential number from 0 to 7.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: pulumi.Input[str]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[int]:
        """
        The memory in megabytes to assign to the NUMA node.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def hostnodes(self) -> Optional[pulumi.Input[str]]:
        """
        The NUMA host nodes.
        """
        return pulumi.get(self, "hostnodes")

    @hostnodes.setter
    def hostnodes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostnodes", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        The NUMA policy (defaults to `preferred`).
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class VirtualMachineOperatingSystemArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type (defaults to `other`).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type (defaults to `other`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineSerialDeviceArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device: The device (defaults to `socket`).
               - `/dev/*` - A host serial device.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)


@pulumi.input_type
class VirtualMachineSmbiosArgs:
    def __init__(__self__, *,
                 family: Optional[pulumi.Input[str]] = None,
                 manufacturer: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 serial: Optional[pulumi.Input[str]] = None,
                 sku: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] family: The family string.
        :param pulumi.Input[str] manufacturer: The manufacturer.
        :param pulumi.Input[str] product: The product ID.
        :param pulumi.Input[str] serial: The serial number.
        :param pulumi.Input[str] sku: The SKU number.
        :param pulumi.Input[str] uuid: The UUID (defaults to randomly generated UUID).
        :param pulumi.Input[str] version: The version.
        """
        if family is not None:
            pulumi.set(__self__, "family", family)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The family string.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[pulumi.Input[str]]:
        """
        The manufacturer.
        """
        return pulumi.get(self, "manufacturer")

    @manufacturer.setter
    def manufacturer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manufacturer", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        The product ID.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def serial(self) -> Optional[pulumi.Input[str]]:
        """
        The serial number.
        """
        return pulumi.get(self, "serial")

    @serial.setter
    def serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "serial", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU number.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID (defaults to randomly generated UUID).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class VirtualMachineStartupArgs:
    def __init__(__self__, *,
                 down_delay: Optional[pulumi.Input[int]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 up_delay: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] down_delay: A non-negative number defining the delay in
               seconds before the next VM is shut down.
        :param pulumi.Input[int] order: A non-negative number defining the general startup
               order.
        :param pulumi.Input[int] up_delay: A non-negative number defining the delay in
               seconds before the next VM is started.
        """
        if down_delay is not None:
            pulumi.set(__self__, "down_delay", down_delay)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if up_delay is not None:
            pulumi.set(__self__, "up_delay", up_delay)

    @property
    @pulumi.getter(name="downDelay")
    def down_delay(self) -> Optional[pulumi.Input[int]]:
        """
        A non-negative number defining the delay in
        seconds before the next VM is shut down.
        """
        return pulumi.get(self, "down_delay")

    @down_delay.setter
    def down_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "down_delay", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        A non-negative number defining the general startup
        order.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="upDelay")
    def up_delay(self) -> Optional[pulumi.Input[int]]:
        """
        A non-negative number defining the delay in
        seconds before the next VM is started.
        """
        return pulumi.get(self, "up_delay")

    @up_delay.setter
    def up_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "up_delay", value)


@pulumi.input_type
class VirtualMachineTpmStateArgs:
    def __init__(__self__, *,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param pulumi.Input[str] version: TPM state device version. Can be `v1.2` or `v2.0`.
               (defaults to `v2.0`).
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        TPM state device version. Can be `v1.2` or `v2.0`.
        (defaults to `v2.0`).
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class VirtualMachineUsbArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 mapping: Optional[pulumi.Input[str]] = None,
                 usb3: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] host: The Host USB device or port or the value `spice`. Use either this or `mapping`.
        :param pulumi.Input[str] mapping: The cluster-wide resource mapping name of the device, for example "usbdevice". Use either this or `host`.
        :param pulumi.Input[bool] usb3: Makes the USB device a USB3 device for the VM
               (defaults to `false`).
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mapping is not None:
            pulumi.set(__self__, "mapping", mapping)
        if usb3 is not None:
            pulumi.set(__self__, "usb3", usb3)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The Host USB device or port or the value `spice`. Use either this or `mapping`.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def mapping(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster-wide resource mapping name of the device, for example "usbdevice". Use either this or `host`.
        """
        return pulumi.get(self, "mapping")

    @mapping.setter
    def mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mapping", value)

    @property
    @pulumi.getter
    def usb3(self) -> Optional[pulumi.Input[bool]]:
        """
        Makes the USB device a USB3 device for the VM
        (defaults to `false`).
        """
        return pulumi.get(self, "usb3")

    @usb3.setter
    def usb3(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "usb3", value)


@pulumi.input_type
class VirtualMachineVgaArgs:
    def __init__(__self__, *,
                 clipboard: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] clipboard: Enable VNC clipboard by setting to `vnc`. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
        :param pulumi.Input[int] memory: The VGA memory in megabytes (defaults to `16`).
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        if clipboard is not None:
            pulumi.set(__self__, "clipboard", clipboard)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> Optional[pulumi.Input[str]]:
        """
        Enable VNC clipboard by setting to `vnc`. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
        """
        return pulumi.get(self, "clipboard")

    @clipboard.setter
    def clipboard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clipboard", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The VGA memory in megabytes (defaults to `16`).
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetVirtualMachinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the VM attribute to filter on. One of [`name`, `template`, `status`, `node_name`]
        :param Sequence[str] values: List of values to pass the filter. VM's attribute should match at least one value in the list.
        :param bool regex: Treat values as regex patterns
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the VM attribute to filter on. One of [`name`, `template`, `status`, `node_name`]
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of values to pass the filter. VM's attribute should match at least one value in the list.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Treat values as regex patterns
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


