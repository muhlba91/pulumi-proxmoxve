# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'VirtualMachine2Cdrom',
    'VirtualMachine2Clone',
    'VirtualMachine2Cpu',
    'VirtualMachine2Timeouts',
    'VirtualMachine2Vga',
    'VirtualMachineAgent',
    'VirtualMachineAudioDevice',
    'VirtualMachineCdrom',
    'VirtualMachineClone',
    'VirtualMachineCpu',
    'VirtualMachineDisk',
    'VirtualMachineDiskSpeed',
    'VirtualMachineEfiDisk',
    'VirtualMachineHostpci',
    'VirtualMachineInitialization',
    'VirtualMachineInitializationDns',
    'VirtualMachineInitializationIpConfig',
    'VirtualMachineInitializationIpConfigIpv4',
    'VirtualMachineInitializationIpConfigIpv6',
    'VirtualMachineInitializationUserAccount',
    'VirtualMachineMemory',
    'VirtualMachineNetworkDevice',
    'VirtualMachineNuma',
    'VirtualMachineOperatingSystem',
    'VirtualMachineSerialDevice',
    'VirtualMachineSmbios',
    'VirtualMachineStartup',
    'VirtualMachineTpmState',
    'VirtualMachineUsb',
    'VirtualMachineVga',
    'VirtualMachineWatchdog',
    'GetVirtualMachinesFilterResult',
    'GetVirtualMachinesVmResult',
]

@pulumi.output_type
class VirtualMachine2Cdrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileId":
            suggest = "file_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachine2Cdrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachine2Cdrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachine2Cdrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_id: Optional[str] = None):
        """
        :param str file_id: The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[str]:
        """
        The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        return pulumi.get(self, "file_id")


@pulumi.output_type
class VirtualMachine2Clone(dict):
    def __init__(__self__, *,
                 id: int,
                 retries: Optional[int] = None):
        """
        :param int id: The ID of the VM to clone.
        :param int retries: The number of retries to perform when cloning the VM (default: 3).
        """
        pulumi.set(__self__, "id", id)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the VM to clone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class VirtualMachine2Cpu(dict):
    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 architecture: Optional[str] = None,
                 cores: Optional[int] = None,
                 flags: Optional[Sequence[str]] = None,
                 hotplugged: Optional[int] = None,
                 limit: Optional[int] = None,
                 numa: Optional[bool] = None,
                 sockets: Optional[int] = None,
                 type: Optional[str] = None,
                 units: Optional[int] = None):
        """
        :param str affinity: The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param str architecture: The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param int cores: The number of CPU cores per socket (defaults to `1`).
        :param Sequence[str] flags: Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        :param int hotplugged: The number of hotplugged vCPUs (defaults to `0`).
        :param int limit: Limit of CPU usage (defaults to `0` which means no limit).
        :param bool numa: Enable NUMA (defaults to `false`).
        :param int sockets: The number of CPU sockets (defaults to `1`).
        :param str type: Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        :param int units: CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if hotplugged is not None:
            pulumi.set(__self__, "hotplugged", hotplugged)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def architecture(self) -> Optional[str]:
        """
        The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter
    def cores(self) -> Optional[int]:
        """
        The number of CPU cores per socket (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def flags(self) -> Optional[Sequence[str]]:
        """
        Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[int]:
        """
        The number of hotplugged vCPUs (defaults to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Limit of CPU usage (defaults to `0` which means no limit).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def numa(self) -> Optional[bool]:
        """
        Enable NUMA (defaults to `false`).
        """
        return pulumi.get(self, "numa")

    @property
    @pulumi.getter
    def sockets(self) -> Optional[int]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def units(self) -> Optional[int]:
        """
        CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class VirtualMachine2Timeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 read: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class VirtualMachine2Vga(dict):
    def __init__(__self__, *,
                 clipboard: Optional[str] = None,
                 memory: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str clipboard: Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        :param int memory: The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        :param str type: The VGA type (defaults to `std`).
        """
        if clipboard is not None:
            pulumi.set(__self__, "clipboard", clipboard)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> Optional[str]:
        """
        Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        """
        return pulumi.get(self, "clipboard")

    @property
    @pulumi.getter
    def memory(self) -> Optional[int]:
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineAgent(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 timeout: Optional[str] = None,
                 trim: Optional[bool] = None,
                 type: Optional[str] = None):
        """
        :param bool enabled: Whether to enable the QEMU agent (defaults
               to `false`).
        :param str timeout: The maximum amount of time to wait for data from
               the QEMU agent to become available ( defaults to `15m`).
        :param bool trim: Whether to enable the FSTRIM feature in the QEMU agent
               (defaults to `false`).
        :param str type: The QEMU agent interface type (defaults to `virtio`).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if trim is not None:
            pulumi.set(__self__, "trim", trim)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable the QEMU agent (defaults
        to `false`).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        The maximum amount of time to wait for data from
        the QEMU agent to become available ( defaults to `15m`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def trim(self) -> Optional[bool]:
        """
        Whether to enable the FSTRIM feature in the QEMU agent
        (defaults to `false`).
        """
        return pulumi.get(self, "trim")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The QEMU agent interface type (defaults to `virtio`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineAudioDevice(dict):
    def __init__(__self__, *,
                 device: Optional[str] = None,
                 driver: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        :param str device: The device (defaults to `intel-hda`).
               - `AC97` - Intel 82801AA AC97 Audio.
               - `ich9-intel-hda` - Intel HD Audio Controller (ich9).
               - `intel-hda` - Intel HD Audio.
        :param str driver: The driver (defaults to `spice`).
        :param bool enabled: Whether to enable the audio device (defaults
               to `true`).
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The device (defaults to `intel-hda`).
        - `AC97` - Intel 82801AA AC97 Audio.
        - `ich9-intel-hda` - Intel HD Audio Controller (ich9).
        - `intel-hda` - Intel HD Audio.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def driver(self) -> Optional[str]:
        """
        The driver (defaults to `spice`).
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable the audio device (defaults
        to `true`).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VirtualMachineCdrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileId":
            suggest = "file_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCdrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 file_id: Optional[str] = None,
                 interface: Optional[str] = None):
        """
        :param bool enabled: Whether to enable the CDROM drive (defaults
               to `false`).
        :param str file_id: A file ID for an ISO file (defaults to `cdrom` as
               in the physical drive). Use `none` to leave the CDROM drive empty.
        :param str interface: A hardware interface to connect CDROM drive to,
               must be `ideN` (defaults to `ide3`). Note that `q35` machine type only
               supports `ide0` and `ide2`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable the CDROM drive (defaults
        to `false`).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[str]:
        """
        A file ID for an ISO file (defaults to `cdrom` as
        in the physical drive). Use `none` to leave the CDROM drive empty.
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        A hardware interface to connect CDROM drive to,
        must be `ideN` (defaults to `ide3`). Note that `q35` machine type only
        supports `ide0` and `ide2`.
        """
        return pulumi.get(self, "interface")


@pulumi.output_type
class VirtualMachineClone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmId":
            suggest = "vm_id"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineClone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vm_id: int,
                 datastore_id: Optional[str] = None,
                 full: Optional[bool] = None,
                 node_name: Optional[str] = None,
                 retries: Optional[int] = None):
        """
        :param int vm_id: The identifier for the source VM.
        :param str datastore_id: The identifier for the target datastore.
        :param bool full: Full or linked clone (defaults to `true`).
        :param str node_name: The name of the source node (leave blank, if
               equal to the `node_name` argument).
        :param int retries: Number of retries in Proxmox for clone vm.
               Sometimes Proxmox errors with timeout when creating multiple clones at
               once.
        """
        pulumi.set(__self__, "vm_id", vm_id)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if full is not None:
            pulumi.set(__self__, "full", full)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> int:
        """
        The identifier for the source VM.
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The identifier for the target datastore.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def full(self) -> Optional[bool]:
        """
        Full or linked clone (defaults to `true`).
        """
        return pulumi.get(self, "full")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        The name of the source node (leave blank, if
        equal to the `node_name` argument).
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        Number of retries in Proxmox for clone vm.
        Sometimes Proxmox errors with timeout when creating multiple clones at
        once.
        """
        return pulumi.get(self, "retries")


@pulumi.output_type
class VirtualMachineCpu(dict):
    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 architecture: Optional[str] = None,
                 cores: Optional[int] = None,
                 flags: Optional[Sequence[str]] = None,
                 hotplugged: Optional[int] = None,
                 limit: Optional[int] = None,
                 numa: Optional[bool] = None,
                 sockets: Optional[int] = None,
                 type: Optional[str] = None,
                 units: Optional[int] = None):
        """
        :param str affinity: The CPU cores that are used to run the VM’s vCPU. The
               value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.
               For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four
               CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param str architecture: The CPU architecture (defaults to `x86_64`).
        :param int cores: The number of CPU cores (defaults to `1`).
        :param Sequence[str] flags: The CPU flags.
               - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
               - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
               vulnerable for Spectre on AMD CPUs.
               - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
               AMD CPUs, best used with "virt-ssbd".
               - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
               virtualization (only supported on Intel CPUs).
               - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
               Windows guests (may lead to guest BSOD on old CPUs).
               - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
               - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
               mitigated correctly.
               - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
               Ivy Bridge Intel CPUs.
               - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
               host HW supports it.
               - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
               Intel CPUs.
               - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
               models.
               - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
               protection for AMD models.
        :param int hotplugged: The number of hotplugged vCPUs (defaults
               to `0`).
        :param int limit: Limit of CPU usage, `0...128`. (defaults to `0` -- no limit).
        :param bool numa: Enable/disable NUMA. (default to `false`)
        :param int sockets: The number of CPU sockets (defaults to `1`).
        :param str type: The emulated CPU type, it's recommended to
               use `x86-64-v2-AES` (defaults to `qemu64`).
        :param int units: The CPU units (defaults to `1024`).
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if hotplugged is not None:
            pulumi.set(__self__, "hotplugged", hotplugged)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The CPU cores that are used to run the VM’s vCPU. The
        value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.
        For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four
        CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def architecture(self) -> Optional[str]:
        """
        The CPU architecture (defaults to `x86_64`).
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter
    def cores(self) -> Optional[int]:
        """
        The number of CPU cores (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @property
    @pulumi.getter
    def flags(self) -> Optional[Sequence[str]]:
        """
        The CPU flags.
        - `+aes`/`-aes` - Activate AES instruction set for HW acceleration.
        - `+amd-no-ssb`/`-amd-no-ssb` - Notifies guest OS that host is not
        vulnerable for Spectre on AMD CPUs.
        - `+amd-ssbd`/`-amd-ssbd` - Improves Spectre mitigation performance with
        AMD CPUs, best used with "virt-ssbd".
        - `+hv-evmcs`/`-hv-evmcs` - Improve performance for nested
        virtualization (only supported on Intel CPUs).
        - `+hv-tlbflush`/`-hv-tlbflush` - Improve performance in overcommitted
        Windows guests (may lead to guest BSOD on old CPUs).
        - `+ibpb`/`-ibpb` - Allows improved Spectre mitigation on AMD CPUs.
        - `+md-clear`/`-md-clear` - Required to let the guest OS know if MDS is
        mitigated correctly.
        - `+pcid`/`-pcid` - Meltdown fix cost reduction on Westmere, Sandy- and
        Ivy Bridge Intel CPUs.
        - `+pdpe1gb`/`-pdpe1gb` - Allows guest OS to use 1 GB size pages, if
        host HW supports it.
        - `+spec-ctrl`/`-spec-ctrl` - Allows improved Spectre mitigation with
        Intel CPUs.
        - `+ssbd`/`-ssbd` - Protection for "Speculative Store Bypass" for Intel
        models.
        - `+virt-ssbd`/`-virt-ssbd` - Basis for "Speculative Store Bypass"
        protection for AMD models.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[int]:
        """
        The number of hotplugged vCPUs (defaults
        to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Limit of CPU usage, `0...128`. (defaults to `0` -- no limit).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def numa(self) -> Optional[bool]:
        """
        Enable/disable NUMA. (default to `false`)
        """
        return pulumi.get(self, "numa")

    @property
    @pulumi.getter
    def sockets(self) -> Optional[int]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The emulated CPU type, it's recommended to
        use `x86-64-v2-AES` (defaults to `qemu64`).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def units(self) -> Optional[int]:
        """
        The CPU units (defaults to `1024`).
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class VirtualMachineDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "fileFormat":
            suggest = "file_format"
        elif key == "fileId":
            suggest = "file_id"
        elif key == "pathInDatastore":
            suggest = "path_in_datastore"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface: str,
                 aio: Optional[str] = None,
                 backup: Optional[bool] = None,
                 cache: Optional[str] = None,
                 datastore_id: Optional[str] = None,
                 discard: Optional[str] = None,
                 file_format: Optional[str] = None,
                 file_id: Optional[str] = None,
                 iothread: Optional[bool] = None,
                 path_in_datastore: Optional[str] = None,
                 replicate: Optional[bool] = None,
                 serial: Optional[str] = None,
                 size: Optional[int] = None,
                 speed: Optional['outputs.VirtualMachineDiskSpeed'] = None,
                 ssd: Optional[bool] = None):
        """
        :param str interface: The disk interface for Proxmox, currently `scsi`,
               `sata` and `virtio` interfaces are supported. Append the disk index at
               the end, for example, `virtio0` for the first virtio disk, `virtio1` for
               the second, etc.
        :param str aio: The disk AIO mode (defaults to `io_uring`).
        :param bool backup: Whether the drive should be included when making backups (defaults to `true`).
        :param str cache: The cache type (defaults to `none`).
        :param str datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param str discard: Whether to pass discard/trim requests to the
               underlying storage. Supported values are `on`/`ignore` (defaults
               to `ignore`).
        :param str file_format: The file format (defaults to `qcow2`).
        :param str file_id: The file ID for a disk image. The ID format is
               `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/centos8.img`. Can be also taken from
               `Download.File` resource.
        :param bool iothread: Whether to use iothreads for this disk (defaults
               to `false`).
        :param str path_in_datastore: The in-datastore path to the disk image.
               ***Experimental.***Use to attach another VM's disks,
               or (as root only) host's filesystem paths (`datastore_id` empty string).
               See "*Example: Attached disks*".
        :param bool replicate: Whether the drive should be considered for replication jobs (defaults to `true`).
        :param str serial: The serial number of the disk, up to 20 bytes long.
        :param int size: The disk size in gigabytes (defaults to `8`).
        :param 'VirtualMachineDiskSpeedArgs' speed: The speed limits.
        :param bool ssd: Whether to use an SSD emulation option for this disk (
               defaults to `false`). Note that SSD emulation is not supported on VirtIO
               Block drives.
        """
        pulumi.set(__self__, "interface", interface)
        if aio is not None:
            pulumi.set(__self__, "aio", aio)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)
        if iothread is not None:
            pulumi.set(__self__, "iothread", iothread)
        if path_in_datastore is not None:
            pulumi.set(__self__, "path_in_datastore", path_in_datastore)
        if replicate is not None:
            pulumi.set(__self__, "replicate", replicate)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if ssd is not None:
            pulumi.set(__self__, "ssd", ssd)

    @property
    @pulumi.getter
    def interface(self) -> str:
        """
        The disk interface for Proxmox, currently `scsi`,
        `sata` and `virtio` interfaces are supported. Append the disk index at
        the end, for example, `virtio0` for the first virtio disk, `virtio1` for
        the second, etc.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def aio(self) -> Optional[str]:
        """
        The disk AIO mode (defaults to `io_uring`).
        """
        return pulumi.get(self, "aio")

    @property
    @pulumi.getter
    def backup(self) -> Optional[bool]:
        """
        Whether the drive should be included when making backups (defaults to `true`).
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def cache(self) -> Optional[str]:
        """
        The cache type (defaults to `none`).
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def discard(self) -> Optional[str]:
        """
        Whether to pass discard/trim requests to the
        underlying storage. Supported values are `on`/`ignore` (defaults
        to `ignore`).
        """
        return pulumi.get(self, "discard")

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[str]:
        """
        The file format (defaults to `qcow2`).
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[str]:
        """
        The file ID for a disk image. The ID format is
        `<datastore_id>:<content_type>/<file_name>`, for example `local:iso/centos8.img`. Can be also taken from
        `Download.File` resource.
        """
        return pulumi.get(self, "file_id")

    @property
    @pulumi.getter
    def iothread(self) -> Optional[bool]:
        """
        Whether to use iothreads for this disk (defaults
        to `false`).
        """
        return pulumi.get(self, "iothread")

    @property
    @pulumi.getter(name="pathInDatastore")
    def path_in_datastore(self) -> Optional[str]:
        """
        The in-datastore path to the disk image.
        ***Experimental.***Use to attach another VM's disks,
        or (as root only) host's filesystem paths (`datastore_id` empty string).
        See "*Example: Attached disks*".
        """
        return pulumi.get(self, "path_in_datastore")

    @property
    @pulumi.getter
    def replicate(self) -> Optional[bool]:
        """
        Whether the drive should be considered for replication jobs (defaults to `true`).
        """
        return pulumi.get(self, "replicate")

    @property
    @pulumi.getter
    def serial(self) -> Optional[str]:
        """
        The serial number of the disk, up to 20 bytes long.
        """
        return pulumi.get(self, "serial")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The disk size in gigabytes (defaults to `8`).
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def speed(self) -> Optional['outputs.VirtualMachineDiskSpeed']:
        """
        The speed limits.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter
    def ssd(self) -> Optional[bool]:
        """
        Whether to use an SSD emulation option for this disk (
        defaults to `false`). Note that SSD emulation is not supported on VirtIO
        Block drives.
        """
        return pulumi.get(self, "ssd")


@pulumi.output_type
class VirtualMachineDiskSpeed(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iopsRead":
            suggest = "iops_read"
        elif key == "iopsReadBurstable":
            suggest = "iops_read_burstable"
        elif key == "iopsWrite":
            suggest = "iops_write"
        elif key == "iopsWriteBurstable":
            suggest = "iops_write_burstable"
        elif key == "readBurstable":
            suggest = "read_burstable"
        elif key == "writeBurstable":
            suggest = "write_burstable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineDiskSpeed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineDiskSpeed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineDiskSpeed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iops_read: Optional[int] = None,
                 iops_read_burstable: Optional[int] = None,
                 iops_write: Optional[int] = None,
                 iops_write_burstable: Optional[int] = None,
                 read: Optional[int] = None,
                 read_burstable: Optional[int] = None,
                 write: Optional[int] = None,
                 write_burstable: Optional[int] = None):
        """
        :param int iops_read: The maximum read I/O in operations per second.
        :param int iops_read_burstable: The maximum unthrottled read I/O pool in operations per second.
        :param int iops_write: The maximum write I/O in operations per second.
        :param int iops_write_burstable: The maximum unthrottled write I/O pool in operations per second.
        :param int read: The maximum read speed in megabytes per second.
        :param int read_burstable: The maximum burstable read speed in
               megabytes per second.
        :param int write: The maximum write speed in megabytes per second.
        :param int write_burstable: The maximum burstable write speed in
               megabytes per second.
        """
        if iops_read is not None:
            pulumi.set(__self__, "iops_read", iops_read)
        if iops_read_burstable is not None:
            pulumi.set(__self__, "iops_read_burstable", iops_read_burstable)
        if iops_write is not None:
            pulumi.set(__self__, "iops_write", iops_write)
        if iops_write_burstable is not None:
            pulumi.set(__self__, "iops_write_burstable", iops_write_burstable)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if read_burstable is not None:
            pulumi.set(__self__, "read_burstable", read_burstable)
        if write is not None:
            pulumi.set(__self__, "write", write)
        if write_burstable is not None:
            pulumi.set(__self__, "write_burstable", write_burstable)

    @property
    @pulumi.getter(name="iopsRead")
    def iops_read(self) -> Optional[int]:
        """
        The maximum read I/O in operations per second.
        """
        return pulumi.get(self, "iops_read")

    @property
    @pulumi.getter(name="iopsReadBurstable")
    def iops_read_burstable(self) -> Optional[int]:
        """
        The maximum unthrottled read I/O pool in operations per second.
        """
        return pulumi.get(self, "iops_read_burstable")

    @property
    @pulumi.getter(name="iopsWrite")
    def iops_write(self) -> Optional[int]:
        """
        The maximum write I/O in operations per second.
        """
        return pulumi.get(self, "iops_write")

    @property
    @pulumi.getter(name="iopsWriteBurstable")
    def iops_write_burstable(self) -> Optional[int]:
        """
        The maximum unthrottled write I/O pool in operations per second.
        """
        return pulumi.get(self, "iops_write_burstable")

    @property
    @pulumi.getter
    def read(self) -> Optional[int]:
        """
        The maximum read speed in megabytes per second.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter(name="readBurstable")
    def read_burstable(self) -> Optional[int]:
        """
        The maximum burstable read speed in
        megabytes per second.
        """
        return pulumi.get(self, "read_burstable")

    @property
    @pulumi.getter
    def write(self) -> Optional[int]:
        """
        The maximum write speed in megabytes per second.
        """
        return pulumi.get(self, "write")

    @property
    @pulumi.getter(name="writeBurstable")
    def write_burstable(self) -> Optional[int]:
        """
        The maximum burstable write speed in
        megabytes per second.
        """
        return pulumi.get(self, "write_burstable")


@pulumi.output_type
class VirtualMachineEfiDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "fileFormat":
            suggest = "file_format"
        elif key == "preEnrolledKeys":
            suggest = "pre_enrolled_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineEfiDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineEfiDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineEfiDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_id: Optional[str] = None,
                 file_format: Optional[str] = None,
                 pre_enrolled_keys: Optional[bool] = None,
                 type: Optional[str] = None):
        """
        :param str datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param str file_format: The file format (defaults to `raw`).
        :param bool pre_enrolled_keys: Use am EFI vars template with
               distribution-specific and Microsoft Standard keys enrolled, if used with
               EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
               to `false`).
        :param str type: Size and type of the OVMF EFI disk. `4m` is newer and
               recommended, and required for Secure Boot. For backwards compatibility
               use `2m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
               to `2m`).
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if pre_enrolled_keys is not None:
            pulumi.set(__self__, "pre_enrolled_keys", pre_enrolled_keys)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[str]:
        """
        The file format (defaults to `raw`).
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="preEnrolledKeys")
    def pre_enrolled_keys(self) -> Optional[bool]:
        """
        Use am EFI vars template with
        distribution-specific and Microsoft Standard keys enrolled, if used with
        EFI type=`4m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `false`).
        """
        return pulumi.get(self, "pre_enrolled_keys")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Size and type of the OVMF EFI disk. `4m` is newer and
        recommended, and required for Secure Boot. For backwards compatibility
        use `2m`. Ignored for VMs with cpu.architecture=`aarch64` (defaults
        to `2m`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineHostpci(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "romFile":
            suggest = "rom_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineHostpci. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineHostpci.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineHostpci.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: str,
                 id: Optional[str] = None,
                 mapping: Optional[str] = None,
                 mdev: Optional[str] = None,
                 pcie: Optional[bool] = None,
                 rom_file: Optional[str] = None,
                 rombar: Optional[bool] = None,
                 xvga: Optional[bool] = None):
        """
        :param str device: The PCI device name for Proxmox, in form
               of `hostpciX` where `X` is a sequential number from 0 to 15.
        :param str id: The PCI device ID. This parameter is not compatible
               with `api_token` and requires the root `username` and `password`
               configured in the proxmox provider. Use either this or `mapping`.
        :param str mapping: The resource mapping name of the device, for
               example gpu. Use either this or `id`.
        :param str mdev: The mediated device ID to use.
        :param bool pcie: Tells Proxmox to use a PCIe or PCI port. Some
               guests/device combination require PCIe rather than PCI. PCIe is only
               available for q35 machine types.
        :param str rom_file: A path to a ROM file for the device to use. This
               is a relative path under `/usr/share/kvm/`.
        :param bool rombar: Makes the firmware ROM visible for the VM (defaults
               to `true`).
        :param bool xvga: Marks the PCI(e) device as the primary GPU of the VM.
               With this enabled the `vga` configuration argument will be ignored.
        """
        pulumi.set(__self__, "device", device)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mapping is not None:
            pulumi.set(__self__, "mapping", mapping)
        if mdev is not None:
            pulumi.set(__self__, "mdev", mdev)
        if pcie is not None:
            pulumi.set(__self__, "pcie", pcie)
        if rom_file is not None:
            pulumi.set(__self__, "rom_file", rom_file)
        if rombar is not None:
            pulumi.set(__self__, "rombar", rombar)
        if xvga is not None:
            pulumi.set(__self__, "xvga", xvga)

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        The PCI device name for Proxmox, in form
        of `hostpciX` where `X` is a sequential number from 0 to 15.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The PCI device ID. This parameter is not compatible
        with `api_token` and requires the root `username` and `password`
        configured in the proxmox provider. Use either this or `mapping`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mapping(self) -> Optional[str]:
        """
        The resource mapping name of the device, for
        example gpu. Use either this or `id`.
        """
        return pulumi.get(self, "mapping")

    @property
    @pulumi.getter
    def mdev(self) -> Optional[str]:
        """
        The mediated device ID to use.
        """
        return pulumi.get(self, "mdev")

    @property
    @pulumi.getter
    def pcie(self) -> Optional[bool]:
        """
        Tells Proxmox to use a PCIe or PCI port. Some
        guests/device combination require PCIe rather than PCI. PCIe is only
        available for q35 machine types.
        """
        return pulumi.get(self, "pcie")

    @property
    @pulumi.getter(name="romFile")
    def rom_file(self) -> Optional[str]:
        """
        A path to a ROM file for the device to use. This
        is a relative path under `/usr/share/kvm/`.
        """
        return pulumi.get(self, "rom_file")

    @property
    @pulumi.getter
    def rombar(self) -> Optional[bool]:
        """
        Makes the firmware ROM visible for the VM (defaults
        to `true`).
        """
        return pulumi.get(self, "rombar")

    @property
    @pulumi.getter
    def xvga(self) -> Optional[bool]:
        """
        Marks the PCI(e) device as the primary GPU of the VM.
        With this enabled the `vga` configuration argument will be ignored.
        """
        return pulumi.get(self, "xvga")


@pulumi.output_type
class VirtualMachineInitialization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"
        elif key == "ipConfigs":
            suggest = "ip_configs"
        elif key == "metaDataFileId":
            suggest = "meta_data_file_id"
        elif key == "networkDataFileId":
            suggest = "network_data_file_id"
        elif key == "userAccount":
            suggest = "user_account"
        elif key == "userDataFileId":
            suggest = "user_data_file_id"
        elif key == "vendorDataFileId":
            suggest = "vendor_data_file_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineInitialization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineInitialization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineInitialization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_id: Optional[str] = None,
                 dns: Optional['outputs.VirtualMachineInitializationDns'] = None,
                 interface: Optional[str] = None,
                 ip_configs: Optional[Sequence['outputs.VirtualMachineInitializationIpConfig']] = None,
                 meta_data_file_id: Optional[str] = None,
                 network_data_file_id: Optional[str] = None,
                 type: Optional[str] = None,
                 upgrade: Optional[bool] = None,
                 user_account: Optional['outputs.VirtualMachineInitializationUserAccount'] = None,
                 user_data_file_id: Optional[str] = None,
                 vendor_data_file_id: Optional[str] = None):
        """
        :param str datastore_id: The identifier for the datastore to create the
               cloud-init disk in (defaults to `local-lvm`).
        :param 'VirtualMachineInitializationDnsArgs' dns: The DNS configuration.
        :param str interface: The hardware interface to connect the cloud-init
               image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
               detected if the setting is missing but a cloud-init image is present,
               otherwise defaults to `ide2`.
        :param Sequence['VirtualMachineInitializationIpConfigArgs'] ip_configs: The IP configuration (one block per network
               device).
        :param str meta_data_file_id: The identifier for a file containing
               all meta data passed to the VM via cloud-init.
        :param str network_data_file_id: The identifier for a file containing
               network configuration data passed to the VM via cloud-init (conflicts
               with `ip_config`).
        :param str type: The cloud-init configuration format
        :param bool upgrade: Whether to do an automatic package upgrade after the first boot
        :param 'VirtualMachineInitializationUserAccountArgs' user_account: The user account configuration (conflicts
               with `user_data_file_id`).
        :param str user_data_file_id: The identifier for a file containing
               custom user data (conflicts with `user_account`).
        :param str vendor_data_file_id: The identifier for a file containing
               all vendor data passed to the VM via cloud-init.
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if ip_configs is not None:
            pulumi.set(__self__, "ip_configs", ip_configs)
        if meta_data_file_id is not None:
            pulumi.set(__self__, "meta_data_file_id", meta_data_file_id)
        if network_data_file_id is not None:
            pulumi.set(__self__, "network_data_file_id", network_data_file_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if upgrade is not None:
            pulumi.set(__self__, "upgrade", upgrade)
        if user_account is not None:
            pulumi.set(__self__, "user_account", user_account)
        if user_data_file_id is not None:
            pulumi.set(__self__, "user_data_file_id", user_data_file_id)
        if vendor_data_file_id is not None:
            pulumi.set(__self__, "vendor_data_file_id", vendor_data_file_id)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The identifier for the datastore to create the
        cloud-init disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.VirtualMachineInitializationDns']:
        """
        The DNS configuration.
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        The hardware interface to connect the cloud-init
        image to. Must be one of `ide0..3`, `sata0..5`, `scsi0..30`. Will be
        detected if the setting is missing but a cloud-init image is present,
        otherwise defaults to `ide2`.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter(name="ipConfigs")
    def ip_configs(self) -> Optional[Sequence['outputs.VirtualMachineInitializationIpConfig']]:
        """
        The IP configuration (one block per network
        device).
        """
        return pulumi.get(self, "ip_configs")

    @property
    @pulumi.getter(name="metaDataFileId")
    def meta_data_file_id(self) -> Optional[str]:
        """
        The identifier for a file containing
        all meta data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "meta_data_file_id")

    @property
    @pulumi.getter(name="networkDataFileId")
    def network_data_file_id(self) -> Optional[str]:
        """
        The identifier for a file containing
        network configuration data passed to the VM via cloud-init (conflicts
        with `ip_config`).
        """
        return pulumi.get(self, "network_data_file_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The cloud-init configuration format
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `upgrade` attribute is deprecated and will be removed in a future release.""")
    def upgrade(self) -> Optional[bool]:
        """
        Whether to do an automatic package upgrade after the first boot
        """
        return pulumi.get(self, "upgrade")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional['outputs.VirtualMachineInitializationUserAccount']:
        """
        The user account configuration (conflicts
        with `user_data_file_id`).
        """
        return pulumi.get(self, "user_account")

    @property
    @pulumi.getter(name="userDataFileId")
    def user_data_file_id(self) -> Optional[str]:
        """
        The identifier for a file containing
        custom user data (conflicts with `user_account`).
        """
        return pulumi.get(self, "user_data_file_id")

    @property
    @pulumi.getter(name="vendorDataFileId")
    def vendor_data_file_id(self) -> Optional[str]:
        """
        The identifier for a file containing
        all vendor data passed to the VM via cloud-init.
        """
        return pulumi.get(self, "vendor_data_file_id")


@pulumi.output_type
class VirtualMachineInitializationDns(dict):
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 server: Optional[str] = None,
                 servers: Optional[Sequence[str]] = None):
        """
        :param str domain: The DNS search domain.
        :param str server: The DNS server. The `server` attribute is
               deprecated and will be removed in a future release. Please use the
               `servers` attribute instead.
        :param Sequence[str] servers: The list of DNS servers.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The DNS search domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    @_utilities.deprecated("""The `server` attribute is deprecated and will be removed in a future release. Please use the `servers` attribute instead.""")
    def server(self) -> Optional[str]:
        """
        The DNS server. The `server` attribute is
        deprecated and will be removed in a future release. Please use the
        `servers` attribute instead.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[str]]:
        """
        The list of DNS servers.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class VirtualMachineInitializationIpConfig(dict):
    def __init__(__self__, *,
                 ipv4: Optional['outputs.VirtualMachineInitializationIpConfigIpv4'] = None,
                 ipv6: Optional['outputs.VirtualMachineInitializationIpConfigIpv6'] = None):
        """
        :param 'VirtualMachineInitializationIpConfigIpv4Args' ipv4: The IPv4 configuration.
        :param 'VirtualMachineInitializationIpConfigIpv6Args' ipv6: The IPv6 configuration.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional['outputs.VirtualMachineInitializationIpConfigIpv4']:
        """
        The IPv4 configuration.
        """
        return pulumi.get(self, "ipv4")

    @property
    @pulumi.getter
    def ipv6(self) -> Optional['outputs.VirtualMachineInitializationIpConfigIpv6']:
        """
        The IPv6 configuration.
        """
        return pulumi.get(self, "ipv6")


@pulumi.output_type
class VirtualMachineInitializationIpConfigIpv4(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 gateway: Optional[str] = None):
        """
        :param str address: The IPv4 address in CIDR notation
               (e.g. 192.168.2.2/24). Alternatively, set this to `dhcp` for
               autodiscovery.
        :param str gateway: The IPv4 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IPv4 address in CIDR notation
        (e.g. 192.168.2.2/24). Alternatively, set this to `dhcp` for
        autodiscovery.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The IPv4 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class VirtualMachineInitializationIpConfigIpv6(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 gateway: Optional[str] = None):
        """
        :param str address: The IPv6 address in CIDR notation
               (e.g. fd1c:000:0000::0000:000:7334/64). Alternatively, set this
               to `dhcp` for autodiscovery.
        :param str gateway: The IPv6 gateway (must be omitted
               when `dhcp` is used as the address).
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IPv6 address in CIDR notation
        (e.g. fd1c:000:0000::0000:000:7334/64). Alternatively, set this
        to `dhcp` for autodiscovery.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The IPv6 gateway (must be omitted
        when `dhcp` is used as the address).
        """
        return pulumi.get(self, "gateway")


@pulumi.output_type
class VirtualMachineInitializationUserAccount(dict):
    def __init__(__self__, *,
                 keys: Optional[Sequence[str]] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param Sequence[str] keys: The SSH keys.
        :param str password: The SSH password.
        :param str username: The SSH username.
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def keys(self) -> Optional[Sequence[str]]:
        """
        The SSH keys.
        """
        return pulumi.get(self, "keys")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The SSH password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The SSH username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VirtualMachineMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepHugepages":
            suggest = "keep_hugepages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dedicated: Optional[int] = None,
                 floating: Optional[int] = None,
                 hugepages: Optional[str] = None,
                 keep_hugepages: Optional[bool] = None,
                 shared: Optional[int] = None):
        """
        :param int dedicated: The dedicated memory in megabytes (defaults to `512`).
        :param int floating: The floating memory in megabytes. The default is `0`, which disables "ballooning device" for the VM.
               Please note that Proxmox has ballooning enabled by default. To enable it, set `floating` to the same value as `dedicated`.
               See [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_memory) section 10.2.6 for more information.
        :param str hugepages: Enable/disable hugepages memory (defaults to disable).
        :param bool keep_hugepages: Keep hugepages memory after the VM is stopped (defaults to `false`).
               
               Settings `hugepages` and `keep_hugepages` are only allowed for `root@pam` authenticated user.
               And required `cpu.numa` to be enabled.
        :param int shared: The shared memory in megabytes (defaults to `0`).
        """
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if floating is not None:
            pulumi.set(__self__, "floating", floating)
        if hugepages is not None:
            pulumi.set(__self__, "hugepages", hugepages)
        if keep_hugepages is not None:
            pulumi.set(__self__, "keep_hugepages", keep_hugepages)
        if shared is not None:
            pulumi.set(__self__, "shared", shared)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[int]:
        """
        The dedicated memory in megabytes (defaults to `512`).
        """
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def floating(self) -> Optional[int]:
        """
        The floating memory in megabytes. The default is `0`, which disables "ballooning device" for the VM.
        Please note that Proxmox has ballooning enabled by default. To enable it, set `floating` to the same value as `dedicated`.
        See [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_memory) section 10.2.6 for more information.
        """
        return pulumi.get(self, "floating")

    @property
    @pulumi.getter
    def hugepages(self) -> Optional[str]:
        """
        Enable/disable hugepages memory (defaults to disable).
        """
        return pulumi.get(self, "hugepages")

    @property
    @pulumi.getter(name="keepHugepages")
    def keep_hugepages(self) -> Optional[bool]:
        """
        Keep hugepages memory after the VM is stopped (defaults to `false`).

        Settings `hugepages` and `keep_hugepages` are only allowed for `root@pam` authenticated user.
        And required `cpu.numa` to be enabled.
        """
        return pulumi.get(self, "keep_hugepages")

    @property
    @pulumi.getter
    def shared(self) -> Optional[int]:
        """
        The shared memory in megabytes (defaults to `0`).
        """
        return pulumi.get(self, "shared")


@pulumi.output_type
class VirtualMachineNetworkDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddress":
            suggest = "mac_address"
        elif key == "rateLimit":
            suggest = "rate_limit"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineNetworkDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineNetworkDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineNetworkDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bridge: Optional[str] = None,
                 disconnected: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 firewall: Optional[bool] = None,
                 mac_address: Optional[str] = None,
                 model: Optional[str] = None,
                 mtu: Optional[int] = None,
                 queues: Optional[int] = None,
                 rate_limit: Optional[float] = None,
                 trunks: Optional[str] = None,
                 vlan_id: Optional[int] = None):
        """
        :param str bridge: The name of the network bridge (defaults to `vmbr0`).
        :param bool disconnected: Whether to disconnect the network device from the network (defaults to `false`).
        :param bool enabled: Whether to enable the network device (defaults to `true`).
        :param bool firewall: Whether this interface's firewall rules should be used (defaults to `false`).
        :param str mac_address: The MAC address.
        :param str model: The network device model (defaults to `virtio`).
        :param int mtu: Force MTU, for VirtIO only. Set to 1 to use the bridge MTU. Cannot be larger than the bridge MTU.
        :param int queues: The number of queues for VirtIO (1..64).
        :param float rate_limit: The rate limit in megabytes per second.
        :param str trunks: String containing a `;` separated list of VLAN trunks
               ("10;20;30"). Note that the VLAN-aware feature need to be enabled on the PVE
               Linux Bridge to use trunks.
        :param int vlan_id: The VLAN identifier.
        """
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if disconnected is not None:
            pulumi.set(__self__, "disconnected", disconnected)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if firewall is not None:
            pulumi.set(__self__, "firewall", firewall)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if queues is not None:
            pulumi.set(__self__, "queues", queues)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if trunks is not None:
            pulumi.set(__self__, "trunks", trunks)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def bridge(self) -> Optional[str]:
        """
        The name of the network bridge (defaults to `vmbr0`).
        """
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter
    def disconnected(self) -> Optional[bool]:
        """
        Whether to disconnect the network device from the network (defaults to `false`).
        """
        return pulumi.get(self, "disconnected")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable the network device (defaults to `true`).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def firewall(self) -> Optional[bool]:
        """
        Whether this interface's firewall rules should be used (defaults to `false`).
        """
        return pulumi.get(self, "firewall")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        The network device model (defaults to `virtio`).
        """
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        Force MTU, for VirtIO only. Set to 1 to use the bridge MTU. Cannot be larger than the bridge MTU.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def queues(self) -> Optional[int]:
        """
        The number of queues for VirtIO (1..64).
        """
        return pulumi.get(self, "queues")

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[float]:
        """
        The rate limit in megabytes per second.
        """
        return pulumi.get(self, "rate_limit")

    @property
    @pulumi.getter
    def trunks(self) -> Optional[str]:
        """
        String containing a `;` separated list of VLAN trunks
        ("10;20;30"). Note that the VLAN-aware feature need to be enabled on the PVE
        Linux Bridge to use trunks.
        """
        return pulumi.get(self, "trunks")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        The VLAN identifier.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class VirtualMachineNuma(dict):
    def __init__(__self__, *,
                 cpus: str,
                 device: str,
                 memory: int,
                 hostnodes: Optional[str] = None,
                 policy: Optional[str] = None):
        """
        :param str cpus: The CPU cores to assign to the NUMA node (format is `0-7;16-31`).
        :param str device: The NUMA device name for Proxmox, in form
               of `numaX` where `X` is a sequential number from 0 to 7.
        :param int memory: The memory in megabytes to assign to the NUMA node.
        :param str hostnodes: The NUMA host nodes.
        :param str policy: The NUMA policy (defaults to `preferred`).
        """
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "memory", memory)
        if hostnodes is not None:
            pulumi.set(__self__, "hostnodes", hostnodes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def cpus(self) -> str:
        """
        The CPU cores to assign to the NUMA node (format is `0-7;16-31`).
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        The NUMA device name for Proxmox, in form
        of `numaX` where `X` is a sequential number from 0 to 7.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def memory(self) -> int:
        """
        The memory in megabytes to assign to the NUMA node.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def hostnodes(self) -> Optional[str]:
        """
        The NUMA host nodes.
        """
        return pulumi.get(self, "hostnodes")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        The NUMA policy (defaults to `preferred`).
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class VirtualMachineOperatingSystem(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: The type (defaults to `other`).
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type (defaults to `other`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineSerialDevice(dict):
    def __init__(__self__, *,
                 device: Optional[str] = None):
        """
        :param str device: The device (defaults to `socket`).
               - `/dev/*` - A host serial device.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        The device (defaults to `socket`).
        - `/dev/*` - A host serial device.
        """
        return pulumi.get(self, "device")


@pulumi.output_type
class VirtualMachineSmbios(dict):
    def __init__(__self__, *,
                 family: Optional[str] = None,
                 manufacturer: Optional[str] = None,
                 product: Optional[str] = None,
                 serial: Optional[str] = None,
                 sku: Optional[str] = None,
                 uuid: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str family: The family string.
        :param str manufacturer: The manufacturer.
        :param str product: The product ID.
        :param str serial: The serial number.
        :param str sku: The SKU number.
        :param str uuid: The UUID (defaults to randomly generated UUID).
        :param str version: The version.
        """
        if family is not None:
            pulumi.set(__self__, "family", family)
        if manufacturer is not None:
            pulumi.set(__self__, "manufacturer", manufacturer)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if serial is not None:
            pulumi.set(__self__, "serial", serial)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        The family string.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def manufacturer(self) -> Optional[str]:
        """
        The manufacturer.
        """
        return pulumi.get(self, "manufacturer")

    @property
    @pulumi.getter
    def product(self) -> Optional[str]:
        """
        The product ID.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def serial(self) -> Optional[str]:
        """
        The serial number.
        """
        return pulumi.get(self, "serial")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        The SKU number.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        The UUID (defaults to randomly generated UUID).
        """
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VirtualMachineStartup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "downDelay":
            suggest = "down_delay"
        elif key == "upDelay":
            suggest = "up_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineStartup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineStartup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineStartup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 down_delay: Optional[int] = None,
                 order: Optional[int] = None,
                 up_delay: Optional[int] = None):
        """
        :param int down_delay: A non-negative number defining the delay in
               seconds before the next VM is shut down.
        :param int order: A non-negative number defining the general startup
               order.
        :param int up_delay: A non-negative number defining the delay in
               seconds before the next VM is started.
        """
        if down_delay is not None:
            pulumi.set(__self__, "down_delay", down_delay)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if up_delay is not None:
            pulumi.set(__self__, "up_delay", up_delay)

    @property
    @pulumi.getter(name="downDelay")
    def down_delay(self) -> Optional[int]:
        """
        A non-negative number defining the delay in
        seconds before the next VM is shut down.
        """
        return pulumi.get(self, "down_delay")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        A non-negative number defining the general startup
        order.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="upDelay")
    def up_delay(self) -> Optional[int]:
        """
        A non-negative number defining the delay in
        seconds before the next VM is started.
        """
        return pulumi.get(self, "up_delay")


@pulumi.output_type
class VirtualMachineTpmState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreId":
            suggest = "datastore_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineTpmState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineTpmState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineTpmState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str datastore_id: The identifier for the datastore to create
               the disk in (defaults to `local-lvm`).
        :param str version: TPM state device version. Can be `v1.2` or `v2.0`.
               (defaults to `v2.0`).
        """
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The identifier for the datastore to create
        the disk in (defaults to `local-lvm`).
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        TPM state device version. Can be `v1.2` or `v2.0`.
        (defaults to `v2.0`).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VirtualMachineUsb(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 mapping: Optional[str] = None,
                 usb3: Optional[bool] = None):
        """
        :param str host: The Host USB device or port or the value `spice`. Use either this or `mapping`.
        :param str mapping: The cluster-wide resource mapping name of the device, for example "usbdevice". Use either this or `host`.
        :param bool usb3: Makes the USB device a USB3 device for the VM
               (defaults to `false`).
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if mapping is not None:
            pulumi.set(__self__, "mapping", mapping)
        if usb3 is not None:
            pulumi.set(__self__, "usb3", usb3)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The Host USB device or port or the value `spice`. Use either this or `mapping`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def mapping(self) -> Optional[str]:
        """
        The cluster-wide resource mapping name of the device, for example "usbdevice". Use either this or `host`.
        """
        return pulumi.get(self, "mapping")

    @property
    @pulumi.getter
    def usb3(self) -> Optional[bool]:
        """
        Makes the USB device a USB3 device for the VM
        (defaults to `false`).
        """
        return pulumi.get(self, "usb3")


@pulumi.output_type
class VirtualMachineVga(dict):
    def __init__(__self__, *,
                 clipboard: Optional[str] = None,
                 memory: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param str clipboard: Enable VNC clipboard by setting to `vnc`. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
        :param int memory: The VGA memory in megabytes (defaults to `16`).
        :param str type: The VGA type (defaults to `std`).
        """
        if clipboard is not None:
            pulumi.set(__self__, "clipboard", clipboard)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> Optional[str]:
        """
        Enable VNC clipboard by setting to `vnc`. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information.
        """
        return pulumi.get(self, "clipboard")

    @property
    @pulumi.getter
    def memory(self) -> Optional[int]:
        """
        The VGA memory in megabytes (defaults to `16`).
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineWatchdog(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 model: Optional[str] = None):
        """
        :param str action: The action to perform if after activation the guest fails to poll the watchdog in time  (defaults to `none`).
        :param bool enabled: Whether the watchdog is enabled (defaults to `false`).
        :param str model: The watchdog type to emulate (defaults to `i6300esb`).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        The action to perform if after activation the guest fails to poll the watchdog in time  (defaults to `none`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the watchdog is enabled (defaults to `false`).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        The watchdog type to emulate (defaults to `i6300esb`).
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class GetVirtualMachinesFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the VM attribute to filter on. One of [`name`, `template`, `status`, `node_name`]
        :param Sequence[str] values: List of values to pass the filter. VM's attribute should match at least one value in the list.
        :param bool regex: Treat values as regex patterns
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the VM attribute to filter on. One of [`name`, `template`, `status`, `node_name`]
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of values to pass the filter. VM's attribute should match at least one value in the list.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        """
        Treat values as regex patterns
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetVirtualMachinesVmResult(dict):
    def __init__(__self__, *,
                 name: str,
                 node_name: str,
                 tags: Sequence[str],
                 vm_id: int,
                 status: Optional[str] = None,
                 template: Optional[bool] = None):
        """
        :param str name: The virtual machine name.
        :param str node_name: The node name. All cluster nodes will be queried in case this is omitted
        :param Sequence[str] tags: A list of tags to filter the VMs. The VM must have all
               the tags to be included in the result.
        :param int vm_id: The VM identifier.
        :param str status: Status of the VM
        :param bool template: Is VM a template (true) or a regular VM (false)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vm_id", vm_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The virtual machine name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> str:
        """
        The node name. All cluster nodes will be queried in case this is omitted
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        A list of tags to filter the VMs. The VM must have all
        the tags to be included in the result.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> int:
        """
        The VM identifier.
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the VM
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def template(self) -> Optional[bool]:
        """
        Is VM a template (true) or a regular VM (false)
        """
        return pulumi.get(self, "template")


