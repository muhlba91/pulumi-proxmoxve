# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ClonedVirtualMachineArgs', 'ClonedVirtualMachine']

@pulumi.input_type
class ClonedVirtualMachineArgs:
    def __init__(__self__, *,
                 clone: pulumi.Input['ClonedVirtualMachineCloneArgs'],
                 node_name: pulumi.Input[_builtins.str],
                 cdrom: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]] = None,
                 cpu: Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']] = None,
                 delete: Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']] = None,
                 delete_unreferenced_disks_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disk: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]] = None,
                 memory: Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]] = None,
                 purge_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 rng: Optional[pulumi.Input['ClonedVirtualMachineRngArgs']] = None,
                 stop_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 timeouts: Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']] = None,
                 vga: Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']] = None,
                 vm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a ClonedVirtualMachine resource.
        :param pulumi.Input['ClonedVirtualMachineCloneArgs'] clone: Clone settings. Changes require recreation.
        :param pulumi.Input[_builtins.str] node_name: Target node for the cloned VM.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]] cdrom: The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        :param pulumi.Input['ClonedVirtualMachineCpuArgs'] cpu: The CPU configuration.
        :param pulumi.Input['ClonedVirtualMachineDeleteArgs'] delete: Explicit deletions to perform after cloning/updating. Entries persist across applies.
        :param pulumi.Input[_builtins.str] description: Optional VM description applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]] disk: Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        :param pulumi.Input['ClonedVirtualMachineMemoryArgs'] memory: Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        :param pulumi.Input[_builtins.str] name: Optional VM name override applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]] network: Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        :param pulumi.Input[_builtins.bool] purge_on_destroy: Purge backup configuration on destroy.
        :param pulumi.Input['ClonedVirtualMachineRngArgs'] rng: Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        :param pulumi.Input[_builtins.bool] stop_on_destroy: Stop the VM on destroy (instead of shutdown).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tags applied after cloning.
        :param pulumi.Input['ClonedVirtualMachineVgaArgs'] vga: Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        :param pulumi.Input[_builtins.str] vm_id: The VM identifier in the Proxmox cluster.
        """
        pulumi.set(__self__, "clone", clone)
        pulumi.set(__self__, "node_name", node_name)
        if cdrom is not None:
            pulumi.set(__self__, "cdrom", cdrom)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if delete_unreferenced_disks_on_destroy is not None:
            pulumi.set(__self__, "delete_unreferenced_disks_on_destroy", delete_unreferenced_disks_on_destroy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if purge_on_destroy is not None:
            pulumi.set(__self__, "purge_on_destroy", purge_on_destroy)
        if rng is not None:
            pulumi.set(__self__, "rng", rng)
        if stop_on_destroy is not None:
            pulumi.set(__self__, "stop_on_destroy", stop_on_destroy)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)
        if vga is not None:
            pulumi.set(__self__, "vga", vga)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)

    @_builtins.property
    @pulumi.getter
    def clone(self) -> pulumi.Input['ClonedVirtualMachineCloneArgs']:
        """
        Clone settings. Changes require recreation.
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: pulumi.Input['ClonedVirtualMachineCloneArgs']):
        pulumi.set(self, "clone", value)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> pulumi.Input[_builtins.str]:
        """
        Target node for the cloned VM.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_name", value)

    @_builtins.property
    @pulumi.getter
    def cdrom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]]:
        """
        The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        """
        return pulumi.get(self, "cdrom")

    @cdrom.setter
    def cdrom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]]):
        pulumi.set(self, "cdrom", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']]:
        """
        The CPU configuration.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']]:
        """
        Explicit deletions to perform after cloning/updating. Entries persist across applies.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter(name="deleteUnreferencedDisksOnDestroy")
    def delete_unreferenced_disks_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "delete_unreferenced_disks_on_destroy")

    @delete_unreferenced_disks_on_destroy.setter
    def delete_unreferenced_disks_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_unreferenced_disks_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional VM description applied after cloning.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]]:
        """
        Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]]):
        pulumi.set(self, "disk", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']]:
        """
        Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional VM name override applied after cloning.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]]:
        """
        Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="purgeOnDestroy")
    def purge_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Purge backup configuration on destroy.
        """
        return pulumi.get(self, "purge_on_destroy")

    @purge_on_destroy.setter
    def purge_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "purge_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def rng(self) -> Optional[pulumi.Input['ClonedVirtualMachineRngArgs']]:
        """
        Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        """
        return pulumi.get(self, "rng")

    @rng.setter
    def rng(self, value: Optional[pulumi.Input['ClonedVirtualMachineRngArgs']]):
        pulumi.set(self, "rng", value)

    @_builtins.property
    @pulumi.getter(name="stopOnDestroy")
    def stop_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Stop the VM on destroy (instead of shutdown).
        """
        return pulumi.get(self, "stop_on_destroy")

    @stop_on_destroy.setter
    def stop_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stop_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tags applied after cloning.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']]):
        pulumi.set(self, "timeouts", value)

    @_builtins.property
    @pulumi.getter
    def vga(self) -> Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']]:
        """
        Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        """
        return pulumi.get(self, "vga")

    @vga.setter
    def vga(self, value: Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']]):
        pulumi.set(self, "vga", value)

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VM identifier in the Proxmox cluster.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_id", value)


@pulumi.input_type
class _ClonedVirtualMachineState:
    def __init__(__self__, *,
                 cdrom: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]] = None,
                 clone: Optional[pulumi.Input['ClonedVirtualMachineCloneArgs']] = None,
                 cpu: Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']] = None,
                 delete: Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']] = None,
                 delete_unreferenced_disks_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disk: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]] = None,
                 memory: Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]] = None,
                 node_name: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 rng: Optional[pulumi.Input['ClonedVirtualMachineRngArgs']] = None,
                 stop_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 timeouts: Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']] = None,
                 vga: Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']] = None,
                 vm_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering ClonedVirtualMachine resources.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]] cdrom: The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        :param pulumi.Input['ClonedVirtualMachineCloneArgs'] clone: Clone settings. Changes require recreation.
        :param pulumi.Input['ClonedVirtualMachineCpuArgs'] cpu: The CPU configuration.
        :param pulumi.Input['ClonedVirtualMachineDeleteArgs'] delete: Explicit deletions to perform after cloning/updating. Entries persist across applies.
        :param pulumi.Input[_builtins.str] description: Optional VM description applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]] disk: Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        :param pulumi.Input['ClonedVirtualMachineMemoryArgs'] memory: Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        :param pulumi.Input[_builtins.str] name: Optional VM name override applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]] network: Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        :param pulumi.Input[_builtins.str] node_name: Target node for the cloned VM.
        :param pulumi.Input[_builtins.bool] purge_on_destroy: Purge backup configuration on destroy.
        :param pulumi.Input['ClonedVirtualMachineRngArgs'] rng: Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        :param pulumi.Input[_builtins.bool] stop_on_destroy: Stop the VM on destroy (instead of shutdown).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tags applied after cloning.
        :param pulumi.Input['ClonedVirtualMachineVgaArgs'] vga: Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        :param pulumi.Input[_builtins.str] vm_id: The VM identifier in the Proxmox cluster.
        """
        if cdrom is not None:
            pulumi.set(__self__, "cdrom", cdrom)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if delete_unreferenced_disks_on_destroy is not None:
            pulumi.set(__self__, "delete_unreferenced_disks_on_destroy", delete_unreferenced_disks_on_destroy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if purge_on_destroy is not None:
            pulumi.set(__self__, "purge_on_destroy", purge_on_destroy)
        if rng is not None:
            pulumi.set(__self__, "rng", rng)
        if stop_on_destroy is not None:
            pulumi.set(__self__, "stop_on_destroy", stop_on_destroy)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)
        if vga is not None:
            pulumi.set(__self__, "vga", vga)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)

    @_builtins.property
    @pulumi.getter
    def cdrom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]]:
        """
        The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        """
        return pulumi.get(self, "cdrom")

    @cdrom.setter
    def cdrom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineCdromArgs']]]]):
        pulumi.set(self, "cdrom", value)

    @_builtins.property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input['ClonedVirtualMachineCloneArgs']]:
        """
        Clone settings. Changes require recreation.
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input['ClonedVirtualMachineCloneArgs']]):
        pulumi.set(self, "clone", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']]:
        """
        The CPU configuration.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['ClonedVirtualMachineCpuArgs']]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']]:
        """
        Explicit deletions to perform after cloning/updating. Entries persist across applies.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['ClonedVirtualMachineDeleteArgs']]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter(name="deleteUnreferencedDisksOnDestroy")
    def delete_unreferenced_disks_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "delete_unreferenced_disks_on_destroy")

    @delete_unreferenced_disks_on_destroy.setter
    def delete_unreferenced_disks_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_unreferenced_disks_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional VM description applied after cloning.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]]:
        """
        Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineDiskArgs']]]]):
        pulumi.set(self, "disk", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']]:
        """
        Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input['ClonedVirtualMachineMemoryArgs']]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional VM name override applied after cloning.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]]:
        """
        Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ClonedVirtualMachineNetworkArgs']]]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Target node for the cloned VM.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_name", value)

    @_builtins.property
    @pulumi.getter(name="purgeOnDestroy")
    def purge_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Purge backup configuration on destroy.
        """
        return pulumi.get(self, "purge_on_destroy")

    @purge_on_destroy.setter
    def purge_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "purge_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def rng(self) -> Optional[pulumi.Input['ClonedVirtualMachineRngArgs']]:
        """
        Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        """
        return pulumi.get(self, "rng")

    @rng.setter
    def rng(self, value: Optional[pulumi.Input['ClonedVirtualMachineRngArgs']]):
        pulumi.set(self, "rng", value)

    @_builtins.property
    @pulumi.getter(name="stopOnDestroy")
    def stop_on_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Stop the VM on destroy (instead of shutdown).
        """
        return pulumi.get(self, "stop_on_destroy")

    @stop_on_destroy.setter
    def stop_on_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stop_on_destroy", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Tags applied after cloning.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['ClonedVirtualMachineTimeoutsArgs']]):
        pulumi.set(self, "timeouts", value)

    @_builtins.property
    @pulumi.getter
    def vga(self) -> Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']]:
        """
        Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        """
        return pulumi.get(self, "vga")

    @vga.setter
    def vga(self, value: Optional[pulumi.Input['ClonedVirtualMachineVgaArgs']]):
        pulumi.set(self, "vga", value)

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VM identifier in the Proxmox cluster.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vm_id", value)


@pulumi.type_token("proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine")
class ClonedVirtualMachine(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cdrom: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineCdromArgs', 'ClonedVirtualMachineCdromArgsDict']]]]] = None,
                 clone: Optional[pulumi.Input[Union['ClonedVirtualMachineCloneArgs', 'ClonedVirtualMachineCloneArgsDict']]] = None,
                 cpu: Optional[pulumi.Input[Union['ClonedVirtualMachineCpuArgs', 'ClonedVirtualMachineCpuArgsDict']]] = None,
                 delete: Optional[pulumi.Input[Union['ClonedVirtualMachineDeleteArgs', 'ClonedVirtualMachineDeleteArgsDict']]] = None,
                 delete_unreferenced_disks_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disk: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineDiskArgs', 'ClonedVirtualMachineDiskArgsDict']]]]] = None,
                 memory: Optional[pulumi.Input[Union['ClonedVirtualMachineMemoryArgs', 'ClonedVirtualMachineMemoryArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineNetworkArgs', 'ClonedVirtualMachineNetworkArgsDict']]]]] = None,
                 node_name: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 rng: Optional[pulumi.Input[Union['ClonedVirtualMachineRngArgs', 'ClonedVirtualMachineRngArgsDict']]] = None,
                 stop_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 timeouts: Optional[pulumi.Input[Union['ClonedVirtualMachineTimeoutsArgs', 'ClonedVirtualMachineTimeoutsArgsDict']]] = None,
                 vga: Optional[pulumi.Input[Union['ClonedVirtualMachineVgaArgs', 'ClonedVirtualMachineVgaArgsDict']]] = None,
                 vm_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_proxmoxve as proxmoxve

        # Example 1: Basic clone with minimal management
        basic_clone = proxmoxve.vm.ClonedVirtualMachine("basic_clone",
            node_name="pve",
            name="basic-clone",
            clone={
                "source_vm_id": 100,
                "full": True,
            },
            cpu={
                "cores": 4,
            })
        # Example 2: Clone with explicit network management
        network_managed = proxmoxve.vm.ClonedVirtualMachine("network_managed",
            node_name="pve",
            name="network-clone",
            clone={
                "source_vm_id": 100,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                    "tag": 100,
                },
                "net1": {
                    "bridge": "vmbr1",
                    "model": "virtio",
                    "firewall": True,
                    "mac_address": "BC:24:11:2E:C5:00",
                },
            },
            cpu={
                "cores": 2,
            })
        # Example 3: Clone with disk management
        disk_managed = proxmoxve.vm.ClonedVirtualMachine("disk_managed",
            node_name="pve",
            name="disk-clone",
            clone={
                "source_vm_id": 100,
                "target_datastore": "local-lvm",
            },
            disk={
                "scsi0": {
                    "datastore_id": "local-lvm",
                    "size_gb": 50,
                    "discard": "on",
                    "ssd": True,
                },
                "scsi1": {
                    "datastore_id": "local-lvm",
                    "size_gb": 100,
                    "backup": False,
                },
            })
        # Example 4: Clone with explicit device deletion
        selective_delete = proxmoxve.vm.ClonedVirtualMachine("selective_delete",
            node_name="pve",
            name="minimal-clone",
            clone={
                "source_vm_id": 100,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                },
            },
            delete={
                "networks": [
                    "net1",
                    "net2",
                ],
            })
        # Example 5: Full-featured clone with multiple settings
        full_featured = proxmoxve.vm.ClonedVirtualMachine("full_featured",
            node_name="pve",
            name="production-vm",
            description="Production VM cloned from template",
            tags=[
                "production",
                "web",
            ],
            clone={
                "source_vm_id": 100,
                "source_node_name": "pve",
                "full": True,
                "target_datastore": "local-lvm",
                "retries": 3,
            },
            cpu={
                "cores": 8,
                "sockets": 1,
                "architecture": "x86_64",
                "type": "host",
            },
            memory={
                "size": 8192,
                "balloon": 2048,
                "shares": 2000,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                    "tag": 100,
                    "firewall": True,
                    "rate_limit": 100,
                },
            },
            disk={
                "scsi0": {
                    "datastore_id": "local-lvm",
                    "size_gb": 100,
                    "discard": "on",
                    "iothread": True,
                    "ssd": True,
                    "cache": "writethrough",
                },
            },
            vga={
                "type": "std",
                "memory": 16,
            },
            delete={
                "disks": ["ide2"],
            },
            stop_on_destroy=False,
            purge_on_destroy=True,
            delete_unreferenced_disks_on_destroy=False,
            timeouts={
                "create": "30m",
                "update": "30m",
                "delete": "10m",
            })
        # Example 6: Linked clone for testing
        test_clone = proxmoxve.vm.ClonedVirtualMachine("test_clone",
            node_name="pve",
            name="test-vm",
            clone={
                "source_vm_id": 100,
                "full": False,
            },
            cpu={
                "cores": 2,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                },
            })
        # Example 7: Clone with pool assignment
        pooled_clone = proxmoxve.vm.ClonedVirtualMachine("pooled_clone",
            node_name="pve",
            name="pooled-vm",
            clone={
                "source_vm_id": 100,
                "pool_id": "production",
            },
            cpu={
                "cores": 4,
            })
        # Example 8: Import existing cloned VM
        imported = proxmoxve.vm.ClonedVirtualMachine("imported",
            vm_id="123",
            node_name="pve",
            clone={
                "source_vm_id": 100,
            },
            cpu={
                "cores": 4,
            })
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineCdromArgs', 'ClonedVirtualMachineCdromArgsDict']]]] cdrom: The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        :param pulumi.Input[Union['ClonedVirtualMachineCloneArgs', 'ClonedVirtualMachineCloneArgsDict']] clone: Clone settings. Changes require recreation.
        :param pulumi.Input[Union['ClonedVirtualMachineCpuArgs', 'ClonedVirtualMachineCpuArgsDict']] cpu: The CPU configuration.
        :param pulumi.Input[Union['ClonedVirtualMachineDeleteArgs', 'ClonedVirtualMachineDeleteArgsDict']] delete: Explicit deletions to perform after cloning/updating. Entries persist across applies.
        :param pulumi.Input[_builtins.str] description: Optional VM description applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineDiskArgs', 'ClonedVirtualMachineDiskArgsDict']]]] disk: Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        :param pulumi.Input[Union['ClonedVirtualMachineMemoryArgs', 'ClonedVirtualMachineMemoryArgsDict']] memory: Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        :param pulumi.Input[_builtins.str] name: Optional VM name override applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineNetworkArgs', 'ClonedVirtualMachineNetworkArgsDict']]]] network: Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        :param pulumi.Input[_builtins.str] node_name: Target node for the cloned VM.
        :param pulumi.Input[_builtins.bool] purge_on_destroy: Purge backup configuration on destroy.
        :param pulumi.Input[Union['ClonedVirtualMachineRngArgs', 'ClonedVirtualMachineRngArgsDict']] rng: Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        :param pulumi.Input[_builtins.bool] stop_on_destroy: Stop the VM on destroy (instead of shutdown).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tags applied after cloning.
        :param pulumi.Input[Union['ClonedVirtualMachineVgaArgs', 'ClonedVirtualMachineVgaArgsDict']] vga: Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        :param pulumi.Input[_builtins.str] vm_id: The VM identifier in the Proxmox cluster.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ClonedVirtualMachineArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_proxmoxve as proxmoxve

        # Example 1: Basic clone with minimal management
        basic_clone = proxmoxve.vm.ClonedVirtualMachine("basic_clone",
            node_name="pve",
            name="basic-clone",
            clone={
                "source_vm_id": 100,
                "full": True,
            },
            cpu={
                "cores": 4,
            })
        # Example 2: Clone with explicit network management
        network_managed = proxmoxve.vm.ClonedVirtualMachine("network_managed",
            node_name="pve",
            name="network-clone",
            clone={
                "source_vm_id": 100,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                    "tag": 100,
                },
                "net1": {
                    "bridge": "vmbr1",
                    "model": "virtio",
                    "firewall": True,
                    "mac_address": "BC:24:11:2E:C5:00",
                },
            },
            cpu={
                "cores": 2,
            })
        # Example 3: Clone with disk management
        disk_managed = proxmoxve.vm.ClonedVirtualMachine("disk_managed",
            node_name="pve",
            name="disk-clone",
            clone={
                "source_vm_id": 100,
                "target_datastore": "local-lvm",
            },
            disk={
                "scsi0": {
                    "datastore_id": "local-lvm",
                    "size_gb": 50,
                    "discard": "on",
                    "ssd": True,
                },
                "scsi1": {
                    "datastore_id": "local-lvm",
                    "size_gb": 100,
                    "backup": False,
                },
            })
        # Example 4: Clone with explicit device deletion
        selective_delete = proxmoxve.vm.ClonedVirtualMachine("selective_delete",
            node_name="pve",
            name="minimal-clone",
            clone={
                "source_vm_id": 100,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                },
            },
            delete={
                "networks": [
                    "net1",
                    "net2",
                ],
            })
        # Example 5: Full-featured clone with multiple settings
        full_featured = proxmoxve.vm.ClonedVirtualMachine("full_featured",
            node_name="pve",
            name="production-vm",
            description="Production VM cloned from template",
            tags=[
                "production",
                "web",
            ],
            clone={
                "source_vm_id": 100,
                "source_node_name": "pve",
                "full": True,
                "target_datastore": "local-lvm",
                "retries": 3,
            },
            cpu={
                "cores": 8,
                "sockets": 1,
                "architecture": "x86_64",
                "type": "host",
            },
            memory={
                "size": 8192,
                "balloon": 2048,
                "shares": 2000,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                    "tag": 100,
                    "firewall": True,
                    "rate_limit": 100,
                },
            },
            disk={
                "scsi0": {
                    "datastore_id": "local-lvm",
                    "size_gb": 100,
                    "discard": "on",
                    "iothread": True,
                    "ssd": True,
                    "cache": "writethrough",
                },
            },
            vga={
                "type": "std",
                "memory": 16,
            },
            delete={
                "disks": ["ide2"],
            },
            stop_on_destroy=False,
            purge_on_destroy=True,
            delete_unreferenced_disks_on_destroy=False,
            timeouts={
                "create": "30m",
                "update": "30m",
                "delete": "10m",
            })
        # Example 6: Linked clone for testing
        test_clone = proxmoxve.vm.ClonedVirtualMachine("test_clone",
            node_name="pve",
            name="test-vm",
            clone={
                "source_vm_id": 100,
                "full": False,
            },
            cpu={
                "cores": 2,
            },
            network={
                "net0": {
                    "bridge": "vmbr0",
                    "model": "virtio",
                },
            })
        # Example 7: Clone with pool assignment
        pooled_clone = proxmoxve.vm.ClonedVirtualMachine("pooled_clone",
            node_name="pve",
            name="pooled-vm",
            clone={
                "source_vm_id": 100,
                "pool_id": "production",
            },
            cpu={
                "cores": 4,
            })
        # Example 8: Import existing cloned VM
        imported = proxmoxve.vm.ClonedVirtualMachine("imported",
            vm_id="123",
            node_name="pve",
            clone={
                "source_vm_id": 100,
            },
            cpu={
                "cores": 4,
            })
        ```

        :param str resource_name: The name of the resource.
        :param ClonedVirtualMachineArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ClonedVirtualMachineArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cdrom: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineCdromArgs', 'ClonedVirtualMachineCdromArgsDict']]]]] = None,
                 clone: Optional[pulumi.Input[Union['ClonedVirtualMachineCloneArgs', 'ClonedVirtualMachineCloneArgsDict']]] = None,
                 cpu: Optional[pulumi.Input[Union['ClonedVirtualMachineCpuArgs', 'ClonedVirtualMachineCpuArgsDict']]] = None,
                 delete: Optional[pulumi.Input[Union['ClonedVirtualMachineDeleteArgs', 'ClonedVirtualMachineDeleteArgsDict']]] = None,
                 delete_unreferenced_disks_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disk: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineDiskArgs', 'ClonedVirtualMachineDiskArgsDict']]]]] = None,
                 memory: Optional[pulumi.Input[Union['ClonedVirtualMachineMemoryArgs', 'ClonedVirtualMachineMemoryArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineNetworkArgs', 'ClonedVirtualMachineNetworkArgsDict']]]]] = None,
                 node_name: Optional[pulumi.Input[_builtins.str]] = None,
                 purge_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 rng: Optional[pulumi.Input[Union['ClonedVirtualMachineRngArgs', 'ClonedVirtualMachineRngArgsDict']]] = None,
                 stop_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 timeouts: Optional[pulumi.Input[Union['ClonedVirtualMachineTimeoutsArgs', 'ClonedVirtualMachineTimeoutsArgsDict']]] = None,
                 vga: Optional[pulumi.Input[Union['ClonedVirtualMachineVgaArgs', 'ClonedVirtualMachineVgaArgsDict']]] = None,
                 vm_id: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ClonedVirtualMachineArgs.__new__(ClonedVirtualMachineArgs)

            __props__.__dict__["cdrom"] = cdrom
            if clone is None and not opts.urn:
                raise TypeError("Missing required property 'clone'")
            __props__.__dict__["clone"] = clone
            __props__.__dict__["cpu"] = cpu
            __props__.__dict__["delete"] = delete
            __props__.__dict__["delete_unreferenced_disks_on_destroy"] = delete_unreferenced_disks_on_destroy
            __props__.__dict__["description"] = description
            __props__.__dict__["disk"] = disk
            __props__.__dict__["memory"] = memory
            __props__.__dict__["name"] = name
            __props__.__dict__["network"] = network
            if node_name is None and not opts.urn:
                raise TypeError("Missing required property 'node_name'")
            __props__.__dict__["node_name"] = node_name
            __props__.__dict__["purge_on_destroy"] = purge_on_destroy
            __props__.__dict__["rng"] = rng
            __props__.__dict__["stop_on_destroy"] = stop_on_destroy
            __props__.__dict__["tags"] = tags
            __props__.__dict__["timeouts"] = timeouts
            __props__.__dict__["vga"] = vga
            __props__.__dict__["vm_id"] = vm_id
        super(ClonedVirtualMachine, __self__).__init__(
            'proxmoxve:VM/clonedVirtualMachine:ClonedVirtualMachine',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            cdrom: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineCdromArgs', 'ClonedVirtualMachineCdromArgsDict']]]]] = None,
            clone: Optional[pulumi.Input[Union['ClonedVirtualMachineCloneArgs', 'ClonedVirtualMachineCloneArgsDict']]] = None,
            cpu: Optional[pulumi.Input[Union['ClonedVirtualMachineCpuArgs', 'ClonedVirtualMachineCpuArgsDict']]] = None,
            delete: Optional[pulumi.Input[Union['ClonedVirtualMachineDeleteArgs', 'ClonedVirtualMachineDeleteArgsDict']]] = None,
            delete_unreferenced_disks_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            disk: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineDiskArgs', 'ClonedVirtualMachineDiskArgsDict']]]]] = None,
            memory: Optional[pulumi.Input[Union['ClonedVirtualMachineMemoryArgs', 'ClonedVirtualMachineMemoryArgsDict']]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            network: Optional[pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineNetworkArgs', 'ClonedVirtualMachineNetworkArgsDict']]]]] = None,
            node_name: Optional[pulumi.Input[_builtins.str]] = None,
            purge_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
            rng: Optional[pulumi.Input[Union['ClonedVirtualMachineRngArgs', 'ClonedVirtualMachineRngArgsDict']]] = None,
            stop_on_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            timeouts: Optional[pulumi.Input[Union['ClonedVirtualMachineTimeoutsArgs', 'ClonedVirtualMachineTimeoutsArgsDict']]] = None,
            vga: Optional[pulumi.Input[Union['ClonedVirtualMachineVgaArgs', 'ClonedVirtualMachineVgaArgsDict']]] = None,
            vm_id: Optional[pulumi.Input[_builtins.str]] = None) -> 'ClonedVirtualMachine':
        """
        Get an existing ClonedVirtualMachine resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineCdromArgs', 'ClonedVirtualMachineCdromArgsDict']]]] cdrom: The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        :param pulumi.Input[Union['ClonedVirtualMachineCloneArgs', 'ClonedVirtualMachineCloneArgsDict']] clone: Clone settings. Changes require recreation.
        :param pulumi.Input[Union['ClonedVirtualMachineCpuArgs', 'ClonedVirtualMachineCpuArgsDict']] cpu: The CPU configuration.
        :param pulumi.Input[Union['ClonedVirtualMachineDeleteArgs', 'ClonedVirtualMachineDeleteArgsDict']] delete: Explicit deletions to perform after cloning/updating. Entries persist across applies.
        :param pulumi.Input[_builtins.str] description: Optional VM description applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineDiskArgs', 'ClonedVirtualMachineDiskArgsDict']]]] disk: Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        :param pulumi.Input[Union['ClonedVirtualMachineMemoryArgs', 'ClonedVirtualMachineMemoryArgsDict']] memory: Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        :param pulumi.Input[_builtins.str] name: Optional VM name override applied after cloning.
        :param pulumi.Input[Mapping[str, pulumi.Input[Union['ClonedVirtualMachineNetworkArgs', 'ClonedVirtualMachineNetworkArgsDict']]]] network: Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        :param pulumi.Input[_builtins.str] node_name: Target node for the cloned VM.
        :param pulumi.Input[_builtins.bool] purge_on_destroy: Purge backup configuration on destroy.
        :param pulumi.Input[Union['ClonedVirtualMachineRngArgs', 'ClonedVirtualMachineRngArgsDict']] rng: Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        :param pulumi.Input[_builtins.bool] stop_on_destroy: Stop the VM on destroy (instead of shutdown).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: Tags applied after cloning.
        :param pulumi.Input[Union['ClonedVirtualMachineVgaArgs', 'ClonedVirtualMachineVgaArgsDict']] vga: Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        :param pulumi.Input[_builtins.str] vm_id: The VM identifier in the Proxmox cluster.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ClonedVirtualMachineState.__new__(_ClonedVirtualMachineState)

        __props__.__dict__["cdrom"] = cdrom
        __props__.__dict__["clone"] = clone
        __props__.__dict__["cpu"] = cpu
        __props__.__dict__["delete"] = delete
        __props__.__dict__["delete_unreferenced_disks_on_destroy"] = delete_unreferenced_disks_on_destroy
        __props__.__dict__["description"] = description
        __props__.__dict__["disk"] = disk
        __props__.__dict__["memory"] = memory
        __props__.__dict__["name"] = name
        __props__.__dict__["network"] = network
        __props__.__dict__["node_name"] = node_name
        __props__.__dict__["purge_on_destroy"] = purge_on_destroy
        __props__.__dict__["rng"] = rng
        __props__.__dict__["stop_on_destroy"] = stop_on_destroy
        __props__.__dict__["tags"] = tags
        __props__.__dict__["timeouts"] = timeouts
        __props__.__dict__["vga"] = vga
        __props__.__dict__["vm_id"] = vm_id
        return ClonedVirtualMachine(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def cdrom(self) -> pulumi.Output[Optional[Mapping[str, 'outputs.ClonedVirtualMachineCdrom']]]:
        """
        The CD-ROM configuration. The key is the interface of the CD-ROM, could be one of `ideN`, `sataN`, `scsiN`, where N is the index of the interface. Note that `q35` machine type only supports `ide0` and `ide2` of IDE interfaces.
        """
        return pulumi.get(self, "cdrom")

    @_builtins.property
    @pulumi.getter
    def clone(self) -> pulumi.Output['outputs.ClonedVirtualMachineClone']:
        """
        Clone settings. Changes require recreation.
        """
        return pulumi.get(self, "clone")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineCpu']]:
        """
        The CPU configuration.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineDelete']]:
        """
        Explicit deletions to perform after cloning/updating. Entries persist across applies.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter(name="deleteUnreferencedDisksOnDestroy")
    def delete_unreferenced_disks_on_destroy(self) -> pulumi.Output[_builtins.bool]:
        return pulumi.get(self, "delete_unreferenced_disks_on_destroy")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Optional VM description applied after cloning.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> pulumi.Output[Optional[Mapping[str, 'outputs.ClonedVirtualMachineDisk']]]:
        """
        Disks keyed by slot (scsi0, virtio0, sata0, ide0, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineMemory']]:
        """
        Memory configuration for the VM. Uses Proxmox memory ballooning to allow dynamic memory allocation. The `size` sets the total available RAM, while `balloon` sets the guaranteed floor. The host can reclaim memory between these values when needed.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Optional VM name override applied after cloning.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Output[Optional[Mapping[str, 'outputs.ClonedVirtualMachineNetwork']]]:
        """
        Network devices keyed by slot (net0, net1, ...). Only listed keys are managed.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> pulumi.Output[_builtins.str]:
        """
        Target node for the cloned VM.
        """
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter(name="purgeOnDestroy")
    def purge_on_destroy(self) -> pulumi.Output[_builtins.bool]:
        """
        Purge backup configuration on destroy.
        """
        return pulumi.get(self, "purge_on_destroy")

    @_builtins.property
    @pulumi.getter
    def rng(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineRng']]:
        """
        Configure the RNG (Random Number Generator) device. The RNG device provides entropy to guests to ensure good quality random numbers for guest applications that require them. Can only be set by `root@pam.` See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) for more information.
        """
        return pulumi.get(self, "rng")

    @_builtins.property
    @pulumi.getter(name="stopOnDestroy")
    def stop_on_destroy(self) -> pulumi.Output[_builtins.bool]:
        """
        Stop the VM on destroy (instead of shutdown).
        """
        return pulumi.get(self, "stop_on_destroy")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        Tags applied after cloning.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineTimeouts']]:
        return pulumi.get(self, "timeouts")

    @_builtins.property
    @pulumi.getter
    def vga(self) -> pulumi.Output[Optional['outputs.ClonedVirtualMachineVga']]:
        """
        Configure the VGA Hardware. If you want to use high resolution modes (>= 1280x1024x16) you may need to increase the vga memory option. Since QEMU 2.9 the default VGA display type is `std` for all OS types besides some Windows versions (XP and older) which use `cirrus`. The `qxl` option enables the SPICE display server. For win* OS you can select how many independent displays you want, Linux guests can add displays themself. You can also run without any graphic card, using a serial device as terminal. See the [Proxmox documentation](https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm_virtual_machines_settings) section 10.2.8 for more information and available configuration parameters.
        """
        return pulumi.get(self, "vga")

    @_builtins.property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Output[_builtins.str]:
        """
        The VM identifier in the Proxmox cluster.
        """
        return pulumi.get(self, "vm_id")

