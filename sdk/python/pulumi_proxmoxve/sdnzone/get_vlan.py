# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GetVlanResult',
    'AwaitableGetVlanResult',
    'get_vlan',
    'get_vlan_output',
]

@pulumi.output_type
class GetVlanResult:
    """
    A collection of values returned by getVlan.
    """
    def __init__(__self__, bridge=None, dns=None, dns_zone=None, id=None, ipam=None, mtu=None, nodes=None, pending=None, reverse_dns=None, state=None):
        if bridge and not isinstance(bridge, str):
            raise TypeError("Expected argument 'bridge' to be a str")
        pulumi.set(__self__, "bridge", bridge)
        if dns and not isinstance(dns, str):
            raise TypeError("Expected argument 'dns' to be a str")
        pulumi.set(__self__, "dns", dns)
        if dns_zone and not isinstance(dns_zone, str):
            raise TypeError("Expected argument 'dns_zone' to be a str")
        pulumi.set(__self__, "dns_zone", dns_zone)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ipam and not isinstance(ipam, str):
            raise TypeError("Expected argument 'ipam' to be a str")
        pulumi.set(__self__, "ipam", ipam)
        if mtu and not isinstance(mtu, int):
            raise TypeError("Expected argument 'mtu' to be a int")
        pulumi.set(__self__, "mtu", mtu)
        if nodes and not isinstance(nodes, list):
            raise TypeError("Expected argument 'nodes' to be a list")
        pulumi.set(__self__, "nodes", nodes)
        if pending and not isinstance(pending, bool):
            raise TypeError("Expected argument 'pending' to be a bool")
        pulumi.set(__self__, "pending", pending)
        if reverse_dns and not isinstance(reverse_dns, str):
            raise TypeError("Expected argument 'reverse_dns' to be a str")
        pulumi.set(__self__, "reverse_dns", reverse_dns)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def bridge(self) -> _builtins.str:
        """
        The local bridge or OVS switch, already configured on *each* node that allows node-to-node connection.
        """
        return pulumi.get(self, "bridge")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> _builtins.str:
        """
        DNS API server address.
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dnsZone")
    def dns_zone(self) -> _builtins.str:
        """
        DNS domain name. Used to register hostnames, such as `<hostname>.<domain>`. The DNS zone must already exist on the DNS server.
        """
        return pulumi.get(self, "dns_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier of the SDN zone.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ipam(self) -> _builtins.str:
        """
        IP Address Management system.
        """
        return pulumi.get(self, "ipam")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> _builtins.int:
        """
        MTU value for the zone.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence[_builtins.str]:
        """
        The Proxmox nodes which the zone and associated VNets are deployed on
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def pending(self) -> _builtins.bool:
        """
        Indicates if the zone has pending configuration changes that need to be applied.
        """
        return pulumi.get(self, "pending")

    @_builtins.property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> _builtins.str:
        """
        Reverse DNS API server address.
        """
        return pulumi.get(self, "reverse_dns")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Indicates the current state of the zone.
        """
        return pulumi.get(self, "state")


class AwaitableGetVlanResult(GetVlanResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetVlanResult(
            bridge=self.bridge,
            dns=self.dns,
            dns_zone=self.dns_zone,
            id=self.id,
            ipam=self.ipam,
            mtu=self.mtu,
            nodes=self.nodes,
            pending=self.pending,
            reverse_dns=self.reverse_dns,
            state=self.state)


def get_vlan(id: Optional[_builtins.str] = None,
             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetVlanResult:
    """
    Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node's physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_proxmoxve as proxmoxve

    example = proxmoxve.SDNZone.get_vlan(id="vlan1")
    pulumi.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", {
        "id": example.id,
        "nodes": example.nodes,
        "bridge": example.bridge,
        "mtu": example.mtu,
        "dns": example.dns,
        "dns_zone": example.dns_zone,
        "ipam": example.ipam,
        "reverse_dns": example.reverse_dns,
    })
    ```


    :param _builtins.str id: The unique identifier of the SDN zone.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('proxmoxve:SDNZone/getVlan:getVlan', __args__, opts=opts, typ=GetVlanResult).value

    return AwaitableGetVlanResult(
        bridge=pulumi.get(__ret__, 'bridge'),
        dns=pulumi.get(__ret__, 'dns'),
        dns_zone=pulumi.get(__ret__, 'dns_zone'),
        id=pulumi.get(__ret__, 'id'),
        ipam=pulumi.get(__ret__, 'ipam'),
        mtu=pulumi.get(__ret__, 'mtu'),
        nodes=pulumi.get(__ret__, 'nodes'),
        pending=pulumi.get(__ret__, 'pending'),
        reverse_dns=pulumi.get(__ret__, 'reverse_dns'),
        state=pulumi.get(__ret__, 'state'))
def get_vlan_output(id: Optional[pulumi.Input[_builtins.str]] = None,
                    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetVlanResult]:
    """
    Retrieves information about a VLAN Zone in Proxmox SDN. It uses an existing local Linux or OVS bridge to connect to the node's physical interface. It uses VLAN tagging defined in the VNet to isolate the network segments. This allows connectivity of VMs between different nodes.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_proxmoxve as proxmoxve

    example = proxmoxve.SDNZone.get_vlan(id="vlan1")
    pulumi.export("dataProxmoxVirtualEnvironmentSdnZoneVlan", {
        "id": example.id,
        "nodes": example.nodes,
        "bridge": example.bridge,
        "mtu": example.mtu,
        "dns": example.dns,
        "dns_zone": example.dns_zone,
        "ipam": example.ipam,
        "reverse_dns": example.reverse_dns,
    })
    ```


    :param _builtins.str id: The unique identifier of the SDN zone.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('proxmoxve:SDNZone/getVlan:getVlan', __args__, opts=opts, typ=GetVlanResult)
    return __ret__.apply(lambda __response__: GetVlanResult(
        bridge=pulumi.get(__response__, 'bridge'),
        dns=pulumi.get(__response__, 'dns'),
        dns_zone=pulumi.get(__response__, 'dns_zone'),
        id=pulumi.get(__response__, 'id'),
        ipam=pulumi.get(__response__, 'ipam'),
        mtu=pulumi.get(__response__, 'mtu'),
        nodes=pulumi.get(__response__, 'nodes'),
        pending=pulumi.get(__response__, 'pending'),
        reverse_dns=pulumi.get(__response__, 'reverse_dns'),
        state=pulumi.get(__response__, 'state')))
