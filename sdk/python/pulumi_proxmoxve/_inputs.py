# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'HostsEntryArgs',
    'HostsEntryArgsDict',
    'ProviderSshArgs',
    'ProviderSshArgsDict',
    'ProviderSshNodeArgs',
    'ProviderSshNodeArgsDict',
    'Vm2CdromArgs',
    'Vm2CdromArgsDict',
    'Vm2CloneArgs',
    'Vm2CloneArgsDict',
    'Vm2CpuArgs',
    'Vm2CpuArgsDict',
    'Vm2TimeoutsArgs',
    'Vm2TimeoutsArgsDict',
    'Vm2VgaArgs',
    'Vm2VgaArgsDict',
    'GetVm2CloneArgs',
    'GetVm2CloneArgsDict',
    'GetVm2CpuArgs',
    'GetVm2CpuArgsDict',
    'GetVm2TimeoutsArgs',
    'GetVm2TimeoutsArgsDict',
    'GetVm2VgaArgs',
    'GetVm2VgaArgsDict',
]

MYPY = False

if not MYPY:
    class HostsEntryArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The IP address.
        """
        hostnames: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The hostnames.
        """
elif False:
    HostsEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostsEntryArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 hostnames: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] address: The IP address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hostnames: The hostnames.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "hostnames", hostnames)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def hostnames(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The hostnames.
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "hostnames", value)


if not MYPY:
    class ProviderSshArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[bool]]
        """
        Whether to use the SSH agent for authentication. Takes precedence over the `private_key` and `password` fields. Defaults to the value of the `PROXMOX_VE_SSH_AGENT` environment variable, or `false` if not set.
        """
        agent_socket: NotRequired[pulumi.Input[str]]
        """
        The path to the SSH agent socket. Defaults to the value of the `SSH_AUTH_SOCK` environment variable.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProviderSshNodeArgsDict']]]]
        """
        Overrides for SSH connection configuration for a Proxmox VE node.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password used for the SSH connection. Defaults to the value of the `password` field of the `provider` block.
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        The unencrypted private key (in PEM format) used for the SSH connection. Defaults to the value of the `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable.
        """
        socks5_password: NotRequired[pulumi.Input[str]]
        """
        The password for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_PASSWORD` environment variable.
        """
        socks5_server: NotRequired[pulumi.Input[str]]
        """
        The address:port of the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_SERVER` environment variable.
        """
        socks5_username: NotRequired[pulumi.Input[str]]
        """
        The username for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_USERNAME` environment variable.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username used for the SSH connection. Defaults to the value of the `username` field of the `provider` block.
        """
elif False:
    ProviderSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderSshArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[bool]] = None,
                 agent_socket: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderSshNodeArgs']]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 socks5_password: Optional[pulumi.Input[str]] = None,
                 socks5_server: Optional[pulumi.Input[str]] = None,
                 socks5_username: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] agent: Whether to use the SSH agent for authentication. Takes precedence over the `private_key` and `password` fields. Defaults to the value of the `PROXMOX_VE_SSH_AGENT` environment variable, or `false` if not set.
        :param pulumi.Input[str] agent_socket: The path to the SSH agent socket. Defaults to the value of the `SSH_AUTH_SOCK` environment variable.
        :param pulumi.Input[Sequence[pulumi.Input['ProviderSshNodeArgs']]] nodes: Overrides for SSH connection configuration for a Proxmox VE node.
        :param pulumi.Input[str] password: The password used for the SSH connection. Defaults to the value of the `password` field of the `provider` block.
        :param pulumi.Input[str] private_key: The unencrypted private key (in PEM format) used for the SSH connection. Defaults to the value of the `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable.
        :param pulumi.Input[str] socks5_password: The password for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_PASSWORD` environment variable.
        :param pulumi.Input[str] socks5_server: The address:port of the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_SERVER` environment variable.
        :param pulumi.Input[str] socks5_username: The username for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_USERNAME` environment variable.
        :param pulumi.Input[str] username: The username used for the SSH connection. Defaults to the value of the `username` field of the `provider` block.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if agent_socket is not None:
            pulumi.set(__self__, "agent_socket", agent_socket)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if socks5_password is not None:
            pulumi.set(__self__, "socks5_password", socks5_password)
        if socks5_server is not None:
            pulumi.set(__self__, "socks5_server", socks5_server)
        if socks5_username is not None:
            pulumi.set(__self__, "socks5_username", socks5_username)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the SSH agent for authentication. Takes precedence over the `private_key` and `password` fields. Defaults to the value of the `PROXMOX_VE_SSH_AGENT` environment variable, or `false` if not set.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "agent", value)

    @property
    @pulumi.getter(name="agentSocket")
    def agent_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the SSH agent socket. Defaults to the value of the `SSH_AUTH_SOCK` environment variable.
        """
        return pulumi.get(self, "agent_socket")

    @agent_socket.setter
    def agent_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_socket", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProviderSshNodeArgs']]]]:
        """
        Overrides for SSH connection configuration for a Proxmox VE node.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderSshNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password used for the SSH connection. Defaults to the value of the `password` field of the `provider` block.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        The unencrypted private key (in PEM format) used for the SSH connection. Defaults to the value of the `PROXMOX_VE_SSH_PRIVATE_KEY` environment variable.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="socks5Password")
    def socks5_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_PASSWORD` environment variable.
        """
        return pulumi.get(self, "socks5_password")

    @socks5_password.setter
    def socks5_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "socks5_password", value)

    @property
    @pulumi.getter(name="socks5Server")
    def socks5_server(self) -> Optional[pulumi.Input[str]]:
        """
        The address:port of the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_SERVER` environment variable.
        """
        return pulumi.get(self, "socks5_server")

    @socks5_server.setter
    def socks5_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "socks5_server", value)

    @property
    @pulumi.getter(name="socks5Username")
    def socks5_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for the SOCKS5 proxy server. Defaults to the value of the `PROXMOX_VE_SSH_SOCKS5_USERNAME` environment variable.
        """
        return pulumi.get(self, "socks5_username")

    @socks5_username.setter
    def socks5_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "socks5_username", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username used for the SSH connection. Defaults to the value of the `username` field of the `provider` block.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProviderSshNodeArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        The address of the Proxmox VE node.
        """
        name: pulumi.Input[str]
        """
        The name of the Proxmox VE node.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port of the Proxmox VE node.
        """
elif False:
    ProviderSshNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderSshNodeArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 name: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] address: The address of the Proxmox VE node.
        :param pulumi.Input[str] name: The name of the Proxmox VE node.
        :param pulumi.Input[int] port: The port of the Proxmox VE node.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        The address of the Proxmox VE node.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Proxmox VE node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the Proxmox VE node.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class Vm2CdromArgsDict(TypedDict):
        file_id: NotRequired[pulumi.Input[str]]
        """
        The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
elif False:
    Vm2CdromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Vm2CdromArgs:
    def __init__(__self__, *,
                 file_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_id: The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        if file_id is not None:
            pulumi.set(__self__, "file_id", file_id)

    @property
    @pulumi.getter(name="fileId")
    def file_id(self) -> Optional[pulumi.Input[str]]:
        """
        The file ID of the CD-ROM, or `cdrom|none`. Defaults to `none` to leave the CD-ROM empty. Use `cdrom` to connect to the physical drive.
        """
        return pulumi.get(self, "file_id")

    @file_id.setter
    def file_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_id", value)


if not MYPY:
    class Vm2CloneArgsDict(TypedDict):
        id: pulumi.Input[int]
        """
        The ID of the VM to clone.
        """
        retries: NotRequired[pulumi.Input[int]]
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
elif False:
    Vm2CloneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Vm2CloneArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[int],
                 retries: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] id: The ID of the VM to clone.
        :param pulumi.Input[int] retries: The number of retries to perform when cloning the VM (default: 3).
        """
        pulumi.set(__self__, "id", id)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[int]:
        """
        The ID of the VM to clone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[int]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)


if not MYPY:
    class Vm2CpuArgsDict(TypedDict):
        affinity: NotRequired[pulumi.Input[str]]
        """
        The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        architecture: NotRequired[pulumi.Input[str]]
        """
        The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        cores: NotRequired[pulumi.Input[int]]
        """
        The number of CPU cores per socket (defaults to `1`).
        """
        flags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        """
        hotplugged: NotRequired[pulumi.Input[int]]
        """
        The number of hotplugged vCPUs (defaults to `0`).
        """
        limit: NotRequired[pulumi.Input[int]]
        """
        Limit of CPU usage (defaults to `0` which means no limit).
        """
        numa: NotRequired[pulumi.Input[bool]]
        """
        Enable NUMA (defaults to `false`).
        """
        sockets: NotRequired[pulumi.Input[int]]
        """
        The number of CPU sockets (defaults to `1`).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        """
        units: NotRequired[pulumi.Input[int]]
        """
        CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
elif False:
    Vm2CpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Vm2CpuArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[str]] = None,
                 architecture: Optional[pulumi.Input[str]] = None,
                 cores: Optional[pulumi.Input[int]] = None,
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hotplugged: Optional[pulumi.Input[int]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 numa: Optional[pulumi.Input[bool]] = None,
                 sockets: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] affinity: The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param pulumi.Input[str] architecture: The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        :param pulumi.Input[int] cores: The number of CPU cores per socket (defaults to `1`).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] flags: Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        :param pulumi.Input[int] hotplugged: The number of hotplugged vCPUs (defaults to `0`).
        :param pulumi.Input[int] limit: Limit of CPU usage (defaults to `0` which means no limit).
        :param pulumi.Input[bool] numa: Enable NUMA (defaults to `false`).
        :param pulumi.Input[int] sockets: The number of CPU sockets (defaults to `1`).
        :param pulumi.Input[str] type: Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        :param pulumi.Input[int] units: CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if hotplugged is not None:
            pulumi.set(__self__, "hotplugged", hotplugged)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if numa is not None:
            pulumi.set(__self__, "numa", numa)
        if sockets is not None:
            pulumi.set(__self__, "sockets", sockets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU cores that are used to run the VM’s vCPU. The value is a list of CPU IDs, separated by commas. The CPU IDs are zero-based.  For example, `0,1,2,3` (which also can be shortened to `0-3`) means that the VM’s vCPUs are run on the first four CPU cores. Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input[str]]:
        """
        The CPU architecture `<aarch64 | x86_64>` (defaults to the host). Setting `affinity` is only allowed for `root@pam` authenticated user.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU cores per socket (defaults to `1`).
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of additional CPU flags. Use `+FLAG` to enable, `-FLAG` to disable a flag. Custom CPU models can specify any flag supported by QEMU/KVM, VM-specific flags must be from the following set for security reasons: `pcid`, `spec-ctrl`, `ibpb`, `ssbd`, `virt-ssbd`, `amd-ssbd`, `amd-no-ssb`, `pdpe1gb`, `md-clear`, `hv-tlbflush`, `hv-evmcs`, `aes`.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def hotplugged(self) -> Optional[pulumi.Input[int]]:
        """
        The number of hotplugged vCPUs (defaults to `0`).
        """
        return pulumi.get(self, "hotplugged")

    @hotplugged.setter
    def hotplugged(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hotplugged", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Limit of CPU usage (defaults to `0` which means no limit).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def numa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable NUMA (defaults to `false`).
        """
        return pulumi.get(self, "numa")

    @numa.setter
    def numa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "numa", value)

    @property
    @pulumi.getter
    def sockets(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU sockets (defaults to `1`).
        """
        return pulumi.get(self, "sockets")

    @sockets.setter
    def sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sockets", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulated CPU type, it's recommended to use `x86-64-v2-AES` or higher (defaults to `kvm64`). See https://pve.proxmox.com/pve-docs/pve-admin-guide.html#qm*virtual*machines_settings for more information.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[int]]:
        """
        CPU weight for a VM. Argument is used in the kernel fair scheduler. The larger the number is, the more CPU time this VM gets. Number is relative to weights of all the other running VMs.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "units", value)


if not MYPY:
    class Vm2TimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    Vm2TimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Vm2TimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 read: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class Vm2VgaArgsDict(TypedDict):
        clipboard: NotRequired[pulumi.Input[str]]
        """
        Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        """
        memory: NotRequired[pulumi.Input[int]]
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The VGA type (defaults to `std`).
        """
elif False:
    Vm2VgaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Vm2VgaArgs:
    def __init__(__self__, *,
                 clipboard: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] clipboard: Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        :param pulumi.Input[int] memory: The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        :param pulumi.Input[str] type: The VGA type (defaults to `std`).
        """
        if clipboard is not None:
            pulumi.set(__self__, "clipboard", clipboard)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> Optional[pulumi.Input[str]]:
        """
        Enable a specific clipboard. If not set, depending on the display type the SPICE one will be added. Currently only `vnc` is available. Migration with VNC clipboard is not supported by Proxmox.
        """
        return pulumi.get(self, "clipboard")

    @clipboard.setter
    def clipboard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clipboard", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The VGA type (defaults to `std`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetVm2CloneArgsDict(TypedDict):
        id: int
        """
        The ID of the VM to clone.
        """
        retries: int
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
elif False:
    GetVm2CloneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVm2CloneArgs:
    def __init__(__self__, *,
                 id: int,
                 retries: int):
        """
        :param int id: The ID of the VM to clone.
        :param int retries: The number of retries to perform when cloning the VM (default: 3).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retries", retries)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        The ID of the VM to clone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: int):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def retries(self) -> int:
        """
        The number of retries to perform when cloning the VM (default: 3).
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: int):
        pulumi.set(self, "retries", value)


if not MYPY:
    class GetVm2CpuArgsDict(TypedDict):
        affinity: str
        """
        List of host cores used to execute guest processes, for example: '0,5,8-11'
        """
        architecture: str
        """
        The CPU architecture.
        """
        cores: int
        """
        The number of CPU cores per socket.
        """
        flags: Sequence[str]
        """
        Set of additional CPU flags.
        """
        hotplugged: int
        """
        The number of hotplugged vCPUs.
        """
        limit: int
        """
        Limit of CPU usage.
        """
        numa: bool
        """
        Enable NUMA.
        """
        sockets: int
        """
        The number of CPU sockets.
        """
        type: str
        """
        Emulated CPU type.
        """
        units: int
        """
        CPU weight for a VM
        """
elif False:
    GetVm2CpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVm2CpuArgs:
    def __init__(__self__, *,
                 affinity: str,
                 architecture: str,
                 cores: int,
                 flags: Sequence[str],
                 hotplugged: int,
                 limit: int,
                 numa: bool,
                 sockets: int,
                 type: str,
                 units: int):
        """
        :param str affinity: List of host cores used to execute guest processes, for example: '0,5,8-11'
        :param str architecture: The CPU architecture.
        :param int cores: The number of CPU cores per socket.
        :param Sequence[str] flags: Set of additional CPU flags.
        :param int hotplugged: The number of hotplugged vCPUs.
        :param int limit: Limit of CPU usage.
        :param bool numa: Enable NUMA.
        :param int sockets: The number of CPU sockets.
        :param str type: Emulated CPU type.
        :param int units: CPU weight for a VM
        """
        pulumi.set(__self__, "affinity", affinity)
        pulumi.set(__self__, "architecture", architecture)
        pulumi.set(__self__, "cores", cores)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "hotplugged", hotplugged)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "numa", numa)
        pulumi.set(__self__, "sockets", sockets)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def affinity(self) -> str:
        """
        List of host cores used to execute guest processes, for example: '0,5,8-11'
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: str):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def architecture(self) -> str:
        """
        The CPU architecture.
        """
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: str):
        pulumi.set(self, "architecture", value)

    @property
    @pulumi.getter
    def cores(self) -> int:
        """
        The number of CPU cores per socket.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: int):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def flags(self) -> Sequence[str]:
        """
        Set of additional CPU flags.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Sequence[str]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def hotplugged(self) -> int:
        """
        The number of hotplugged vCPUs.
        """
        return pulumi.get(self, "hotplugged")

    @hotplugged.setter
    def hotplugged(self, value: int):
        pulumi.set(self, "hotplugged", value)

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Limit of CPU usage.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: int):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def numa(self) -> bool:
        """
        Enable NUMA.
        """
        return pulumi.get(self, "numa")

    @numa.setter
    def numa(self, value: bool):
        pulumi.set(self, "numa", value)

    @property
    @pulumi.getter
    def sockets(self) -> int:
        """
        The number of CPU sockets.
        """
        return pulumi.get(self, "sockets")

    @sockets.setter
    def sockets(self, value: int):
        pulumi.set(self, "sockets", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Emulated CPU type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def units(self) -> int:
        """
        CPU weight for a VM
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: int):
        pulumi.set(self, "units", value)


if not MYPY:
    class GetVm2TimeoutsArgsDict(TypedDict):
        read: NotRequired[str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetVm2TimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVm2TimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[str]):
        pulumi.set(self, "read", value)


if not MYPY:
    class GetVm2VgaArgsDict(TypedDict):
        clipboard: str
        """
        Enable a specific clipboard.
        """
        memory: int
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        type: str
        """
        The VGA type.
        """
elif False:
    GetVm2VgaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVm2VgaArgs:
    def __init__(__self__, *,
                 clipboard: str,
                 memory: int,
                 type: str):
        """
        :param str clipboard: Enable a specific clipboard.
        :param int memory: The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        :param str type: The VGA type.
        """
        pulumi.set(__self__, "clipboard", clipboard)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def clipboard(self) -> str:
        """
        Enable a specific clipboard.
        """
        return pulumi.get(self, "clipboard")

    @clipboard.setter
    def clipboard(self, value: str):
        pulumi.set(self, "clipboard", value)

    @property
    @pulumi.getter
    def memory(self) -> int:
        """
        The VGA memory in megabytes (4-512 MB). Has no effect with serial display.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: int):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The VGA type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


